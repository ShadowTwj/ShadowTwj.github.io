<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Annotation注解</title>
    <url>/2020/11/13/Annotation%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="三种内置注解"><a href="#三种内置注解" class="headerlink" title="三种内置注解:"></a>三种内置注解:</h4><ol>
<li><p><code>@Override</code>表示当前的方法定义将覆盖超类中的方法。</p>
</li>
<li><p><code>@Deprecated</code>使用了注解为它的元素编译器将发出警告，因为注解@Deprecated是不赞成使用的代码，被弃用的代码。</p>
</li>
<li><p><code>@SuppressWarnings</code>关闭不当编辑器警告信息。</p>
</li>
</ol>
<h4 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h4><blockquote>
<p>定义注解的注解,是java提供给我们用于定义注解的基本注解.在<code>java.lang.annotation</code>包</p>
</blockquote>
<h5 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h5><blockquote>
<p>用于定义注解的作用目标，表示该注解可以用于什么地方，ElementType参数有：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Target(ElementType.TYPE)           用于接口(注解本质上也是接口),类,枚举</span><br><span class="line">@Target(ElementType.FIELD)          用于字段,枚举常量</span><br><span class="line">@Target(ElementType.METHOD)         用于方法</span><br><span class="line">@Target(ElementType.PARAMETER)      用于方法参数</span><br><span class="line">@Target(ElementType.CONSTRUCTOR)    用于构造参数</span><br><span class="line">@Target(ElementType.LOCAL_VARIABLE) 用于局部变量</span><br><span class="line">@Target(ElementType.ANNOTATION_TYPE)用于注解</span><br><span class="line">@Target(ElementType.PACKAGE)        用于包</span><br></pre></td></tr></table></figure>

<h5 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h5><blockquote>
<p>用于定义注解保留策略，即定义的注解类在什么时候存在(源码阶段 or 编译后 or 运行阶段).</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Retention(RetentionPolicy.SOURCE)	注解仅在源码中保留,class文件中不存在</span><br><span class="line">@Retention(RetentionPolicy.CLASS)	注解在源码和class文件中都存在,但运行时不存在,即运行时无法获得,该策略也是默认的保留策略</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)	注解在源码,class文件中存在且运行时可以通过反射机制获取到</span><br></pre></td></tr></table></figure>

<h5 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h5><blockquote>
<p>用于描述其它类型的annotation应该被javadoc文档化,出现在api doc中</p>
</blockquote>
<h5 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h5><blockquote>
<p>允许子类继承父类中的注解</p>
</blockquote>
<h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE&#125;)   ---作用范围 Class</span><br><span class="line">@Retention(RetentionPolicy.CLASS)  ---生命周期：仅保留到.class文件</span><br><span class="line">public @interface 注解名 &#123;定义体&#125;</span><br></pre></td></tr></table></figure>
<p>像<code>@Override</code>这样,没有成员定义的注解称之为标记注解.</p>
<p>自定义注解后，需要处理注解，注解实现的具体逻辑需要自己来写注解处理器</p>
<h3 id="注解处理器"><a href="#注解处理器" class="headerlink" title="注解处理器:"></a>注解处理器:</h3><p>注解处理器可以分为运行时注解处理和编译时注解处理器.运行时处理器需要借助反射机制实现,而编译时处理器则需要借助APT来实现.</p>
<p>无论是运行时注解处理器还是编译时注解处理器,主要工作都是读取注解然后处理特定注解</p>
<h4 id="运行时注解处理器"><a href="#运行时注解处理器" class="headerlink" title="运行时注解处理器"></a>运行时注解处理器</h4><p>运行时注解属性为<code>@Retention(RetentionPolicy.RUNTIME)</code>的注解.</p>
<p>为了运行时能准确获取到注解的相关信息，Java在java.lang.reflect 反射包下新增了<code>AnnotatedElement</code>接口，所有程序元素的(Class,Method)都实现了该接口，通过该接口提供的方法可以利用反射技术地读取注解的信息</p>
<p>常用<code>AnnotatedElement</code>中的反射方法:</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><T extends Annotation> T getAnnotation(Class<T> annotationClass)</td>
<td align="center">返回该元素上存在的制定类型的注解</td>
</tr>
<tr>
<td align="center">Annotation[] getAnnotations()</td>
<td align="center">返回该元素上存在的所有注解</td>
</tr>
<tr>
<td align="center">default <T extends Annotation> T[] getAnnotationsByType(Class<T> annotationClass)</td>
<td align="center">返回该元素指定类型的注解</td>
</tr>
<tr>
<td align="center">default <T extends Annotation> T getDeclaredAnnotation(Class<T> annotationClass)</td>
<td align="center">返回直接存在与该元素上的所有注释</td>
</tr>
<tr>
<td align="center">default <T extends Annotation> T[] getDeclaredAnnotationsByType(Class<T> annotationClass)</td>
<td align="center">返回直接存在该元素岸上某类型的注释</td>
</tr>
<tr>
<td align="center">Annotation[] getDeclaredAnnotations()</td>
<td align="center">返回直接存在与该元素上的所有注释</td>
</tr>
</tbody></table>
<p>通过这些反射方法获取到注解信息，然后对其进行业务操作即可</p>
<h4 id="编译时注解处理器"><a href="#编译时注解处理器" class="headerlink" title="编译时注解处理器"></a>编译时注解处理器</h4><blockquote>
<p>(Annotation Processor Tool)APT,处理注解来生成代码<br>获取注解及生成代码都是在代码编译时候完成的，相比反射在运行时处理注解大大提高了程序性能</p>
</blockquote>
<p>不同于运行时注解处理器，编写编译时注解处理器分两步:</p>
<h5 id="继承AbstractProcessor，实现自己的注解处理器"><a href="#继承AbstractProcessor，实现自己的注解处理器" class="headerlink" title="继承AbstractProcessor，实现自己的注解处理器"></a>继承AbstractProcessor，实现自己的注解处理器</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RouteProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ProcessingEnvironment env)</span></span>&#123; </span><br><span class="line">        <span class="keyword">super</span>.init(processingEnv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annoations, RoundEnvironment env)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">getSupportedAnnotationTypes</span><span class="params">()</span> </span>&#123; </span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">super</span>.getSupportedAnnotationTypes();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SourceVersion <span class="title">getSupportedSourceVersion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">super</span>.getSupportedSourceVersion();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">init(ProcessingEnvironment processingEnv)</td>
<td align="center">该方法有注解处理器自动调用，其中ProcessingEnvironment类提供了很多有用的工具类：Filter，Types，Elements，Messager等</td>
</tr>
<tr>
<td align="center">getSupportedAnnotationTypes()</td>
<td align="center">该方法返回字符串的集合表示该处理器用于处理那些注解</td>
</tr>
<tr>
<td align="center">getSupportedSourceVersion()</td>
<td align="center">该方法用来指定支持的java版本，一般来说我们都是支持到最新版本，因此直接返回SourceVersion.latestSupported(）即可</td>
</tr>
<tr>
<td align="center">process(Set annotations, RoundEnvironment roundEnv)</td>
<td align="center">该方法是注解处理器处理注解的主要地方，我们需要在这里写扫描和处理注解的代码，以及最终生成的java文件。其中需要深入的是RoundEnvironment类，该用于查找出程序元素上使用的注解</td>
</tr>
</tbody></table>
<h5 id="注册处理器-并打成jar包"><a href="#注册处理器-并打成jar包" class="headerlink" title="注册处理器,并打成jar包"></a>注册处理器,并打成jar包</h5><blockquote>
<p>注解和注解处理器必须要新建jar包，然后通过jar包引用。</p>
</blockquote>
<p>为了让java编译器或能够找到自定义的注解处理器我们需要对其进行注册和打包：自定义的处理器需要被打成一个jar，并且需要在jar包的<code>META-INF/services</code>路径下中创建一个固定的文件<code>javax.annotation.processing.Processor</code>,在<code>javax.annotation.processing.Processor</code>文件中需要填写自定义处理器的完整路径名，有几个处理器就需要填写几个</p>
<blockquote>
<p>AbstractProcessor中生成java类，可以使用JavaPoet开源库进行编写，提升效率</p>
</blockquote>
<p>常用的<code>Lombok</code>来消除代码冗余，则是通过APT来实现的<br><img src="/images/Annotation%E6%B3%A8%E8%A7%A3.png"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Bean Copy</title>
    <url>/2019/09/25/Bean-Copy/</url>
    <content><![CDATA[<blockquote>
<p>在日常开发中，经常会遇到需要Bean copy的情况，有好多copy的方法</p>
</blockquote>
<h2 id="克隆的分类"><a href="#克隆的分类" class="headerlink" title="克隆的分类"></a>克隆的分类</h2><ul>
<li>浅克隆（shallow clone），浅克隆是指拷贝对象时仅仅copy对象本身和对象中的基本变量，而不拷贝对象包含的引用指向的对象。</li>
<li>深克隆（deep clone），不仅copy对象本身，而且copy对象包含的引用指向的所有对象。</li>
</ul>
<h2 id="克隆方法"><a href="#克隆方法" class="headerlink" title="克隆方法"></a>克隆方法</h2><h3 id="传统的setter方法"><a href="#传统的setter方法" class="headerlink" title="传统的setter方法"></a>传统的setter方法</h3><p>手工来setter对象的每个属性，这种方法性能非常高，但是写法不优雅、繁琐</p>
<h3 id="Object-clone"><a href="#Object-clone" class="headerlink" title="Object.clone()"></a>Object.clone()</h3><ul>
<li><p>实现<code>java.lang.Cloneable</code>接口<br>Cloneable是标记型的接口，它们内部都没有方法和属性，实现 Cloneable来表示该对象能被克隆，能使用Object.clone()方法。如果没有实现 Cloneable的类对象调用clone()就会抛出CloneNotSupportedException。</p>
</li>
<li><p>重写（Override）Object的<code>clone()</code>方法，并声明为<code>public</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">        String name;</span><br><span class="line">        <span class="keyword">int</span> age;</span><br><span class="line">        </span><br><span class="line">        Student(String name,<span class="keyword">int</span> age) &#123;</span><br><span class="line">            <span class="keyword">this</span>.name=name;</span><br><span class="line">            <span class="keyword">this</span>.age=age;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这只是浅克隆，如果需要深克隆的话则重写（Override）Object类的clone()方法，并且在方法内部调用持有对象的clone方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">        String name;    </span><br><span class="line">        Info info;    </span><br><span class="line"></span><br><span class="line">        Student(String name,Info info) &#123;    </span><br><span class="line">            <span class="keyword">this</span>.name=name;    </span><br><span class="line">            <span class="keyword">this</span>.info=info;    </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">            Student student = (Student) <span class="keyword">super</span>.clone();</span><br><span class="line">            student.info = (Info) student.info.clone();</span><br><span class="line">            <span class="keyword">return</span> student;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以调用<code>Object.clone()</code>方法或调用<code>org.apache.commons.lang3.ObjectUtils</code>的clone()方法来克隆对象了</p>
</li>
</ul>
<h3 id="序列化来实现深克隆"><a href="#序列化来实现深克隆" class="headerlink" title="序列化来实现深克隆"></a>序列化来实现深克隆</h3><p>自定义类需要实现<code>Serializable</code>接口，然后把对象（实际上只是对象的一个拷贝）写到一个流里，再从流里读出来，便可以重建对象</p>
<h3 id="使用第三方工具"><a href="#使用第三方工具" class="headerlink" title="使用第三方工具"></a>使用第三方工具</h3><p>常见的第三方工具大概有这几种:</p>
<blockquote>
<p>Apache 的 BeanUtils<br>Apache 的 PropertyUtils<br>Spring 的 BeanUtils<br>Cglib 的 BeanCopier</p>
</blockquote>
<h4 id="Apache-的-BeanUtils-和-PropertyUtils"><a href="#Apache-的-BeanUtils-和-PropertyUtils" class="headerlink" title="Apache 的 BeanUtils 和 PropertyUtils:"></a>Apache 的 BeanUtils 和 PropertyUtils:</h4><p>Apache的BeanUtils和PropertyUtils<strong>性能非常差</strong>，一般都不使用。<br>这个俩个类都是浅克隆，Apache还提供了 <code>SerializationUtils.clone(T)</code>，T对象需要实现<code>Serializable</code>接口，他属于深克隆。</p>
<h4 id="Spring-的-BeanUtils"><a href="#Spring-的-BeanUtils" class="headerlink" title="Spring 的 BeanUtils"></a>Spring 的 BeanUtils</h4><p>Spring的BeanUtils的<code>BeanUtils.copyProperties()</code>方法相比Apache来说性能要好很多。<br>并且相比Cglib 的 BeanCopier来说，它是静态方法，直接使用即可，非常方便。而BeanCopier不是静态方法，使用前需要使用<code>BeanCopier.create()</code>来初始化。</p>
<h4 id="Cglib-的-BeanCopier"><a href="#Cglib-的-BeanCopier" class="headerlink" title="Cglib 的 BeanCopier"></a>Cglib 的 BeanCopier</h4><p>Cglib 的 BeanCopier相比来说性能是最高的，但是使用前需要通过<code>BeanCopier.create()</code>来初始化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BeanCopier beanCopier = BeanCopier.create(srcClass, dstClass, <span class="keyword">false</span>);</span><br><span class="line">beanCopier.copy(srcObject, dstObject, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>

<p>其实BeanCopier主要花费的时间是调用create()方法，真正执行copy Bean花费的时间较少，所以我们可以进行优化，不是每次执行创建新BeanCopier，将BeanCopier.create()创建的BeanCopier进行缓存</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@UtilityClass</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanCopierUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, BeanCopier&gt; cache = Maps.newConcurrentMap();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &lt;S, D&gt; <span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">(S srcObject, D dstObject)</span> </span>&#123;</span><br><span class="line">    BeanCopier beanCopier = getBeanCopier(srcObject.getClass(), dstObject.getClass());</span><br><span class="line">    beanCopier.copy(srcObject, dstObject, <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> BeanCopier <span class="title">getBeanCopier</span><span class="params">(Class&lt;?&gt; srcClass, Class&lt;?&gt; dstClass)</span> </span>&#123;</span><br><span class="line">    String key = Joiner.on(<span class="string">&#x27;\u0003&#x27;</span>).join(srcClass.getName(), dstClass.getName());</span><br><span class="line">    <span class="keyword">return</span> cache.computeIfAbsent(key, k -&gt; BeanCopier.create(srcClass, dstClass, <span class="keyword">false</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加入缓存后和手工set的性能接近</p>
<hr>
<blockquote>
<p>建议不要使用Apache的工具，如果是偶尔使用为了方便可以使用Spring的BeanUtils，如果是频繁使用时还是推荐使用Cglib 的 BeanCopier</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Elasticsearch安装启动报错</title>
    <url>/2018/01/02/Elasticsearch%E5%AE%89%E8%A3%85%E5%90%AF%E5%8A%A8%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<p>Elasticsearch在启动./elasticsearch时报错:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[2018-01-02T10:47:17,157][WARN ][o.e.b.ElasticsearchUncaughtExceptionHandler] [node-1] uncaught exception in thread [main]</span><br><span class="line">org.elasticsearch.bootstrap.StartupException: java.lang.RuntimeException: can not run elasticsearch as root</span><br><span class="line">	at org.elasticsearch.bootstrap.Elasticsearch.init(Elasticsearch.java:125) ~[elasticsearch-6.1.1.jar:6.1.1]</span><br><span class="line">	at org.elasticsearch.bootstrap.Elasticsearch.execute(Elasticsearch.java:112) ~[elasticsearch-6.1.1.jar:6.1.1]</span><br><span class="line">	at org.elasticsearch.cli.EnvironmentAwareCommand.execute(EnvironmentAwareCommand.java:86) ~[elasticsearch-6.1.1.jar:6.1.1]</span><br><span class="line">	at org.elasticsearch.cli.Command.mainWithoutErrorHandling(Command.java:124) ~[elasticsearch-cli-6.1.1.jar:6.1.1]</span><br><span class="line">	at org.elasticsearch.cli.Command.main(Command.java:90) ~[elasticsearch-cli-6.1.1.jar:6.1.1]</span><br><span class="line">	at org.elasticsearch.bootstrap.Elasticsearch.main(Elasticsearch.java:92) ~[elasticsearch-6.1.1.jar:6.1.1]</span><br><span class="line">	at org.elasticsearch.bootstrap.Elasticsearch.main(Elasticsearch.java:85) ~[elasticsearch-6.1.1.jar:6.1.1]</span><br><span class="line">Caused by: java.lang.RuntimeException: can not run elasticsearch as root</span><br><span class="line">	at org.elasticsearch.bootstrap.Bootstrap.initializeNatives(Bootstrap.java:104) ~[elasticsearch-6.1.1.jar:6.1.1]</span><br><span class="line">	at org.elasticsearch.bootstrap.Bootstrap.setup(Bootstrap.java:171) ~[elasticsearch-6.1.1.jar:6.1.1]</span><br><span class="line">	at org.elasticsearch.bootstrap.Bootstrap.init(Bootstrap.java:322) ~[elasticsearch-6.1.1.jar:6.1.1]</span><br><span class="line">	at org.elasticsearch.bootstrap.Elasticsearch.init(Elasticsearch.java:121) ~[elasticsearch-6.1.1.jar:6.1.1]</span><br><span class="line">	... 6 more</span><br></pre></td></tr></table></figure>
<p>这是因为在Elasticsearch5.0以后不让用root用户直接运行，所以需要创建新用户：<br>1.创建新用户adduser xxx,给新用户添加密码passwd xxx<br>2.root给xxx赋权限，chown -R xxx /elasticsearch安装目录<br>3.切换用户su xxx<br>4.再执行./elasticsearch启动ES</p>
]]></content>
      <categories>
        <category>Elasticsearch</category>
      </categories>
      <tags>
        <tag>Elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>Guava CaChe</title>
    <url>/2017/11/08/Guava-CaChe/</url>
    <content><![CDATA[<p>Guava CaChe是本地（进程内）缓存</p>
<blockquote>
<h4 id="引包"><a href="#引包" class="headerlink" title="引包"></a>引包</h4></blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;  </span><br><span class="line">    &lt;groupId&gt;com.google.guava&lt;&#x2F;groupId&gt;  </span><br><span class="line">    &lt;artifactId&gt;guava&lt;&#x2F;artifactId&gt;  </span><br><span class="line">    &lt;version&gt;19.0&lt;&#x2F;version&gt;  </span><br><span class="line">&lt;&#x2F;dependency&gt;  </span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="Cache接口及其实现"><a href="#Cache接口及其实现" class="headerlink" title="Cache接口及其实现"></a>Cache接口及其实现</h4></blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cache&lt;k, v&gt; cache &#x3D; CacheBuilder.newBuilder()  </span><br><span class="line">        &#x2F;&#x2F;设置cache的初始大小为10，要合理设置该值  </span><br><span class="line">        .initialCapacity(10)  </span><br><span class="line">        &#x2F;&#x2F;设置并发数为5，即同一时间最多只能有5个线程往cache执行写入操作  </span><br><span class="line">        .concurrencyLevel(5)  </span><br><span class="line">        &#x2F;&#x2F;设置cache中的数据在写入之后的存活时间为10秒  </span><br><span class="line">        .expireAfterWrite(10, TimeUnit.SECONDS)  </span><br><span class="line">        &#x2F;&#x2F;构建cache实例  </span><br><span class="line">        .....</span><br><span class="line">        .build();  </span><br></pre></td></tr></table></figure>
<p>接口Cache是泛型，很好的支持了不同类型的key和value<br>TimeUnit.SECONDS 存活时间单位为秒<br>TimeUnit.HOURSC 存活时间单位为小时<br>TimeUnit.DAYS 存活时间单位为天</p>
<p>例如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LoadingCache&lt;Key, Object&gt; cache&#x3D; CacheBuilder.newBuilder()</span><br><span class="line">        .expireAfterWrite(10, TimeUnit.MINUTES)</span><br><span class="line">        .build(</span><br><span class="line">            new CacheLoader&lt;Key, Object&gt;() &#123;</span><br><span class="line">                public Object load(Key key) throws AnyException &#123;</span><br><span class="line">                    return getObject(key);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<h4 id="Cache提供的常用方法"><a href="#Cache提供的常用方法" class="headerlink" title="Cache提供的常用方法"></a>Cache提供的常用方法</h4></blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;** </span><br><span class="line"> * 该接口的实现被认为是线程安全的，即可在多线程中调用 </span><br><span class="line"> * 通过被定义单例使用 </span><br><span class="line"> *&#x2F;  </span><br><span class="line">public interface Cache&lt;K, V&gt; &#123;  </span><br><span class="line">  </span><br><span class="line">  &#x2F;** </span><br><span class="line">   * 通过key获取缓存中的value，若不存在直接返回null </span><br><span class="line">   *&#x2F;  </span><br><span class="line">  V getIfPresent(Object key);  </span><br><span class="line">  </span><br><span class="line">  &#x2F;** </span><br><span class="line">   * 通过key获取缓存中的value，若不存在就通过valueLoader来加载该value </span><br><span class="line">   * 整个过程为 &quot;if cached, return; otherwise create, cache and return&quot; </span><br><span class="line">   * 注意valueLoader要么返回非null值，要么抛出异常，绝对不能返回null </span><br><span class="line">   *&#x2F;  </span><br><span class="line">  V get(K key, Callable&lt;? extends V&gt; valueLoader) throws ExecutionException;  </span><br><span class="line">  </span><br><span class="line">  &#x2F;** </span><br><span class="line">   * 添加缓存，若key存在，就覆盖旧值 </span><br><span class="line">   *&#x2F;  </span><br><span class="line">  void put(K key, V value);  </span><br><span class="line">  </span><br><span class="line">  &#x2F;** </span><br><span class="line">   * 删除该key关联的缓存 </span><br><span class="line">   *&#x2F;  </span><br><span class="line">  void invalidate(Object key);  </span><br><span class="line">  </span><br><span class="line">  &#x2F;** </span><br><span class="line">   * 删除所有缓存 </span><br><span class="line">   *&#x2F;  </span><br><span class="line">  void invalidateAll();  </span><br><span class="line">  </span><br><span class="line">  &#x2F;** </span><br><span class="line">   * 执行一些维护操作，包括清理缓存 </span><br><span class="line">   *&#x2F;  </span><br><span class="line">  void cleanUp();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="清除缓存"><a href="#清除缓存" class="headerlink" title="清除缓存"></a>清除缓存</h4></blockquote>
<h5 id="基于存活时间的清除"><a href="#基于存活时间的清除" class="headerlink" title="基于存活时间的清除"></a>基于存活时间的清除</h5><p>这应该是最常用的清除策略，在构建Cache实例的时候，CacheBuilder提供两种基于存活时间的构建方法：<br>（1）expireAfterAccess(long, TimeUnit)：缓存项在创建后，在给定时间内没有被读/写访问，则清除。<br>（2）expireAfterWrite(long, TimeUnit)：缓存项在创建后，在给定时间内没有被写访问（创建或覆盖），则清除。expireAfterWrite()方法有些类似于redis中的expire命令，但显然它只能设置所有缓存都具有相同的存活时间。</p>
<h5 id="基于容量的清除"><a href="#基于容量的清除" class="headerlink" title="基于容量的清除"></a>基于容量的清除</h5><p>在构建Cache实例的时候，通过CacheBuilder.maximumSize(long)方法可以设置Cache的最大容量数，当缓存数量达到或接近该最大值时，Cache将清除掉那些最近最少使用的缓存。<br>以上是这种方式是以缓存的“数量”作为容量的计算方式，还有另外一种基于“权重”的计算方式。比如每一项缓存所占据的内存空间大小都不一样，可以看作它们有不同的“权重”（weights）。你可以使用CacheBuilder.weigher(Weigher)指定一个权重函数，并且用CacheBuilder.maximumWeight(long)指定最大总重</p>
<h5 id="显式清除"><a href="#显式清除" class="headerlink" title="显式清除"></a>显式清除</h5><p>任何时候，都可以显式地清除缓存项，而不是等到它被回收，Cache接口提供了如下API：<br>（1）个别清除：Cache.invalidate(key)<br>（2）批量清除：Cache.invalidateAll(keys)<br>（3）清除所有缓存项：Cache.invalidateAll()  </p>
<h5 id="基于引用的清除"><a href="#基于引用的清除" class="headerlink" title="基于引用的清除"></a>基于引用的清除</h5><p>在构建Cache实例过程中，通过设置使用弱引用的键、或弱引用的值、或软引用的值，从而使JVM在GC时顺带实现缓存的清除，不过一般不轻易使用这个特性。<br>（1）CacheBuilder.weakKeys()：使用弱引用存储键<br>（2）CacheBuilder.weakValues()：使用弱引用存储值<br>（3）CacheBuilder.softValues()：使用软引用存储值  </p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Guava</tag>
        <tag>Cache</tag>
      </tags>
  </entry>
  <entry>
    <title>EventBus事件总线</title>
    <url>/2017/11/08/EventBus%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF/</url>
    <content><![CDATA[<p>EventBus是Guava的事件处理机制，是设计模式中的观察者模式（生产/消费者编程模型）实现的<br>EventBus类是guava中关注消息的发布和订阅的类，简单的说订阅者通过EventBus注册并订阅事件，发布者将事件发送到EventBus中，EventBus将事件顺序的通知给时间订阅者  </p>
<h4 id="EventBus概述"><a href="#EventBus概述" class="headerlink" title="EventBus概述"></a>EventBus概述</h4><blockquote>
<h5 id="EventBus的三要素"><a href="#EventBus的三要素" class="headerlink" title="EventBus的三要素"></a>EventBus的三要素</h5></blockquote>
<ul>
<li>Event：事件，可以是任意类型的对象。</li>
<li>Subscriber：事件订阅者，在EventBus3.0之前消息处理的方法只能限定于onEvent、onEventMainThread、onEventBackgroundThread和onEventAsync，他们分别代表四种线程模型。而在EventBus3.0之后，事件处理的方法可以随便取名，但是需要添加一个注解@Subscribe，并且要指定线程模型（默认为POSTING），四种线程模型下面会讲到。</li>
<li>Publisher：事件发布者，可以在任意线程任意位置发送事件，直接调用EventBus的post(Object)方法。可以自己实例化EventBus对象，但一般使用EventBus.getDefault()就好了，根据post函数参数的类型，会自动调用订阅相应类型事件的函数。</li>
</ul>
<blockquote>
<h5 id="EventBus的四种ThreadMode（线程模型）"><a href="#EventBus的四种ThreadMode（线程模型）" class="headerlink" title="EventBus的四种ThreadMode（线程模型）"></a>EventBus的四种ThreadMode（线程模型）</h5></blockquote>
<p>EventBus3.0有以下四种ThreadMode： </p>
<ul>
<li>POSTING（默认）：如果使用事件处理函数指定了线程模型为POSTING，那么该事件在哪个线程发布出来的，事件处理函数就会在这个线程中运行，也就是说发布事件和接收事件在同一个线程。在线程模型为POSTING的事件处理函数中尽量避免执行耗时操作，因为它会阻塞事件的传递，甚至有可能会引起ANR。  </li>
<li>MAIN:<br>事件的处理会在UI线程中执行。事件处理时间不能太长，长了会ANR的。</li>
<li>BACKGROUND：如果事件是在UI线程中发布出来的，那么该事件处理函数就会在新的线程中运行，如果事件本来就是子线程中发布出来的，那么该事件处理函数直接在发布事件的线程中执行。在此事件处理函数中禁止进行UI更新操作。  </li>
<li>ASYNC：无论事件在哪个线程发布，该事件处理函数都会在新建的子线程中执行，同样，此事件处理函数中禁止进行UI更新操作。</li>
</ul>
<h4 id="创建EventBus实例"><a href="#创建EventBus实例" class="headerlink" title="创建EventBus实例"></a>创建EventBus实例</h4><p>创建一个EventBus实例，只需要简单的调用构造方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">EventBus eventBus = <span class="keyword">new</span> EventBus();</span><br></pre></td></tr></table></figure>
<p>也提供了一个带参数的构造类,目的只是为了加上一个标识:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">EventBus eventBus = <span class="keyword">new</span> EventBus(TradeAccountEvent.class.getName());</span><br></pre></td></tr></table></figure>
<h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>1.自定义一个事件类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageEvent</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.注册事件：<br><code>EventBus.register(Object)</code>方法，请保证事件生产者和监听者共享相同的EventBus实例。<br>或静态方法<code>EventBus.getDefault().register(this);</code>(3.0支持)</p>
<p>3.订阅事件：<br>这个类需要定义一个只接受一个参数的public方法，参数的类型要和订阅的事件类型一致。<br>需要在方法上加上@Subscribe注解  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Subscribe(threadMode = ThreadMode.MAIN)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">XXX</span><span class="params">(MessageEvent messageEvent)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>threadMode不指定默认为POSTING  </p>
<p>4.发送事件：<br><code>EventBus.post(Object)</code>方法。异步分发可以直接用EventBus的子类AsyncEventBus<br>或静态方法<code>EventBus.getDefault().post(messageEvent);</code>(3.0支持)  </p>
<p>5.取消注册：<br><code>EventBus.unregister(Object)</code>方法<br>或静态方法<code>EventBus.getDefault().unregister(this);</code>(3.0支持)</p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventBusObject</span></span>&#123;</span><br><span class="line">    EventBus eventBus = <span class="keyword">new</span> EventBus();</span><br><span class="line">    <span class="comment">//注册</span></span><br><span class="line">    eventBus.register(<span class="keyword">this</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeCustomer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Object event = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="comment">//发布事件</span></span><br><span class="line">        eventBus.post(event);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//取消注册</span></span><br><span class="line">    eventBus.unregister(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//订阅事件</span></span><br><span class="line">    <span class="meta">@Subscribe</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">(Object e)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Guava</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 8 Optional类深度解析</title>
    <url>/2017/12/29/Java-8-Optional%E7%B1%BB%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<blockquote>
<p>==<strong>原文链接：<a href="http://www.importnew.com/6675.html">http://www.importnew.com/6675.html</a></strong>==  </p>
</blockquote>
<p>身为一名Java程序员，大家可能都有这样的经历：调用一个方法得到了返回值却不能直接将返回值作为参数去调用别的方法。我们首先要判断这个返回值是否为null，只有在非空的前提下才能将其作为其他方法的参数。这正是一些类似Guava的外部API试图解决的问题。一些JVM编程语言比如Scala、Ceylon等已经将对在核心API中解决了这个问题。在我的前一篇文章中，介绍了Scala是如何解决了这个问题。  </p>
<p>新版本的Java，比如Java 8引入了一个新的Optional类。Optional类的Javadoc描述如下：<br>这是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。</p>
<p>本文会逐个探讨Optional类包含的方法，并通过一两个示例展示如何使用。  </p>
<p><strong>of</strong><br>为非null的值创建一个Optional。<br>of方法通过工厂方法创建Optional类。需要注意的是，创建对象时传入的参数不能为null。如果传入参数为null，则抛出NullPointerException 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;调用工厂方法创建Optional实例</span><br><span class="line">Optional&lt;String&gt; name &#x3D; Optional.of(&quot;Sanaulla&quot;);</span><br><span class="line">&#x2F;&#x2F;传入参数为null，抛出NullPointerException.</span><br><span class="line">Optional&lt;String&gt; someNull &#x3D; Optional.of(null);</span><br></pre></td></tr></table></figure>
<p><strong>ofNullable</strong><br>为指定的值创建一个Optional，如果指定的值为null，则返回一个空的Optional。<br>ofNullable与of方法相似，唯一的区别是可以接受参数为null的情况。示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;下面创建了一个不包含任何值的Optional实例</span><br><span class="line">&#x2F;&#x2F;例如，值为&#39;null&#39;</span><br><span class="line">Optional empty &#x3D; Optional.ofNullable(null);</span><br></pre></td></tr></table></figure>
<p><strong>isPresent</strong><br>非常容易理解<br>如果值存在返回true，否则返回false。<br>类似下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;isPresent方法用来检查Optional实例中是否包含值</span><br><span class="line">if (name.isPresent()) &#123;</span><br><span class="line">  &#x2F;&#x2F;在Optional实例内调用get()返回已存在的值</span><br><span class="line">  System.out.println(name.get());&#x2F;&#x2F;输出Sanaulla</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>get</strong><br>如果Optional有值则将其返回，否则抛出NoSuchElementException。<br>上面的示例中，get方法用来得到Optional实例中的值。下面我们看一个抛出NoSuchElementException的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;执行下面的代码会输出：No value present </span><br><span class="line">try &#123;</span><br><span class="line">  &#x2F;&#x2F;在空的Optional实例上调用get()，抛出NoSuchElementException</span><br><span class="line">  System.out.println(empty.get());</span><br><span class="line">&#125; catch (NoSuchElementException ex) &#123;</span><br><span class="line">  System.out.println(ex.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>ifPresent</strong><br>如果Optional实例有值则为其调用consumer，否则不做处理<br>要理解ifPresent方法，首先需要了解Consumer类。简答地说，Consumer类包含一个抽象方法。该抽象方法对传入的值进行处理，但没有返回值。Java8支持不用接口直接通过lambda表达式传入参数。<br>如果Optional实例有值，调用ifPresent()可以接受接口段或lambda表达式。类似下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;ifPresent方法接受lambda表达式作为参数。</span><br><span class="line">&#x2F;&#x2F;lambda表达式对Optional的值调用consumer进行处理。</span><br><span class="line">name.ifPresent((value) -&gt; &#123;</span><br><span class="line">  System.out.println(&quot;The length of the value is: &quot; + value.length());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>orElse</strong><br>如果有值则将其返回，否则返回指定的其它值。<br>如果Optional实例有值则将其返回，否则返回orElse方法传入的参数。示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;如果值不为null，orElse方法返回Optional实例的值。</span><br><span class="line">&#x2F;&#x2F;如果为null，返回传入的消息。</span><br><span class="line">&#x2F;&#x2F;输出：There is no value present!</span><br><span class="line">System.out.println(empty.orElse(&quot;There is no value present!&quot;));</span><br><span class="line">&#x2F;&#x2F;输出：Sanaulla</span><br><span class="line">System.out.println(name.orElse(&quot;There is some value!&quot;));</span><br></pre></td></tr></table></figure>
<p><strong>orElseGet</strong><br>orElseGet与orElse方法类似，区别在于得到的默认值。orElse方法将传入的字符串作为默认值，orElseGet方法可以接受Supplier接口的实现用来生成默认值。示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;orElseGet与orElse方法类似，区别在于orElse传入的是默认值，</span><br><span class="line">&#x2F;&#x2F;orElseGet可以接受一个lambda表达式生成默认值。</span><br><span class="line">&#x2F;&#x2F;输出：Default Value</span><br><span class="line">System.out.println(empty.orElseGet(() -&gt; &quot;Default Value&quot;));</span><br><span class="line">&#x2F;&#x2F;输出：Sanaulla</span><br><span class="line">System.out.println(name.orElseGet(() -&gt; &quot;Default Value&quot;));</span><br></pre></td></tr></table></figure>
<p><strong>orElseThrow</strong><br>如果有值则将其返回，否则抛出supplier接口创建的异常。<br>在orElseGet方法中，我们传入一个Supplier接口。然而，在orElseThrow中我们可以传入一个lambda表达式或方法，如果值不存在来抛出异常。示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  &#x2F;&#x2F;orElseThrow与orElse方法类似。与返回默认值不同，</span><br><span class="line">  &#x2F;&#x2F;orElseThrow会抛出lambda表达式或方法生成的异常 </span><br><span class="line"> </span><br><span class="line">  empty.orElseThrow(ValueAbsentException::new);</span><br><span class="line">&#125; catch (Throwable ex) &#123;</span><br><span class="line">  &#x2F;&#x2F;输出: No value present in the Optional instance</span><br><span class="line">  System.out.println(ex.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ValueAbsentException定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ValueAbsentException extends Throwable &#123;</span><br><span class="line"> </span><br><span class="line">  public ValueAbsentException() &#123;</span><br><span class="line">    super();</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  public ValueAbsentException(String msg) &#123;</span><br><span class="line">    super(msg);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  @Override</span><br><span class="line">  public String getMessage() &#123;</span><br><span class="line">    return &quot;No value present in the Optional instance&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>map</strong><br>map方法文档说明如下：<br>如果有值，则对其执行调用mapping函数得到返回值。如果返回值不为null，则创建包含mapping返回值的Optional作为map方法返回值，否则返回空Optional。<br>map方法用来对Optional实例的值执行一系列操作。通过一组实现了Function接口的lambda表达式传入操作。如果你不熟悉Function接口，可以参考我的这篇博客。map方法示例如下：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;map方法执行传入的lambda表达式参数对Optional实例的值进行修改。</span><br><span class="line">&#x2F;&#x2F;为lambda表达式的返回值创建新的Optional实例作为map方法的返回值。</span><br><span class="line">Optional&lt;String&gt; upperName &#x3D; name.map((value) -&gt; value.toUpperCase());</span><br><span class="line">System.out.println(upperName.orElse(&quot;No value found&quot;));</span><br></pre></td></tr></table></figure>
<p><strong>flatMap</strong><br>如果有值，为其执行mapping函数返回Optional类型返回值，否则返回空Optional。flatMap与map（Funtion）方法类似，区别在于flatMap中的mapper返回值必须是Optional。调用结束时，flatMap不会对结果用Optional封装。<br>flatMap方法与map方法类似，区别在于mapping函数的返回值不同。map方法的mapping函数返回值可以是任何类型T，而flatMap方法的mapping函数必须是Optional。  </p>
<p>参照map函数，使用flatMap重写的示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;flatMap与map（Function）非常类似，区别在于传入方法的lambda表达式的返回类型。</span><br><span class="line">&#x2F;&#x2F;map方法中的lambda表达式返回值可以是任意类型，在map函数返回之前会包装为Optional。 </span><br><span class="line">&#x2F;&#x2F;但flatMap方法中的lambda表达式返回值必须是Optionl实例。 </span><br><span class="line">upperName &#x3D; name.flatMap((value) -&gt; Optional.of(value.toUpperCase()));</span><br><span class="line">System.out.println(upperName.orElse(&quot;No value found&quot;));&#x2F;&#x2F;输出SANAULLA</span><br></pre></td></tr></table></figure>
<p><strong>filter</strong><br>filter个方法通过传入限定条件对Optional实例的值进行过滤。文档描述如下：<br>如果有值并且满足断言条件返回包含该值的Optional，否则返回空Optional。<br>读到这里，可能你已经知道如何为filter方法传入一段代码。是的，这里可以传入一个lambda表达式。对于filter函数我们应该传入实现了Predicate接口的lambda表达式。如果你不熟悉Predicate接口，可以参考这篇文章。  </p>
<p>现在我来看看filter的各种用法，下面的示例介绍了满足限定条件和不满足两种情况：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;filter方法检查给定的Option值是否满足某些条件。</span><br><span class="line">&#x2F;&#x2F;如果满足则返回同一个Option实例，否则返回空Optional。</span><br><span class="line">Optional&lt;String&gt; longName &#x3D; name.filter((value) -&gt; value.length() &gt; 6);</span><br><span class="line">System.out.println(longName.orElse(&quot;The name is less than 6 characters&quot;));&#x2F;&#x2F;输出Sanaulla</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;另一个例子是Optional值不满足filter指定的条件。</span><br><span class="line">Optional&lt;String&gt; anotherName &#x3D; Optional.of(&quot;Sana&quot;);</span><br><span class="line">Optional&lt;String&gt; shortName &#x3D; anotherName.filter((value) -&gt; value.length() &gt; 6);</span><br><span class="line">&#x2F;&#x2F;输出：name长度不足6字符</span><br><span class="line">System.out.println(shortName.orElse(&quot;The name is less than 6 characters&quot;));</span><br></pre></td></tr></table></figure>
<p>以上，我们介绍了Optional类的各个方法。下面通过一个完整的示例对用法集中展示：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class OptionalDemo &#123;</span><br><span class="line"> </span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    &#x2F;&#x2F;创建Optional实例，也可以通过方法返回值得到。</span><br><span class="line">    Optional&lt;String&gt; name &#x3D; Optional.of(&quot;Sanaulla&quot;);</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;创建没有值的Optional实例，例如值为&#39;null&#39;</span><br><span class="line">    Optional empty &#x3D; Optional.ofNullable(null);</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;isPresent方法用来检查Optional实例是否有值。</span><br><span class="line">    if (name.isPresent()) &#123;</span><br><span class="line">      &#x2F;&#x2F;调用get()返回Optional值。</span><br><span class="line">      System.out.println(name.get());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    try &#123;</span><br><span class="line">      &#x2F;&#x2F;在Optional实例上调用get()抛出NoSuchElementException。</span><br><span class="line">      System.out.println(empty.get());</span><br><span class="line">    &#125; catch (NoSuchElementException ex) &#123;</span><br><span class="line">      System.out.println(ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;ifPresent方法接受lambda表达式参数。</span><br><span class="line">    &#x2F;&#x2F;如果Optional值不为空，lambda表达式会处理并在其上执行操作。</span><br><span class="line">    name.ifPresent((value) -&gt; &#123;</span><br><span class="line">      System.out.println(&quot;The length of the value is: &quot; + value.length());</span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;如果有值orElse方法会返回Optional实例，否则返回传入的错误信息。</span><br><span class="line">    System.out.println(empty.orElse(&quot;There is no value present!&quot;));</span><br><span class="line">    System.out.println(name.orElse(&quot;There is some value!&quot;));</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;orElseGet与orElse类似，区别在于传入的默认值。</span><br><span class="line">    &#x2F;&#x2F;orElseGet接受lambda表达式生成默认值。</span><br><span class="line">    System.out.println(empty.orElseGet(() -&gt; &quot;Default Value&quot;));</span><br><span class="line">    System.out.println(name.orElseGet(() -&gt; &quot;Default Value&quot;));</span><br><span class="line"> </span><br><span class="line">    try &#123;</span><br><span class="line">      &#x2F;&#x2F;orElseThrow与orElse方法类似，区别在于返回值。</span><br><span class="line">      &#x2F;&#x2F;orElseThrow抛出由传入的lambda表达式&#x2F;方法生成异常。</span><br><span class="line">      empty.orElseThrow(ValueAbsentException::new);</span><br><span class="line">    &#125; catch (Throwable ex) &#123;</span><br><span class="line">      System.out.println(ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;map方法通过传入的lambda表达式修改Optonal实例默认值。 </span><br><span class="line">    &#x2F;&#x2F;lambda表达式返回值会包装为Optional实例。</span><br><span class="line">    Optional&lt;String&gt; upperName &#x3D; name.map((value) -&gt; value.toUpperCase());</span><br><span class="line">    System.out.println(upperName.orElse(&quot;No value found&quot;));</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;flatMap与map（Funtion）非常相似，区别在于lambda表达式的返回值。</span><br><span class="line">    &#x2F;&#x2F;map方法的lambda表达式返回值可以是任何类型，但是返回值会包装成Optional实例。</span><br><span class="line">    &#x2F;&#x2F;但是flatMap方法的lambda返回值总是Optional类型。</span><br><span class="line">    upperName &#x3D; name.flatMap((value) -&gt; Optional.of(value.toUpperCase()));</span><br><span class="line">    System.out.println(upperName.orElse(&quot;No value found&quot;));</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;filter方法检查Optiona值是否满足给定条件。</span><br><span class="line">    &#x2F;&#x2F;如果满足返回Optional实例值，否则返回空Optional。</span><br><span class="line">    Optional&lt;String&gt; longName &#x3D; name.filter((value) -&gt; value.length() &gt; 6);</span><br><span class="line">    System.out.println(longName.orElse(&quot;The name is less than 6 characters&quot;));</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;另一个示例，Optional值不满足给定条件。</span><br><span class="line">    Optional&lt;String&gt; anotherName &#x3D; Optional.of(&quot;Sana&quot;);</span><br><span class="line">    Optional&lt;String&gt; shortName &#x3D; anotherName.filter((value) -&gt; value.length() &gt; 6);</span><br><span class="line">    System.out.println(shortName.orElse(&quot;The name is less than 6 characters&quot;));</span><br><span class="line"> </span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码输出如下：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sanaulla</span><br><span class="line">No value present</span><br><span class="line">The length of the value is: 8</span><br><span class="line">There is no value present!</span><br><span class="line">Sanaulla</span><br><span class="line">Default Value</span><br><span class="line">Sanaulla</span><br><span class="line">No value present in the Optional instance</span><br><span class="line">SANAULLA</span><br><span class="line">SANAULLA</span><br><span class="line">Sanaulla</span><br><span class="line">The name is less than 6 characters</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Guava</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>Java代理模式</title>
    <url>/2019/12/24/Java%E7%9A%84%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><blockquote>
<p>在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。</p>
</blockquote>
<blockquote>
<p>在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。</p>
</blockquote>
<blockquote>
<p>java中的代理分为：静态代理、动态代理。动态代理又分为jdk代理和Cglib代理。</p>
</blockquote>
<h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>静态代理在使用时，需要定义接口或者父类，被代理的对象和代理对象需要一起实现同一个接口或者继承同一个父类。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h4><ul>
<li><p>抽象接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>委托类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserImpl</span> <span class="keyword">implements</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;name is &quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>代理类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserProxy</span> <span class="keyword">implements</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserProxy</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.user = user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        String result = user.getName(name); </span><br><span class="line">        System.out.println(result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Demo</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        UserProxy userProxy = <span class="keyword">new</span> UserProxy(<span class="keyword">new</span> UserImpl());</span><br><span class="line">        userProxy.getName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h4><blockquote>
<p>代理类不仅是一个隔离客户端和委托类的中介，还可以通过代理类在不修改原有代码的前提下增加一些新功能，是开闭原则(Open for Extension, Closed for Modification)最典型的实践。</p>
<p>代理类可以为委托类预处理消息、过滤消息、把消息转发给委托类以及事后处理消息等。代理类与委托类之间通常会存在关联关系，一个代理类的对象与一个委托类的对象关联，代理类对象本身并不真正实现服务，而是通过调用委托类的对象的相关方法来提供特定的服务。</p>
</blockquote>
</li>
<li><p>优点:可以做到在不修改目标对象的功能前提下,对目标功能扩展；</p>
</li>
<li><p>缺点:因为代理对象需要与目标对象实现一样的接口，所以会有很多代理类，同时，一旦接口增加方法，目标对象与代理对象都要维护。</p>
</li>
</ul>
<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>静态代理的缺点怎么改进呢？让代理类动态的生成是不就可以了呢，也就是<code>动态代理</code></p>
<p><code>动态代理</code>两种最常见的方式：</p>
<ol>
<li>通过实现接口的方式 -&gt; JDK动态代理</li>
<li>通过继承类的方式 -&gt; CGLIB动态代理</li>
</ol>
<h4 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h4><p><strong>JDK动态代理又称接口代理</strong>，基于Java反射机制实现，必须要实现了接口的业务类才能用这种办法生成代理对象。</p>
<p>JDK动态代理主要涉及两个类：<code>java.lang.reflect.Proxy</code> 和 <code>java.lang.reflect.InvocationHandler</code></p>
<p>InvocationHandler 和 Proxy 的主要方法介绍:</p>
<ul>
<li><p><code>java.lang.reflect.InvocationHandler</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义了代理对象调用方法时希望执行的动作，用于集中处理在动态代理类对象上的方法调用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> proxy     被代理的对象 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> method    要调用的方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args      方法调用时所需要参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br></pre></td></tr></table></figure></li>
<li><p><code>java.lang.reflect.Proxy</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造实现指定接口的代理类的一个新实例，所有方法会调用给定处理器对象的 invoke 方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> loader        指定当前目标对象使用类加载器，获取加载器的方法是固定的</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> interfaces    目标对象实现的接口的类型，使用泛型方式确认类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> h             InvocationHandler接口的子类的实例  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          InvocationHandler h)</span></span></span><br></pre></td></tr></table></figure>
<p>  <strong>推荐使用Guava中的 <code>com.google.common.reflect.Reflection</code>的<code>newProxy</code>方法，更加方便</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造实现指定接口的代理类的一个新实例，所有方法会调用给定处理器对象的 invoke 方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> interfaceType</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">newProxy</span><span class="params">(Class&lt;T&gt; interfaceType, InvocationHandler handler)</span></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 返回指定接口的代理类</span></span></span><br><span class="line"><span class="function"><span class="comment"> *</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @param loader        目标对象的类加载</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @param interfaces    目标对象实现的接口类型</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; <span class="title">getProxyClass</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                         Class&lt;?&gt;... interfaces)</span></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 获取指定代理对象所关联的调用处理器</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InvocationHandler <span class="title">getInvocationHandler</span><span class="params">(Object proxy)</span></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 判断cl是否为一个代理类</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isProxyClass</span><span class="params">(Class&lt;?&gt; cl)</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="示例-1"><a href="#示例-1" class="headerlink" title="示例:"></a>示例:</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    User user = (User) Proxy.newProxyInstance(User.class.getClassLoader(), <span class="comment">// 传入ClassLoader</span></span><br><span class="line">                                              User.class.getInterfaces(), <span class="comment">// 传入要实现的接口</span></span><br><span class="line">                                              (object, method, para) -&gt; &#123;</span><br><span class="line">                                                System.out.println(method);</span><br><span class="line">                                                <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;getName&quot;</span>)) &#123;</span><br><span class="line">                                                  System.out.println(<span class="string">&quot;name is &quot;</span> + args[<span class="number">0</span>]);</span><br><span class="line">                                                &#125;</span><br><span class="line">                                                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                                              &#125;); <span class="comment">// 传入处理调用方法的InvocationHandler</span></span><br><span class="line"></span><br><span class="line">    user.getName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>在运行期动态创建一个interface实例的步骤如下：</p>
<ol>
<li>定义一个InvocationHandler实例，它负责实现接口的方法调用；</li>
<li>通过Proxy.newProxyInstance()创建interface实例，它需要3个参数：<ol>
<li>使用的ClassLoader，通常就是接口类的ClassLoader；</li>
<li>需要实现的接口数组，至少需要传入一个接口进去；</li>
<li>用来处理接口方法调用的InvocationHandler实例。</li>
</ol>
</li>
<li>将返回的Object强制转型为接口。</li>
</ol>
<h4 id="Cglib动态代理"><a href="#Cglib动态代理" class="headerlink" title="Cglib动态代理"></a>Cglib动态代理</h4><p><strong>Cglib动态代理又称子类代理</strong>，基于ASM机制实现，通过生成业务类的子类作为代理类。</p>
<h5 id="Cglib子类实现代理的方法"><a href="#Cglib子类实现代理的方法" class="headerlink" title="Cglib子类实现代理的方法:"></a>Cglib子类实现代理的方法:</h5><ol>
<li>需要引入cglib和asm的jar包文件，Spring的核心包里面已经包含了此包；</li>
<li>引入jar包后，就可以在内存中动态构建子类；</li>
<li><strong>代理的类不能为final，否则报错；</strong></li>
<li><strong>目标对象的方法如果为final/static，那么就不会被拦截，即不会执行目标对象额外的方法。</strong></li>
</ol>
<h5 id="示例-2"><a href="#示例-2" class="headerlink" title="示例:"></a>示例:</h5><ul>
<li><p>被代理类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserImpl</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;name is &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>实现MethodInterceptor接口生成方法拦截器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserMethodInterceptor</span>  <span class="keyword">implements</span> <span class="title">MethodInterceptor</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> object 表示要进行增强的对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 表示拦截的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> objects 数组表示参数列表，基本数据类型需要传入其包装类型，如int--&gt;Integer、long-Long、double--&gt;Double</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodProxy 表示对方法的代理，invokeSuper方法表示对被代理对象方法的调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Before: &quot;</span>  + method.getName());</span><br><span class="line">        <span class="comment">// 注意这里是调用 invokeSuper 而不是 invoke，否则死循环，methodProxy.invokesuper执行的是原始类的方法，method.invoke执行的是子类的方法</span></span><br><span class="line">        Object object = methodProxy.invokeSuper(o, objects);</span><br><span class="line">        System.out.println(<span class="string">&quot;After: &quot;</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Demo</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">//继承被代理类</span></span><br><span class="line">        enhancer.setSuperclass(UserImpl.class);</span><br><span class="line">        <span class="comment">//设置回调</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> UserMethodInterceptor());</span><br><span class="line">        <span class="comment">//设置代理类对象</span></span><br><span class="line">        UserImpl user = (UserImpl) enhancer.create();</span><br><span class="line">        <span class="comment">//在调用代理类中方法时会被我们实现的方法拦截器进行拦截</span></span><br><span class="line">        user.getName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="在Spring的AOP编程中"><a href="#在Spring的AOP编程中" class="headerlink" title="在Spring的AOP编程中:"></a>在Spring的AOP编程中:</h4><ul>
<li>如果加入容器的目标对象有实现接口，用JDK代理</li>
<li>如果目标对象没有实现接口，用Cglib代理</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Java字符串生成对应MD5摘要</title>
    <url>/2017/10/13/Java%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%94%9F%E6%88%90%E5%AF%B9%E5%BA%94MD5%E6%91%98%E8%A6%81/</url>
    <content><![CDATA[<p>MD5全名Message-Digest Algorithm 5（信息-摘要算法）是一种不可逆的加密算法  </p>
<p>MD5可以用来一致性验证、数字签名和安全访问认证</p>
<p>在Java中有时需要生成给定字符串的MD5摘要：</p>
<h5 id="1-导包"><a href="#1-导包" class="headerlink" title="1.导包"></a>1.导包</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;commons-codec&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-codec&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.8&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>
<h5 id="2-调用md5Hex方法"><a href="#2-调用md5Hex方法" class="headerlink" title="2.调用md5Hex方法"></a>2.调用md5Hex方法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String str &#x3D; &quot;123456&quot;;</span><br><span class="line">String md5 &#x3D; DigestUtils.md5Hex(str);</span><br><span class="line">System.out.println(md5); </span><br><span class="line">&#x2F;&#x2F;e10adc3949ba59abbe56e057f20f883e</span><br></pre></td></tr></table></figure>
<p>还可以加盐来增加保密性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String salt &#x3D; &quot;MD5盐&quot;;</span><br><span class="line">md5 &#x3D; DigestUtils.md5Hex(salt+str);</span><br><span class="line">System.out.println(md5); </span><br><span class="line">&#x2F;&#x2F;196c6ed9e9e3af1a576f5938b35f1b46</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java线程：Atomic</title>
    <url>/2018/01/09/Java%E7%BA%BF%E7%A8%8B%EF%BC%9AAtomic/</url>
    <content><![CDATA[<blockquote>
<p>==<strong>原文链接：<a href="http://thomaschen2011.iteye.com/blog/1468085">http://thomaschen2011.iteye.com/blog/1468085</a></strong>==  </p>
</blockquote>
<h4 id="一、何谓Atomic？"><a href="#一、何谓Atomic？" class="headerlink" title="一、何谓Atomic？"></a>一、何谓Atomic？</h4><p>Atomic一词跟原子有点关系，后者曾被人认为是最小物质的单位。计算机中的Atomic是指不能分割成若干部分的意思。如果一段代码被认为是Atomic，则表示这段代码在执行过程中，是不能被中断的。通常来说，原子指令由硬件提供，供软件来实现原子方法（某个线程进入该方法后，就不会被中断，直到其执行完成）</p>
<p> 在x86 平台上，CPU提供了在指令执行期间对总线加锁的手段。CPU芯片上有一条引线#HLOCK pin，如果汇编语言的程序中在一条指令前面加上前缀”LOCK”，经过汇编以后的机器代码就使CPU在执行这条指令的时候把#HLOCK pin的电位拉低，持续到这条指令结束时放开，从而把总线锁住，这样同一总线上别的CPU就暂时不能通过总线访问内存了，保证了这条指令在多处理器环境中的原子性。</p>
<h4 id="二、JDK1-5的原子包：java-util-concurrent-atomic"><a href="#二、JDK1-5的原子包：java-util-concurrent-atomic" class="headerlink" title="二、JDK1.5的原子包：java.util.concurrent.atomic"></a>二、JDK1.5的原子包：java.util.concurrent.atomic</h4><p>这个包里面提供了一组原子类。==其基本的特性就是在多线程环境下，当有多个线程同时执行这些类的实例包含的方法时，具有排他性，即当某个线程进入方法，执行其中的指令时，不会被其他线程打断，而别的线程就像自旋锁一样，一直等到该方法执行完成，才由JVM从等待队列中选择一个另一个线程进入，这只是一种逻辑上的理解==。实际上是借助硬件的相关指令来实现的，不会阻塞线程(或者说只是在硬件级别上阻塞了)。其中的类可以分成4组</p>
<ul>
<li>AtomicBoolean，AtomicInteger，AtomicLong，AtomicReference  </li>
<li>AtomicIntegerArray，AtomicLongArray  </li>
<li>AtomicLongFieldUpdater，AtomicIntegerFieldUpdater，AtomicReferenceFieldUpdater  </li>
<li>AtomicMarkableReference，AtomicStampedReference，AtomicReferenceArray  </li>
</ul>
<p>Atomic类的作用:  </p>
<ul>
<li>使得让对单一数据的操作，实现了原子化  </li>
<li>使用Atomic类构建复杂的，无需阻塞的代码<br>访问对2个或2个以上的atomic变量（或者对单个atomic变量进行2次或2次以上的操作）通常认为是需要同步的，以达到让这些操作能被作为一个原子单元。  </li>
</ul>
<h5 id="2-1-AtomicBoolean-AtomicInteger-AtomicLong-AtomicReference"><a href="#2-1-AtomicBoolean-AtomicInteger-AtomicLong-AtomicReference" class="headerlink" title="2.1 AtomicBoolean , AtomicInteger, AtomicLong, AtomicReference"></a>2.1 AtomicBoolean , AtomicInteger, AtomicLong, AtomicReference</h5><p>这四种基本类型用来处理布尔，整数，长整数，对象四种数据。  </p>
<ul>
<li><p>构造函数（两个构造函数）  </p>
</li>
<li><p>默认的构造函数：初始化的数据分别是false，0，0，null  </p>
</li>
<li><p>带参构造函数：参数为初始化的数据 </p>
</li>
<li><p>set( )和get( )方法：可以原子地设定和获取atomic的数据。类似于volatile，保证数据会在主存中设置或读取  </p>
</li>
<li><p>getAndSet( )方法  </p>
</li>
<li><p>原子的将变量设定为新数据，同时返回先前的旧数据  </p>
</li>
<li><p>其本质是get( )操作，然后做set( )操作。尽管这2个操作都是atomic，但是他们合并在一起的时候，就不是atomic。在Java的源程序的级别上，如果不依赖synchronized的机制来完成这个工作，是不可能的。只有依靠native方法才可以。  </p>
</li>
<li><p>compareAndSet( ) 和weakCompareAndSet( )方法  </p>
</li>
<li><p>这两个方法都是conditional modifier方法。这2个方法接受2个参数，一个是期望数据(expected)，一个是新数据(new)；如果atomic里面的数据和期望数据一致，则将新数据设定给atomic的数据，返回true，表明成功；否则就不设定，并返回false。  </p>
</li>
<li><p>对于AtomicInteger、AtomicLong还提供了一些特别的方法。getAndIncrement( )、incrementAndGet( )、getAndDecrement( )、decrementAndGet ( )、addAndGet( )、getAndAdd( )以实现一些加法，减法原子操作。(==注意 –i、++i不是原子操作，其中包含有3个操作步骤：第一步，读取i；第二步，加1或减1；第三步：写回内存==)  </p>
</li>
</ul>
<h6 id="2-1-1-1个例子-使用AtomicReference创建线程安全的堆栈"><a href="#2-1-1-1个例子-使用AtomicReference创建线程安全的堆栈" class="headerlink" title="2.1.1 1个例子-使用AtomicReference创建线程安全的堆栈"></a>2.1.1 1个例子-使用AtomicReference创建线程安全的堆栈</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class LinkedStack&lt;T&gt; &#123;  </span><br><span class="line">  </span><br><span class="line">    private AtomicReference&lt;Node&lt;T&gt;&gt; stacks &#x3D; new AtomicReference&lt;Node&lt;T&gt;&gt;();  </span><br><span class="line">  </span><br><span class="line">    public T push(T e) &#123;  </span><br><span class="line">        Node&lt;T&gt; oldNode, newNode;  </span><br><span class="line">        while (true) &#123; &#x2F;&#x2F;这里的处理非常的特别，也是必须如此的。  </span><br><span class="line">            oldNode &#x3D; stacks.get();  </span><br><span class="line">            newNode &#x3D; new Node&lt;T&gt;(e, oldNode);  </span><br><span class="line">            if (stacks.compareAndSet(oldNode, newNode)) &#123;  </span><br><span class="line">                return e;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    public T pop() &#123;  </span><br><span class="line">        Node&lt;T&gt; oldNode, newNode;  </span><br><span class="line">        while (true) &#123;  </span><br><span class="line">            oldNode &#x3D; stacks.get();  </span><br><span class="line">            newNode &#x3D; oldNode.next;  </span><br><span class="line">            if (stacks.compareAndSet(oldNode, newNode)) &#123;  </span><br><span class="line">                return oldNode.object;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    private static final class Node&lt;T&gt; &#123;  </span><br><span class="line">        private T object;  </span><br><span class="line">          </span><br><span class="line">        private Node&lt;T&gt; next;  </span><br><span class="line">  </span><br><span class="line">        private Node(T object, Node&lt;T&gt; next) &#123;  </span><br><span class="line">            this.object &#x3D; object;  </span><br><span class="line">            this.next &#x3D; next;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h6 id="2-1-2-几个问题"><a href="#2-1-2-几个问题" class="headerlink" title="2.1.2 几个问题"></a>2.1.2 几个问题</h6><p>Q1： compareAndSet和weakCompareAndSet的区别？</p>
<p>A1： 有人认为这是个坑，因为这2个方法其中的内容是一模一样的。疑惑ing（环境JDK1.6.0_20_b02）</p>
<p>Q2：volatile boolean和AtomicBoolean的区别？</p>
<p>Q3：volatile int和AtomicInteger的区别？</p>
<p>Q4：LazySet()和Set()的区别？</p>
]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>转载</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>JetBrick-template模板转换字符串</title>
    <url>/2018/01/11/JetBrick-template%E6%A8%A1%E6%9D%BF%E8%BD%AC%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4><p>jetbrick-template 是一个新一代 Java 模板引擎，具有高性能和高扩展性。 适合于动态 HTML 页面输出或者代码生成，可替代 JSP 页面或者 Velocity 等模板。 指令和 Velocity 相似，表达式和 Java 保持一致，易学易用。  </p>
<p>这里只是简单的利用jetbrick-template模板来转换字符串。  </p>
<h4 id="二、用法"><a href="#二、用法" class="headerlink" title="二、用法"></a>二、用法</h4><p>Maven包:  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;com.github.subchen&lt;&#x2F;groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;jetbrick-template&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;version&gt;2.1.2&lt;&#x2F;version&gt;</span><br><span class="line">  &lt;classifier&gt;sources&lt;&#x2F;classifier&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>例子:  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void jetxTest() &#123;</span><br><span class="line">  &#x2F;&#x2F;创建引擎</span><br><span class="line">  JetEngine jetEngine &#x3D; JetEngine.create();</span><br><span class="line"></span><br><span class="line">  String template &#x3D; &quot;Hello, $&#123;username&#125;&quot;;</span><br><span class="line">  &#x2F;&#x2F;得到JetBrick模板，可以是string也可以是文件</span><br><span class="line">  &#x2F;&#x2F;.getTemplate()传入模板jetx文件路径, .createTemplate()传入模板字符串</span><br><span class="line">  JetTemplate jetTemplate &#x3D; jetEngine.createTemplate(template);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;设置需要替换的变量值</span><br><span class="line">  Map&lt;String, Object&gt; context &#x3D; Maps.newHashMap();</span><br><span class="line">  context.put(&quot;username&quot;, &quot;张三&quot;);</span><br><span class="line"></span><br><span class="line">  StringWriter writer &#x3D; new StringWriter();</span><br><span class="line">  &#x2F;&#x2F;转换模板</span><br><span class="line">  jetTemplate.render(context, writer);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;输出结果</span><br><span class="line">  System.out.println(&quot;------------&quot;);</span><br><span class="line">  System.out.println(writer.toString());</span><br><span class="line">  System.out.println(&quot;------------&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果:  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">------------</span><br><span class="line">Hello, 张三</span><br><span class="line">------------</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JetBrick</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux expect</title>
    <url>/2020/09/13/Linux-expect/</url>
    <content><![CDATA[<blockquote>
<p><code>expect</code> 是基于<a href="http://tcl.tk/man/tcl8.5/TclCmd/contents.htm">Tcl</a>实现的一个脚本语言，用来实现自动和程序交互式通信。类似自动远程登录命令，模拟人手工交互输入密码的过程，从而实现自动远程登录<br><code>expect</code> 的工作流程为:<code>spawn</code>(启动指定进程)—&gt;<code>expect</code>(获取指定关键字)—&gt;<code>send</code>(向指定程序发送指定字符)—&gt;<code>interact</code>(允许用户交互)–&gt;退出结束</p>
</blockquote>
<h3 id="安装expect"><a href="#安装expect" class="headerlink" title="安装expect"></a>安装expect</h3><p>使用<code>expect</code>的前提需要安装，这里以<code>yum</code>安装为例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install -y expect</span><br></pre></td></tr></table></figure>

<h3 id="expect常用命令"><a href="#expect常用命令" class="headerlink" title="expect常用命令"></a>expect常用命令</h3><h4 id="spawn"><a href="#spawn" class="headerlink" title="spawn"></a>spawn</h4><p>启动一个进程，然后所有的<code>expect</code>都在这个进程中进行</p>
<h4 id="expect"><a href="#expect" class="headerlink" title="expect"></a>expect</h4><p>获取匹配信息匹配成功则执行<code>expect</code>后面的程序动作</p>
<blockquote>
<p>example:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">expect &#123;</span><br><span class="line">    “yes&#x2F;no”</span><br><span class="line">    &#123;send “yes\n”;exp_continue&#125;</span><br><span class="line">    “*password:”</span><br><span class="line">    &#123;send “123456\n”&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="exp-continue"><a href="#exp-continue" class="headerlink" title="exp_continue"></a>exp_continue</h4><p>在<code>expect</code>中多次匹配用到，使后面的匹配仍然从第一个关键字开始，否则第一次匹配从第一个关键字开始，但是后面第二次匹配则从第二个关键字开始</p>
<h4 id="send-exp-send"><a href="#send-exp-send" class="headerlink" title="send exp_send"></a>send exp_send</h4><p>用于发送指定的字符串信息</p>
<h4 id="send-user"><a href="#send-user" class="headerlink" title="send_user"></a>send_user</h4><p>把参数输出到标准输出中去，默认的<code>send</code>,<code>exp_send</code>命令都是将参数输出到程序中的，相当于<code>shell</code>中的<code>echo</code></p>
<h4 id="interact"><a href="#interact" class="headerlink" title="interact"></a>interact</h4><p>停留在当前进程，退出<code>expect</code>，交给用户操作</p>
<h4 id="exit"><a href="#exit" class="headerlink" title="exit"></a>exit</h4><p>退出<code>expect</code>脚本，还可以使用该命令指定退出前的一些命令</p>
<blockquote>
<p>example:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exit -onexit &#123;</span><br><span class="line">    exec rm $tmpfile(删除临时文件)</span><br><span class="line">    send_user “Good bye\n”</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><blockquote>
<p><code>expect</code>变量使用方法和<code>Tcl</code>一致</p>
</blockquote>
<h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p>定义变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set host localhost</span><br><span class="line">set passwrod 123456</span><br></pre></td></tr></table></figure>
<blockquote>
<p>example:接收命令行参数为变量</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set host [lindex $argv 0]</span><br><span class="line">set passwrod [lindex $argv 1]</span><br></pre></td></tr></table></figure>
<h4 id="puts"><a href="#puts" class="headerlink" title="puts"></a>puts</h4><p>输出变量</p>
<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><h4 id="eof"><a href="#eof" class="headerlink" title="eof"></a>eof</h4><p><code>expect</code>执行结束 退出</p>
<h4 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a>timeout</h4><p>设置全局性的超时时间，默认是10s</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set timeout 60</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis中#和$的区别</title>
    <url>/2017/11/03/MyBatis%E4%B8%AD-%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<blockquote>
<p>#{ }：解析为一个 JDBC 预编译语句（prepared statement）的参数标记符，在SQL中解析为字符串</p>
</blockquote>
<p>如:  </p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">SELECT * FROM test WHERE id=#&#123;id&#125;</span><br></pre></td></tr></table></figure>

<p>解析为SQL时为</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test1 <span class="keyword">WHERE</span> id<span class="operator">=</span>&quot;1&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>${}：在SQL中解析为变量，不带引号</p>
</blockquote>
<p>如:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">SELECT * FROM $&#123;tableName&#125; WHERE id=&quot;1&quot;</span><br></pre></td></tr></table></figure>

<p>解析为SQL时为</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test2 <span class="keyword">WHERE</span> id<span class="operator">=</span>&quot;1&quot;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>死锁DeadLock</title>
    <url>/2019/09/18/MySQL-DeadLock/</url>
    <content><![CDATA[<h2 id="死锁问题"><a href="#死锁问题" class="headerlink" title="死锁问题"></a>死锁问题</h2><blockquote>
<p>Deadlock found when trying to get lock; try restarting transaction</p>
</blockquote>
<p>发现在批量update时偶尔报Deadlock found when trying to get lock; try restarting transaction错误</p>
<h3 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h3><p>根本原因是两个事物同时批量操作时，有操作相同的记录，但是两个事物操作相同记录的顺序不一样，导致两个两个事物都获取不到锁，互锁了<br><img src="/images/deadlock.jpg" alt="deadlock"></p>
<p>正如阿里Java开发手册中说的一样:</p>
<blockquote>
<p>【强制】对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造 成死锁。<br>说明:线程一需要对表 A、B、C 依次全部加锁后才可以进行更新操作，那么线程二的加锁顺序 也必须是 A、B、C，否则可能出现死锁。</p>
</blockquote>
<hr>
<h3 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h3><ul>
<li>减小事务</li>
<li>给字段排序，按照排序后顺序执行，让死锁变为锁等待。</li>
</ul>
<hr>
<h4 id="减小事物"><a href="#减小事物" class="headerlink" title="减小事物:"></a>减小事物:</h4><p>减小在一个事物中的语句和执行时间，这样只是减小发生deadlock的概率，推荐给字段排序来解决。</p>
<h4 id="给字段排序"><a href="#给字段排序" class="headerlink" title="给字段排序:"></a>给字段排序:</h4><p>看到网上有这样解决的：<br>Change</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> onlineusers <span class="keyword">WHERE</span> datetime <span class="operator">&lt;=</span> now() <span class="operator">-</span> <span class="type">INTERVAL</span> <span class="number">900</span> <span class="keyword">SECOND</span></span><br></pre></td></tr></table></figure>
<p>TO</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> onlineusers <span class="keyword">WHERE</span> id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> onlineusers</span><br><span class="line">    <span class="keyword">WHERE</span> datetime <span class="operator">&lt;=</span> now() <span class="operator">-</span> <span class="type">INTERVAL</span> <span class="number">900</span> <span class="keyword">SECOND</span> <span class="keyword">order</span> <span class="keyword">by</span> id) u;</span><br></pre></td></tr></table></figure>
<p><strong>需要注意这样写可能会非常慢，因为IN中的子查询可能会不走索引，全表扫描，如果表中的数据很多，那这样就会产生很大的问题</strong></p>
<ul>
<li><p>可以修改为join：</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">UPDATE tableName <span class="keyword">AS</span> table1 <span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> tableName <span class="keyword">WHERE</span> <span class="keyword">AND</span> id <span class="keyword">IN</span> (<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>) <span class="keyword">ORDER</span> <span class="keyword">BY</span> id) <span class="keyword">AS</span> table2 <span class="keyword">ON</span> table1.id<span class="operator">=</span>table2.id <span class="keyword">SET</span> column1<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>或者可以修改为:</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">UPDATE tableNmae <span class="keyword">SET</span> column1<span class="operator">=</span><span class="number">1</span> <span class="keyword">WHERE</span> <span class="keyword">AND</span> id <span class="keyword">IN</span> (<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>)  <span class="keyword">ORDER</span> <span class="keyword">BY</span> id;</span><br></pre></td></tr></table></figure>
<p>  MySQL支持这种语法</p>
</li>
<li><p>或者可以在程序中把需要排序的字段排好序，然后再去执行SQL</p>
</li>
</ul>
]]></content>
      <categories>
        <category>DB</category>
      </categories>
      <tags>
        <tag>DB</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Semaphore信号量</title>
    <url>/2017/11/04/Semaphore%E4%BF%A1%E5%8F%B7%E9%87%8F/</url>
    <content><![CDATA[<p>Semaphore为并发包(java.util.concurrent)中提供用于控制某资源同时可以被几个线程访问的类  </p>
<blockquote>
<h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4></blockquote>
<p>信号量主要有两种用途：<br>保护一个重要(代码)部分防止一次超过 N 个线程进入。<br>在两个线程之间发送信号。</p>
<blockquote>
<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4></blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Semaphore(int permits) &#123;  </span><br><span class="line">    sync &#x3D; new NonfairSync(permits);  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>permits 初始许可数，也就是最大访问线程数4</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Semaphore(int permits, boolean fair) &#123;  </span><br><span class="line">    sync &#x3D; (fair)? new FairSync(permits) : new NonfairSync(permits);  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>permits 初始许可数，也就是最大访问线程数<br>fair 当设置为false时，线程获取许可的顺序是无序的，也就是说新线程可能会比等待的老线程会先获得许可;当设置为true时，信号量保证它们调用的顺序（即先进先出；FIFO）</p>
<blockquote>
<h4 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h4></blockquote>
<p>void  acquire() 从信号量获取一个许可，如果无可用许可前将一直阻塞等待<br>void acquire(int permits) 获取指定数目的许可，如果无可用许可前也将会一直阻塞等待<br>boolean tryAcquire() 从信号量尝试获取一个许可，如果无可用许可，直接返回false，不会阻塞<br>boolean tryAcquire(int permits) 尝试获取指定数目的许可，如果无可用许可直接返回false<br>boolean tryAcquire(int permits, long timeout, TimeUnit unit) 在指定的时间内尝试从信号量中获取许可，如果在指定的时间内获取成功，返回true，否则返回false<br>void release() 释放一个许可，别忘了在finally中使用，注意：多次调用该方法，会使信号量的许可数增加，达到动态扩展的效果，如：初始permits 为1， 调用了两次release，最大许可会改变为2<br>int availablePermits() 获取当前信号量可用的许可  </p>
<blockquote>
<h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4></blockquote>
<h5 id="保护重要部分"><a href="#保护重要部分" class="headerlink" title="保护重要部分"></a>保护重要部分</h5><p>如果你将信号量用于保护一个重要部分，试图进入这一部分的代码通常会首先尝试获得一个许可，然后才能进入重要部分(代码块)，执行完之后，再把许可释放掉，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Semaphore semaphore &#x3D; new Semaphore(5);  </span><br><span class="line">  </span><br><span class="line">&#x2F;&#x2F;如果没有许可将一直阻塞</span><br><span class="line">semaphore.acquire();  </span><br><span class="line">...  </span><br><span class="line">semaphore.release();  </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;尝试获取许可，如果没有可用许可则返回false，不会阻塞</span><br><span class="line">if (semaphore.tryAcquire())&#123;</span><br><span class="line">   semaphore.release();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="在线程之间发送信号"><a href="#在线程之间发送信号" class="headerlink" title="在线程之间发送信号"></a>在线程之间发送信号</h5><p>如果你将一个信号量用于在两个线程之间传送信号，通常你应该用一个线程调用 acquire() 方法，而另一个线程调用 release() 方法。<br>如果没有可用的许可，acquire() 调用将会阻塞，直到一个许可被另一个线程释放出来。同理，如果无法往信号量释放更多许可时，一个 release() 调用也会阻塞。<br>通过这个可以对多个线程进行协调。比如，如果线程 1 将一个对象插入到了一个共享列表(list)之后之后调用了 acquire()，而线程 2 则在从该列表中获取一个对象之前调用了 release()，这时你其实已经创建了一个阻塞队列。信号量中可用的许可的数量也就等同于该阻塞队列能够持有的元素个数。</p>
<blockquote>
<h4 id="更多方法"><a href="#更多方法" class="headerlink" title="更多方法"></a>更多方法</h4></blockquote>
<p>java.util.concurrent.Semaphore 类还有很多方法，比如：<br>availablePermits()<br>acquireUninterruptibly()<br>drainPermits()<br>hasQueuedThreads()<br>getQueuedThreads()<br>等等</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring-AOP</title>
    <url>/2020/12/02/Spring-AOP/</url>
    <content><![CDATA[<blockquote>
<p>面向切面编程(AOP)可以实现横切关注点与它们所影响对象之间的解耦，对业务逻辑没有任何侵入<br>使用场景有很多，如：日志、异常、声明式事物、安全、缓存等，包括但不限于这些场景<br>常见的AOP实现有<code>Spring-AOP</code>和<code>AspectJ</code>，<code>Spring-AOP</code>基于动态代理实现，主要总结一下<code>Spring-AOP</code></p>
</blockquote>
<p><img src="/images/Spring-AOP0.png"></p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="切面-Aspect"><a href="#切面-Aspect" class="headerlink" title="切面(Aspect)"></a>切面(Aspect)</h4><p>切面是通知和切点的结合，通知和切点共同定义了切面的全面内容————是什么，在何时和何处完成其功能</p>
<h5 id="通知-Advice"><a href="#通知-Advice" class="headerlink" title="通知(Advice)"></a>通知(Advice)</h5><p>切面的具体功能被称为通知，同时通知不仅定义了切面功能，还定义了切面何时使用，而根据使用时机可以分为5种类型的通知：</p>
<ul>
<li>前置通知(Before)：在目标方法被调用之前调用通知功能</li>
<li>后置通知(After)：在目标方法完成之后调用通知，此时不会关心方法的输出是什么</li>
<li>返回通知(After-returning)：在目标方法成功执行之后调用通知</li>
<li>异常通知(After-throwing)：在目标方法抛出异常后调用通知</li>
<li>环绕通知(Around)：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。环绕通知是最强大的通知类型</li>
</ul>
<blockquote>
<p>在 <code>Spring-AOP</code> 中的环绕通知必须有 <code>ProceedingJoinPoint</code> 这个对象参数，通过它的 <code>proceed()</code> 方法来调用被通知的方法</p>
</blockquote>
<h5 id="切点-Poincut"><a href="#切点-Poincut" class="headerlink" title="切点(Poincut)"></a>切点(Poincut)</h5><p>通知定义了切面的 “什么” 和 “何时” ，切点则是定义了切面的 ”何处“</p>
<p>切点定义了通知被应用的具体位置(在哪些连接点)</p>
<h4 id="连接点-Join-point"><a href="#连接点-Join-point" class="headerlink" title="连接点(Join point)"></a>连接点(Join point)</h4><p>连接点是在应用执行过程中能够应用通知的 ”所有点“</p>
<p>连接点可以是调用方法时、抛出异常时、甚至修改一个字段时，但因为<code>Spring-AOP</code>基于动态代理，所以<code>Spring</code>只支持方法的连接点，而<code>AspectJ</code>和<code>JBoss</code>的AOP框架还提供了字段和构造器接入点。</p>
<p>但是方法拦截则满足了大部分的需求，如果需要方法拦截之外的连接点可以利用<code>AspectJ</code>来补充<code>Spring-AOP</code>的功能</p>
<h4 id="引入-Introduction"><a href="#引入-Introduction" class="headerlink" title="引入(Introduction)"></a>引入(Introduction)</h4><p>添加方法或字段到被通知的类</p>
<h4 id="织入-Weaving"><a href="#织入-Weaving" class="headerlink" title="织入(Weaving)"></a>织入(Weaving)</h4><p>织入是把切面应用到目标对象并创建新的代理对象的过程</p>
<p>织入可以在对象生命周期的多个点织入：</p>
<ul>
<li>编译期：切面在目标类编译期被织入。这种需要特殊的编译器。<code>AspectJ</code>的织入编译器就是以这种方式织入</li>
<li>类加载期：切面在目标类加载到JVM时被织入。这种方式需要特殊的类加载器，可以在目标类被引入应用之前增强该目标类的字节码。<code>AspectJ 5</code>的加载时织入就支持这种方式织入</li>
<li>运行期：切面在应用运行的某个时刻被织入。在织入时，AOP容器会为目标对象动态地创建一个代理对象。**<code>Spring-AOP</code>就是以这种方式织入切面的**</li>
</ul>
<h3 id="定义切点"><a href="#定义切点" class="headerlink" title="定义切点"></a>定义切点</h3><blockquote>
<p>切点用来定位使用通知的地方，在<code>Spring-AOP</code>中使用的是<code>AspectJ</code>的切点表达式语言来定义切点，但是<code>Spring</code>仅支持<code>AspectJ</code>切点指示器的一个子集</p>
</blockquote>
<h4 id="切点表达式"><a href="#切点表达式" class="headerlink" title="切点表达式"></a>切点表达式</h4><h5 id="切点指示器"><a href="#切点指示器" class="headerlink" title="切点指示器"></a>切点指示器</h5><p><code>Spring-AOP</code>所支持的<code>AspectJ</code>的切点指示器</p>
<table>
<thead>
<tr>
<th>AspectJ 指示器</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>arg()</td>
<td>限制连接点匹配参数为指定类型的执行方法</td>
</tr>
<tr>
<td>@args()</td>
<td>限制连接点匹配参数由指定注解标注的执行方法</td>
</tr>
<tr>
<td>execution()</td>
<td>用于匹配是连接点的执行方法</td>
</tr>
<tr>
<td>this()</td>
<td>限制连接点匹配AOP代理的bean引用为指定类型的类</td>
</tr>
<tr>
<td>target</td>
<td>限制连接点匹配目标对象为指定类型的类</td>
</tr>
<tr>
<td>@target()</td>
<td>限制连接点匹配特定的执行对象，这些对象对应的类要具有指定类 型的注解</td>
</tr>
<tr>
<td>within()</td>
<td>限制连接点匹配指定的类型</td>
</tr>
<tr>
<td>@within()</td>
<td>限制连接点匹配指定注解所标注的类型（当使用Spring AOP时，方 法定义在由指定的注解所标注的类里）</td>
</tr>
<tr>
<td>@annotation</td>
<td>限定匹配带有指定注解的连接点</td>
</tr>
</tbody></table>
<p><strong>只有<code>execution</code>指示器是实际执行匹配的，而其他的指示器都是用来限制匹配的</strong></p>
<h5 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h5><p>支持<code>and</code>、<code>or</code>、<code>not</code>关系来连接指示器</p>
<p>在POJO中使用<code>&amp;&amp;</code>、<code>||</code>、<code>!</code>分别代表<code>and</code>、<code>or</code>、<code>not</code>关系</p>
<p>在XML中直接使用<code>and</code>、<code>or</code>、<code>not</code>来连接指示器</p>
<p><img src="/images/Spring-AOP1.jpg"></p>
<h4 id="bean指示器"><a href="#bean指示器" class="headerlink" title="bean指示器"></a>bean指示器</h4><p>除去<code>AspectJ</code>指示器外，<code>Spring</code>还引入了一个新的<code>bean()</code>指示器，用来在切点表达式中使用bean的ID来标识bean。<code>bean()</code>使用<code>bean Id</code>或<code>bean名称</code>作为参数来限制切点只匹配特定的<code>bean</code></p>
<h3 id="注解创建切面"><a href="#注解创建切面" class="headerlink" title="注解创建切面"></a>注解创建切面</h3><blockquote>
<p><code>AspectJ 5</code>支持使用注解来创建切面，使用少量的注解就可以把任意类转变为切面</p>
</blockquote>
<blockquote>
<p><code>Spring</code>同时支持<code>AspectJ</code>注解驱动的切面</p>
</blockquote>
<h4 id="AOP配置注解"><a href="#AOP配置注解" class="headerlink" title="AOP配置注解"></a>AOP配置注解</h4><h5 id="Aspect"><a href="#Aspect" class="headerlink" title="@Aspect"></a>@Aspect</h5><p>表明该类不仅仅是个POJO，还是一个切面</p>
<h5 id="通知注解"><a href="#通知注解" class="headerlink" title="通知注解"></a>通知注解</h5><blockquote>
<p>通知注解对应五种通知类型，来声明通知方法</p>
</blockquote>
<table>
<thead>
<tr>
<th>注解</th>
<th>通知</th>
</tr>
</thead>
<tbody><tr>
<td>@After</td>
<td>通知方法会在目标方法返回或抛出异常后调用</td>
</tr>
<tr>
<td>@AfterReturning</td>
<td>通知方法会在目标方法返回后调用</td>
</tr>
<tr>
<td>@AfterThrowing</td>
<td>通知方法会在目标方法抛出异常后调用</td>
</tr>
<tr>
<td>@Around</td>
<td>通知方法会将目标方法封装起来</td>
</tr>
<tr>
<td>@Before</td>
<td>通知方法会在目标方法调用之前执行</td>
</tr>
</tbody></table>
<h5 id="Pointcut"><a href="#Pointcut" class="headerlink" title="@Pointcut"></a>@Pointcut</h5><p><code>@Pointcut</code>注解可以在一个<code>@AspectJ</code>切面内定义可重用的切点</p>
<p>E.g.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Audience</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Pointcut(&quot;execution(** concert.Performance.perform(..))&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performce</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Before(&quot;performce()&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">silenceCellPhones</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Silencing cell phones&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Around(&quot;performce()&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takeSeats</span><span class="params">(ProceedingJoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">	joinPoint.proceed(joinPoint.getArgs())</span><br><span class="line">    System.out.println(<span class="string">&quot;Taking seats&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@AfterReturning(&quot;performce()&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">applause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;CLAP CLAP CLAP!!!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@AfterThrowing(&quot;performce()&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demandRefund</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Demanding a refund&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过在 <code>performance()</code> 方法上添加 <code>@Pointcut</code> 注解，这样就可以在任何的切点表达式中使用 <code>performance()</code> 了</p>
<p><code>performance()</code> 方法的实际内容并不重要，在这里它实际上应该是空的。其实该方法本身只是一个标识，供 <code>@Pointcut</code> 注解依附。</p>
<h4 id="通过注解引入新功能"><a href="#通过注解引入新功能" class="headerlink" title="通过注解引入新功能"></a>通过注解引入新功能</h4><blockquote>
<p>类似<code>Groovy</code>不直接修改对象或类的定义就能为对象或类增加新的方法，虽然Java不是动态语言，但是通过<code>AOP</code>引用新的接口则可以实现其功能</p>
</blockquote>
<blockquote>
<p>但是当引入接口的方法被调用时，代理会把此调用委托给实现了新接口的某个其他对象。实际上，<strong>一个<code>bean</code>的实现被拆分到了多个类中</strong></p>
</blockquote>
<p>通过<code>@DeclareParents</code>注解可以将新的接口引入到<code>bean</code>中</p>
<p>定义新的接口:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> concert;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Encoreable</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">performEncore</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建切面引入接口:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> concert;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.DeclareParents;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EncodeableIntroducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@DeclareParents(value=&quot;concert.Performce+&quot;,</span></span><br><span class="line"><span class="meta">                  defaultImpl=DefaultEncoreable.class)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Encoreable encoreable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>@DeclareParents</code> 注解由三部分组成：</p>
<ul>
<li><code>value</code> 属性指定了哪种类型的 <code>bean</code> 要引入该接口。在本例中，也就是所有实现 <code>Performance</code> 的类型。（标记符后面的加号表示是 <code>Performance</code> 的所有子类型，而不是 Performance 本身。）</li>
<li><code>defaultImpl</code> 属性指定了为引入功能提供实现的类。在这里，我们指定的是 <code>DefaultEncoreable</code> 提供实现。</li>
<li><code>@DeclareParents</code> 注解所标注的静态属性指明了要引入了接口。在这里，我们所引入的是 Encoreable 接口。</li>
</ul>
<h3 id="XML中声明切面"><a href="#XML中声明切面" class="headerlink" title="XML中声明切面"></a>XML中声明切面</h3><h4 id="AOP配置元素"><a href="#AOP配置元素" class="headerlink" title="AOP配置元素"></a>AOP配置元素</h4><p>在 Spring 的 aop 命名空间中，提供了多个元素用来在 XML 中声明切面</p>
<table>
<thead>
<tr>
<th>AOP 配置元素</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;aop:advisor&gt;</td>
<td>定义 AOP 通知器</td>
</tr>
<tr>
<td>&lt;aop:after&gt;</td>
<td>定义 AOP 后置通知（不管被通知的方法是否执行成功）</td>
</tr>
<tr>
<td>&lt;aop:after-returning&gt;</td>
<td>定义 AOP 返回通知</td>
</tr>
<tr>
<td>&lt;aop:after-throwing&gt;</td>
<td>定义 AOP 异常通知</td>
</tr>
<tr>
<td>&lt;aop:around&gt;</td>
<td>定义 AOP 环绕通知</td>
</tr>
<tr>
<td>&lt;aop:aspect&gt;</td>
<td>定义一个切面</td>
</tr>
<tr>
<td>&lt;aop:aspectj-autoproxy&gt;</td>
<td>启用 @AspectJ 注解驱动的切面</td>
</tr>
<tr>
<td>&lt;aop:before&gt;</td>
<td>定义一个 AOP 前置通知</td>
</tr>
<tr>
<td>&lt;aop:config&gt;</td>
<td>顶层的 AOP 配置元素。大多数的元素必须包含在元素内</td>
</tr>
<tr>
<td>&lt;aop:declare-parents&gt;</td>
<td>以透明的方式为被通知的对象引入额外的接口</td>
</tr>
<tr>
<td>&lt;aop:pointcut&gt;</td>
<td>定义一个切点</td>
</tr>
</tbody></table>
<p>E.g.</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;audience&quot;</span>&gt;</span></span><br><span class="line">    &lt;aop:pointcut</span><br><span class="line">      id=&quot;performance&quot;</span><br><span class="line">      expressions=&quot;execution(** concert.Performance.perform(..))&quot; /&gt;</span><br><span class="line">  </span><br><span class="line">    &lt;aop:before</span><br><span class="line">      pointcut-ref=&quot;performance&quot;</span><br><span class="line">      method=&quot;silenceCellPhones&quot; /&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;aop:around</span><br><span class="line">      pointcut-ref=&quot;performance&quot;</span><br><span class="line">      method=&quot;takeSeats&quot; /&gt;</span><br><span class="line">      </span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:after-returning</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">pointcut</span>=<span class="string">&quot;execution(** concert.Performance.perform(..))&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">method</span>=<span class="string">&quot;applause&quot;</span> /&gt;</span></span><br><span class="line">      </span><br><span class="line">    &lt;aop:after-throwing</span><br><span class="line">      pointcut-ref=&quot;performance&quot;</span><br><span class="line">      method=&quot;demandRefund&quot; /&gt;</span><br><span class="line">      </span><br><span class="line">  <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="通过切面引入新功能"><a href="#通过切面引入新功能" class="headerlink" title="通过切面引入新功能"></a>通过切面引入新功能</h4><p>使用 <code>@DeclareParents</code> 注解可以为被通知的方法引入新的方法，使用 <code>Spring aop</code> 命名空间中的 <code>&lt;aop:declare-parents&gt;</code> 元素，可以实现相同的功能</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">  &lt;aop:delate-parents</span><br><span class="line">    types-matching=&quot;concert.Performance+&quot;</span><br><span class="line">    implement-interface=&quot;concert.Encoreable&quot;</span><br><span class="line">    default-impl=&quot;concert.DefaultEncoreable&quot; /&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>types-matching</code>类型匹配，匹配为哪些<code>bean</code>引入接口</li>
<li><code>implement-interface</code>指定新加的接口</li>
<li><code>default-impl</code>用全限定类名来显式指定新加接口的实现</li>
<li><code>delegate-ref</code>还支持引用了一个<code>Spring bean</code>作为引入接口的实现</li>
</ul>
<h3 id="启用AspectJ自动代理"><a href="#启用AspectJ自动代理" class="headerlink" title="启用AspectJ自动代理"></a>启用AspectJ自动代理</h3><p><strong>无论是注解创建、还是XML声明切面，都需要启用自动代理，来创建切面的代理，否则切面不会生效</strong></p>
<p>启用自动代理有两种方式：</p>
<ul>
<li><p>在<code>JavaConfig</code>中启用</p>
<blockquote>
<p>配置类的类级别上通过使用 <code>@EnableAspectJAutoProxy</code> 注解启用自动代理功能</p>
</blockquote>
</li>
<li><p> 在<code>XML</code>中启用</p>
<blockquote>
<p>使用 Spring aop 命名空间中的 <code>&lt;aop:aspectj-autoproxy/&gt;</code> 元素</p>
</blockquote>
</li>
</ul>
<h3 id="注入AspectJ切面"><a href="#注入AspectJ切面" class="headerlink" title="注入AspectJ切面"></a>注入AspectJ切面</h3><blockquote>
<p>虽然 <code>Spring AOP</code> 能够满足许多应用的切面需求，但是与 <code>AspectJ</code> 相比，<code>Spring AOP</code> 是一个功能比较弱的 <code>AOP</code> 解决方案。<code>AspectJ</code> 提供了 <code>Spring AOP</code> 所不能支持的许多类型的切点</p>
</blockquote>
<p><code>AspectJ</code> 可以织入到任意的Java应用程序中，而我们可以借助 <code>Spring</code> 的依赖注入把 <code>bean</code> 装配进 <code>AspectJ</code> 切面中，这样更为方便</p>
<h4 id="用AspectJ实现切面"><a href="#用AspectJ实现切面" class="headerlink" title="用AspectJ实现切面"></a>用AspectJ实现切面</h4><p>创建 <code>AspectJ</code> 的切面需要使用扩展的Java语言</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.aspect.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> aspect AspectInject &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AspectInject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Pointcut（切入点）：定义了相应Advice要发生的地方。</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 定义切入点的常用的两种方式：</span></span><br><span class="line"><span class="comment">     * 1、使用正则表达式。</span></span><br><span class="line"><span class="comment">     * 2、使用AspectJ表达式（Https://www.iteye.com/blog/jinnianshilongnian-1415606）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">pointcut <span class="title">printInfo</span><span class="params">()</span>:<span class="title">execution</span><span class="params">(* xxx.xxx.xxx.xxx.printInfo(..)</span>)</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造器切点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">pointcut <span class="title">constructEntity</span><span class="params">()</span>:<span class="title">execution</span><span class="params">(xxx.xxx.xxx.xxx.User.new()</span>)</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Advice定义了在Pointcut（切入点）具体要做的操作。</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 切入点在AOP中有多种类型，但在Spring中只有方法类型。</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * before advice, 前置。</span></span><br><span class="line"><span class="comment">     * after return advice, 后置（出错不执行）。</span></span><br><span class="line"><span class="comment">     * after throwing advice, 后置（出错才执行）。</span></span><br><span class="line"><span class="comment">     * after(final) advice, 后置（怎么都执行）。</span></span><br><span class="line"><span class="comment">     * around advice, 环绕（前后都执行）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"> </span><br><span class="line">    before():printInfo()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------printInfo()方法的前置------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    after():printInfo()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------printInfo()的后置------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    before():constructEntity()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------new User()时候的前置------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    after():constructEntity()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-------new User()时候的后置------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用aspectOf-方法注入"><a href="#使用aspectOf-方法注入" class="headerlink" title="使用aspectOf()方法注入"></a>使用aspectOf()方法注入</h4><p><code>Spring bean</code> 由 <code>Spring</code> 容器初始化，但是 <code>AspectJ</code> 切面是由 <code>AspectJ</code> 在运行期创建的。等到 <code>Spring</code> 有机会为 <code>AspectJ</code> 切面注入 <code>bean</code> 时，切面已经被实例化了。</p>
<p>所有的 <code>AspectJ</code> 切面都提供了一个静态的 <code>aspectOf()</code> 方法，该方法返回切面的一个单例。所以为了获得切面的实例，我们必须使用 <code>factory-method</code> 来调用 <code>asepctOf()</code> 方法</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.aspect.test.AspectInject&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;aspectOf&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>


<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul>
<li>《Spring 实战（第 4 版）》</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot自动配置</title>
    <url>/2021/06/04/SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<blockquote>
<p>SpringBoot的一个很重要的特性就是自动配置，使用注解，让服务不再需要xml等各种配置文件<br>然后使用main方法一键启动</p>
</blockquote>
<h2 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h2><p><code>@SpringBootApplication</code> 注解是 SpringBoot 的源头，一切都要从该注解开始说起</p>
<p>标注在类上时，表示该类是 SpringBoot 的主配置类，并从该类中的 <code>main</code> 方法来启动 SpringBoot 应用</p>
<p>注解源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(excludeFilters = &#123;</span></span><br><span class="line"><span class="meta">		@Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span></span><br><span class="line"><span class="meta">		@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br></pre></td></tr></table></figure>

<p>可以看出主要包含了三个注解：</p>
<ul>
<li><code>@SpringBootConfiguration</code></li>
<li><code>@ComponentScan</code></li>
<li><code>@EnableAutoConfiguration</code></li>
</ul>
<h3 id="SpringBootConfiguration"><a href="#SpringBootConfiguration" class="headerlink" title="@SpringBootConfiguration"></a>@SpringBootConfiguration</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootConfiguration &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看 <code>@SpringBootConfiguration</code> 的源码发现其实就是一个 <code>@Configuration</code> 注解，表示这是一个 SpringBoot 的配置类</p>
<h3 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h3><p><code>@ComponentScan</code> 表示开启组件扫描</p>
<p>默认是扫描<strong>当前类</strong>下的package。将 <code>@Controller/@Service/@Component/@Repository</code> 等注解加载到IOC容器中</p>
<h3 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h3><p><code>@EnableAutoConfiguration</code> 表示开启自动配置，SpringBoot 自动配置的原理都在这个注解中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(AutoConfigurationImportSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br></pre></td></tr></table></figure>

<p><code>@EnableAutoConfiguration</code> 又主要包含 <code>@Import</code>、<code>@AutoConfigurationPackage</code> 俩个注解，先看下重点 <code>@Import</code> 这个注解</p>
<h4 id="Import"><a href="#Import" class="headerlink" title="@Import"></a>@Import</h4><p><code>@Import</code> 注解是用来导入配置类或者一些需要前置加载的类，可以将多个配置类融合成一个配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Import &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> Configuration&#125;, &#123;<span class="doctag">@link</span> ImportSelector&#125;, &#123;<span class="doctag">@link</span> ImportBeanDefinitionRegistrar&#125;</span></span><br><span class="line"><span class="comment">	 * or regular component classes to import.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	Class&lt;?&gt;[] value();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看代码可以看出，有三种使用方式：</p>
<ul>
<li>导入普通 Java 类，导入的类会被加载为 Bean</li>
<li>导入 <code>ImportSelector</code> 接口实现</li>
<li>导入 <code>ImportBeanDefinitionRegistrar</code> 接口实现</li>
</ul>
<ol>
<li><p>ImportSelector</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	* Select and return the names of which class(es) should be imported based on</span></span><br><span class="line"><span class="comment">	* the &#123;<span class="doctag">@link</span> AnnotationMetadata&#125; of the importing @&#123;<span class="doctag">@link</span> Configuration&#125; class.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	String[] selectImports(AnnotationMetadata importingClassMetadata);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 接口中只有一个 <code>selectImports</code> 方法，用于返回全类名数组，会把返回数组中的类全部导入</p>
</li>
<li><p>ImportBeanDefinitionRegistrar</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	* Register bean definitions as necessary based on the given annotation metadata of</span></span><br><span class="line"><span class="comment">	* the importing &#123;<span class="doctag">@code</span> <span class="doctag">@Configuration</span>&#125; class.</span></span><br><span class="line"><span class="comment">	* &lt;p&gt;Note that &#123;<span class="doctag">@link</span> BeanDefinitionRegistryPostProcessor&#125; types may &lt;em&gt;not&lt;/em&gt; be</span></span><br><span class="line"><span class="comment">	* registered here, due to lifecycle constraints related to &#123;<span class="doctag">@code</span> <span class="doctag">@Configuration</span>&#125;</span></span><br><span class="line"><span class="comment">	* class processing.</span></span><br><span class="line"><span class="comment">	* <span class="doctag">@param</span> importingClassMetadata annotation metadata of the importing class</span></span><br><span class="line"><span class="comment">	* <span class="doctag">@param</span> registry current bean definition registry</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <code>registerBeanDefinitions</code> 它可以手动注册bean到容器中</p>
</li>
</ol>
<h4 id="AutoConfigurationImportSelector-class"><a href="#AutoConfigurationImportSelector-class" class="headerlink" title="AutoConfigurationImportSelector.class"></a>AutoConfigurationImportSelector.class</h4><p><code>AutoConfigurationImportSelector.class</code> 类实现了 <code>ImportSelector</code> 接口，其中的核心方法是 <code>selectImports</code>，来返回需要导入的组件的全类名数组</p>
<ul>
<li><p><code>selectImports</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">	<span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line">		<span class="keyword">return</span> NO_IMPORTS;</span><br><span class="line">	&#125;</span><br><span class="line">	AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader</span><br><span class="line">			.loadMetadata(<span class="keyword">this</span>.beanClassLoader);</span><br><span class="line">	AnnotationAttributes attributes = getAttributes(annotationMetadata);</span><br><span class="line">	<span class="comment">//获取全类名数组</span></span><br><span class="line">	List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata,</span><br><span class="line">			attributes);</span><br><span class="line">	configurations = removeDuplicates(configurations);</span><br><span class="line">	Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);</span><br><span class="line">	checkExcludedClasses(configurations, exclusions);</span><br><span class="line">	configurations.removeAll(exclusions);</span><br><span class="line">	configurations = filter(configurations, autoConfigurationMetadata);</span><br><span class="line">	fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">	<span class="keyword">return</span> StringUtils.toStringArray(configurations);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>getCandidateConfigurations</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata,</span></span></span><br><span class="line"><span class="function"><span class="params">		AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//获取EnableAutoConfiguration.class对应的全类名数组</span></span><br><span class="line">	List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(</span><br><span class="line">			getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader());</span><br><span class="line">	Assert.notEmpty(configurations,</span><br><span class="line">			<span class="string">&quot;No auto configuration classes found in META-INF/spring.factories. If you &quot;</span></span><br><span class="line">					+ <span class="string">&quot;are using a custom packaging, make sure that file is correct.&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> configurations;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; getSpringFactoriesLoaderFactoryClass() &#123;</span><br><span class="line">	<span class="keyword">return</span> EnableAutoConfiguration.class;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>loadFactoryNames</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">loadFactoryNames</span><span class="params">(Class&lt;?&gt; factoryClass, <span class="meta">@Nullable</span> ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">	String factoryClassName = factoryClass.getName();</span><br><span class="line">	<span class="comment">//返回 META-INF/spring.factories 文件下 EnableAutoConfiguration.class 对应的所有值</span></span><br><span class="line">	<span class="keyword">return</span> loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>loadSpringFactories</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从当前项目的类路径中获取所有 META-INF/spring.factories 这个文件下的信息。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(<span class="meta">@Nullable</span> ClassLoader classLoader) &#123;</span><br><span class="line">	MultiValueMap&lt;String, String&gt; result = cache.get(classLoader);</span><br><span class="line">	<span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">//FACTORIES_RESOURCE_LOCATION:META-INF/spring.factories</span></span><br><span class="line">		Enumeration&lt;URL&gt; urls = (classLoader != <span class="keyword">null</span> ?</span><br><span class="line">				classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :</span><br><span class="line">				ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));</span><br><span class="line">		result = <span class="keyword">new</span> LinkedMultiValueMap&lt;&gt;();</span><br><span class="line">		<span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">			URL url = urls.nextElement();</span><br><span class="line">			UrlResource resource = <span class="keyword">new</span> UrlResource(url);</span><br><span class="line">			Properties properties = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">			<span class="keyword">for</span> (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">				String factoryClassName = ((String) entry.getKey()).trim();</span><br><span class="line">				<span class="keyword">for</span> (String factoryName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) &#123;</span><br><span class="line">					result.add(factoryClassName, factoryName.trim());</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cache.put(classLoader, result);</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Unable to load factories from location [&quot;</span> +</span><br><span class="line">				FACTORIES_RESOURCE_LOCATION + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="META-INF-spring-factories"><a href="#META-INF-spring-factories" class="headerlink" title="META-INF/spring.factories"></a>META-INF/spring.factories</h4><p><code>META-INF/spring.factories</code> 在很多第三方依赖中都会有这个文件，第三方依赖通过这个文件并配置 <code>EnableAutoConfiguration</code> 参数，然后自动配置会把这个参数下面的所有类都配置到 Spring 容器中，如图</p>
<p><img src="/images/SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE0.jpg" alt="image"></p>
<h4 id="AutoConfigurationPackage"><a href="#AutoConfigurationPackage" class="headerlink" title="@AutoConfigurationPackage"></a>@AutoConfigurationPackage</h4><p><code>@EnableAutoConfiguration</code> 注解中的另一个注解 <code>@AutoConfigurationPackage</code>，是用来自动配置包的，将主配置类 <code>@SpringBootConfiguration</code> 标注的类，所在包及下面所有子包里面的所有组件扫描到 Spring 容器中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Import(AutoConfigurationPackages.Registrar.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AutoConfigurationPackage &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>AutoConfigurationPackage</code> 注解依然使用了 <code>import</code> 注解，不过使用的是 <code>ImportBeanDefinitionRegistrar</code> 接口实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Registrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span>, <span class="title">DeterminableImports</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="comment">//把所在包及其子包里边的组件扫描注册到Spring容器中</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata,</span></span></span><br><span class="line"><span class="function"><span class="params">			BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">		register(registry, <span class="keyword">new</span> PackageImport(metadata).getPackageName());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Set&lt;Object&gt; <span class="title">determineImports</span><span class="params">(AnnotationMetadata metadata)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Collections.singleton(<span class="keyword">new</span> PackageImport(metadata));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p> SpringBoot的自动装配是由 <code>@EnableAutoConfiguration</code> 注解来实现的，而 <code>@EnableAutoConfiguration</code> 注解又是通过 <code>@AutoConfigurationPackage</code> 和 <code>@Import(AutoConfigurationImportSelector.class)</code> 来实现服务自身的自动配置和第三方依赖的自动配置</p>
<p>注解关系如图：</p>
<p> <img src="/images/SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE1.png" alt="image"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring—@Transactional注解</title>
    <url>/2018/03/01/Spring%E2%80%94-Transactional%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<p>在日常开发中事物管理是非常重要的，当出现异常情况时，它可以保证数据的一致性。  </p>
<h3 id="Spring事物管理方式"><a href="#Spring事物管理方式" class="headerlink" title="Spring事物管理方式"></a>Spring事物管理方式</h3><p>Spring也对事物做了丰富的支持。Spring 事务管理分为编码式和声明式的两种方式。  </p>
<p>编程式事务指的是通过编码方式实现事务,编程式事务管理使用TransactionTemplate或者直接使用底层的PlatformTransactionManager。对于编程式事务管理，spring推荐使用TransactionTemplate。  </p>
<p>声明式事务基于 AOP,其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。  </p>
<p>声明式事务管理使业务代码逻辑不受污染, 因此在实际使用中声明式事务用的比较多。但是声明式事物管理的最小级别是方法级，而编程式事物管理的的最小级别是代码级。  </p>
<p>声明式事务有两种方式，一种是在配置文件（xml）中做相关的事务规则声明，另一种是基于@Transactional 注解的方式。注释配置是目前流行的使用方式。本文介绍的就是基于@Transactional注解的方式。  </p>
<h3 id="实现-Transactional-注解管理事务的步骤"><a href="#实现-Transactional-注解管理事务的步骤" class="headerlink" title="实现@Transactional 注解管理事务的步骤"></a>实现@Transactional 注解管理事务的步骤</h3><p>使用@Transactional 注解管理事务的实现步骤分为两步</p>
<h4 id="第一步：在-xml-配置文件中添加事务配置信息"><a href="#第一步：在-xml-配置文件中添加事务配置信息" class="headerlink" title="第一步：在 xml 配置文件中添加事务配置信息"></a>第一步：在 xml 配置文件中添加事务配置信息</h4><p>以 DataSourceTransactionManager 为例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--spring声明式事务管理控制--&gt;</span><br><span class="line">  &lt;!--配置事务管理器类--&gt;</span><br><span class="line">  &lt;bean id&#x3D;&quot;transactionManager&quot;</span><br><span class="line">    class&#x3D;&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!--设置注解驱动的事务管理--&gt;</span><br><span class="line">  &lt;tx:annotation-driven transaction-manager&#x3D;&quot;transactionManager&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>####第二步，将@Transactional 注解添加到合适的方法或类上，并设置合适的属性信息。<br>@Transactional 注解的属性信息:</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>value</td>
<td>String</td>
<td>可选的限定描述符，指定使用的事务管理器</td>
</tr>
<tr>
<td>propagation</td>
<td>enum: Propagation</td>
<td>可选的事务传播行为设置</td>
</tr>
<tr>
<td>isolation</td>
<td>enum: Isolation</td>
<td>可选的事务隔离级别设置</td>
</tr>
<tr>
<td>readOnly</td>
<td>boolean</td>
<td>读写或只读事务，默认读写</td>
</tr>
<tr>
<td>timeout</td>
<td>int (in seconds granularity)</td>
<td>事务超时时间设置</td>
</tr>
<tr>
<td>rollbackFor</td>
<td>Class对象数组，必须继承自Throwable</td>
<td>导致事务回滚的异常类数组</td>
</tr>
<tr>
<td>rollbackForClassName</td>
<td>类名数组，必须继承自Throwable</td>
<td>导致事务回滚的异常类名字数组</td>
</tr>
<tr>
<td>noRollbackFor</td>
<td>Class对象数组，必须继承自Throwable</td>
<td>不会导致事务回滚的异常类数组</td>
</tr>
<tr>
<td>noRollbackForClassName</td>
<td>类名数组，必须继承自Throwable</td>
<td>不会导致事务回滚的异常类名字数组</td>
</tr>
</tbody></table>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><h4 id="Transactional作用的位置"><a href="#Transactional作用的位置" class="headerlink" title="@Transactional作用的位置"></a>@Transactional作用的位置</h4><p>@Transactional 可以作用于接口、接口方法、类以及类方法上。当作用于类上时，该类的所有 public 方法将都具有该类型的事务属性，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。<br>虽然 @Transactional 注解可以作用于接口、接口方法、类以及类方法上，但是 Spring 建议不要在接口或者接口方法上使用该注解，因为这只有在使用基于接口的代理时它才会生效。  </p>
<h4 id="Transactional-只能应用到-public-方法才有效"><a href="#Transactional-只能应用到-public-方法才有效" class="headerlink" title="@Transactional 只能应用到 public 方法才有效"></a>@Transactional 只能应用到 public 方法才有效</h4><p> @Transactional 注解应该只被应用到 public 方法上，这是由 Spring AOP 的本质决定的。如果你在 protected、private 或者默认可见性的方法上使用 @Transactional 注解，这将被忽略，也不会抛出任何异常。  </p>
<h4 id="正确的设置-Transactional-的-propagation-属性"><a href="#正确的设置-Transactional-的-propagation-属性" class="headerlink" title="正确的设置@Transactional 的 propagation 属性"></a>正确的设置@Transactional 的 propagation 属性</h4><ol>
<li><strong>Propagation.REQUIRED:</strong> propagation的默认值，支持当前事务，如果不存在，则创建一个新事务。</li>
<li><strong>Propagation.SUPPORTS:</strong> 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。 </li>
<li><strong>Propagation.MANDATORY:</strong> 支持当前事务，如果不存在则抛出异常。</li>
<li><strong>Propagation.REQUIRES_NEW:</strong> 创建一个新事务，如果存在当前事务，则挂起它。</li>
<li><strong>Propagation.NOT_SUPPORTED:</strong> 以非事务方式执行，如果当前事务存在，则挂起当前事务。</li>
<li><strong>Propagation.NEVER:</strong> 以非事务方式执行，如果存在事务，则抛出异常。</li>
<li><strong>Propagation.NESTED:</strong> 如果当前事务存在，则在嵌套事务中执行</li>
</ol>
<h4 id="正确的设置-Transactional-的-rollbackFor-属性"><a href="#正确的设置-Transactional-的-rollbackFor-属性" class="headerlink" title="正确的设置@Transactional 的 rollbackFor 属性"></a>正确的设置@Transactional 的 rollbackFor 属性</h4><p>默认情况下，如果在事务中抛出了未检查异常（继承自 RuntimeException 的异常）或者 Error，则 Spring 将回滚事务；除此之外，Spring 不会回滚事务。<br>而可以指定rollbackFor属性来设置回滚的异常等级，若在目标方法中抛出的异常是 rollbackFor 指定的异常的子类，事务同样会回滚。  </p>
<h4 id="内部调用-Transactional不起作用"><a href="#内部调用-Transactional不起作用" class="headerlink" title="内部调用@Transactional不起作用"></a>内部调用@Transactional不起作用</h4><p>默认情况下，只有来自外部的方法调用才会被AOP代理捕获，也就是，类内部方法调用本类内部的其他方法并不会引起事务行为，即使被调用方法使用@Transactional注解进行修饰。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring中的FactoryBean</title>
    <url>/2019/12/27/Spring%E4%B8%AD%E7%9A%84FactoryBean/</url>
    <content><![CDATA[<p>Spring 中有两种类型的Bean，一种是普通Bean，另一种是工厂Bean 即 FactoryBean。<br>FactoryBean跟普通Bean不同，其返回的对象不是指定类的一个实例，而是该<code>FactoryBean</code>的<code>getObject</code>方法所返回的对象</p>
<h3 id="FactoryBean接口定义"><a href="#FactoryBean接口定义" class="headerlink" title="FactoryBean接口定义"></a>FactoryBean接口定义</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.beans.factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FactoryBean</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//返回的对象实例</span></span><br><span class="line">    <span class="function">T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Bean的类型</span></span><br><span class="line">    Class&lt;?&gt; getObjectType();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//true是单例，false是非单例  在Spring5.0中此方法利用了JDK1.8的新特性变成了default方法，返回true</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>FactoryBean 通常是用来创建比较复杂的bean，一般的bean 直接用xml配置即可，但如果一个bean的创建过程中涉及到很多其他的bean 和复杂的逻辑，用xml配置比较困难，这时可以考虑用FactoryBean。</p>
<blockquote>
<p>当使用ApplicationContext的getBean()方法获取FactoryBean实例本身而不是它所产生的bean，则要使用&amp;符号+id。比如，现有FactoryBean，它有id，在容器上调用getBean(“myBean”)将返回FactoryBean所产生的bean，调用getBean(“&amp;myBean”)将返回FactoryBean它本身的实例。</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring容器</title>
    <url>/2017/09/14/Spring%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<p>　　Spring容器是Spring框架当中的一个核心模块，用来管理对象。在基于Spring的应用中，你的对象生存在Spring的容器中，Spring容器负责创建对象，装配对象和配置他们，并且管理对象的整个生命周期。  </p>
<h3 id="Spring容器类型"><a href="#Spring容器类型" class="headerlink" title="Spring容器类型"></a>Spring容器类型</h3><p>　　Spring容器并不是只有一个，而是有多个，大体上可以归为两种类型。<br>　　1. bean工厂:由org.springframework.beans.factoryeanFactory接口定义，是最简单的容器，提供基本的DI(依赖注入)<br>　　2. 应用上下文:由org.springframework.context.ApplicationContext接口定义，提供应用框架级别的服务，所以比bean工厂更受欢迎  </p>
<h4 id="应用上下文"><a href="#应用上下文" class="headerlink" title="应用上下文"></a>应用上下文</h4><p>　　Spring自带了多种类型的应用上下文，常用的可能有这么几个:  </p>
<blockquote>
<ul>
<li>AnnotationConfigApplicationContext:从一个或多个基于Java的配置类中加载Spring应用上下文  </li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>AnnotationConfigWebApplicationContext:从一个或多个基于Java的配置类中加载Spring Web应用上下文  </li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>ClassPathXmlApplicationContext:从类路径下的一个或多个XML配置文件中加载上下文定义，把应用上下文的定义文件作为类资源</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>FileSystemXmlapplicationContext:从文件系统下的一个或多个XML配置文件中加载上下文定义  </li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>XmlWebApplicationContext:从Web应用下的一个或多个XML配置文件中加载上下文定义  </li>
</ul>
</blockquote>
<h3 id="启动Spring容器"><a href="#启动Spring容器" class="headerlink" title="启动Spring容器"></a>启动Spring容器</h3><p>　　启动容器常用的几种方式：  </p>
<h4 id="手动启动Spring容器"><a href="#手动启动Spring容器" class="headerlink" title="手动启动Spring容器:"></a>手动启动Spring容器:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ApplicationContext ac &#x3D; new ClassPathXmlApplicationContext(config);</span><br><span class="line">   &#x2F;&#x2F;ApplicationContext是接口</span><br><span class="line">   &#x2F;&#x2F;ClassPathXmlApplicationContext是一个具体类，实现了上述接口</span><br><span class="line">   &#x2F;&#x2F;config是配置文件的位置及文件名</span><br></pre></td></tr></table></figure>
<h4 id="在Web项目中"><a href="#在Web项目中" class="headerlink" title="在Web项目中:"></a>在Web项目中:</h4><ul>
<li>用监听器的方式来启动Spring容器:<br>在web.xml中<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;context-param&gt;</span><br><span class="line">    &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;</span><br><span class="line">    &lt;param-value&gt;&#x2F;WEB-INF&#x2F;classes&#x2F;applicationContext-*.xml&lt;&#x2F;param-value&gt;</span><br><span class="line">&lt;&#x2F;context-param&gt;</span><br><span class="line">&lt;listener&gt; </span><br><span class="line">    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener</span><br><span class="line"> &lt;&#x2F;listener-class&gt;</span><br><span class="line">&lt;&#x2F;listener&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;context-param&gt;</span><br><span class="line">    &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;</span><br><span class="line">    &lt;param-value&gt;classpath:applicationContext.xml&lt;&#x2F;param-value&gt;</span><br><span class="line">&lt;&#x2F;context-param&gt;</span><br><span class="line">  &lt;listener&gt;</span><br><span class="line">    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener</span><br><span class="line">&lt;&#x2F;listener-class&gt;</span><br><span class="line">  &lt;&#x2F;listener&gt;</span><br></pre></td></tr></table></figure></li>
<li><del>用servlet方式来启动Spring容器：</del><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;servlet&gt; </span><br><span class="line">    &lt;servlet-name&gt;context&lt;&#x2F;servlet-name&gt; </span><br><span class="line">    &lt;servlet-class&gt;org.springframework.web.context.ContextLoaderServlet&lt;&#x2F;servlet-class&gt;</span><br><span class="line">    &lt;load-on-startup&gt;1&lt;&#x2F;load-on-startup&gt;</span><br><span class="line">&lt;&#x2F;servlet&gt; </span><br></pre></td></tr></table></figure>
这种方式，spring3.0以后不再支持，建议使用监听器方式<h4 id="单元测试时启动Spring容器"><a href="#单元测试时启动Spring容器" class="headerlink" title="单元测试时启动Spring容器:"></a>单元测试时启动Spring容器:</h4>在用Junit进行单元测试时可以用@ContextConfiguration注解来启动Spring容器<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ContextConfiguration(locations &#x3D; &quot;classpath:applicationContext.xml&quot;)</span><br><span class="line">@ContextConfiguration(locations &#x3D;&#123;&quot;&#x2F;applicationContext.xml&quot;&#125;)</span><br></pre></td></tr></table></figure>
除了junit4和spring的jar包，还需要spring-test.jar</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>ThreadPoolExecutor</title>
    <url>/2020/04/02/ThreadPoolExecutor/</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>ThreadPoolExecutor是Java中线程池的核心实现类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">classDiagram</span><br><span class="line">Executor &lt;|-- ExecutorService : 继承</span><br><span class="line">ExecutorService &lt;|-- AbstractExecutorService : 实现</span><br><span class="line">AbstractExecutorService &lt;|-- ThreadPoolExecutor : 继承</span><br></pre></td></tr></table></figure>

<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new &#123;<span class="doctag">@code</span> ThreadPoolExecutor&#125; with the given initial</span></span><br><span class="line"><span class="comment"> * parameters and default thread factory.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> corePoolSize      核心线程池大小</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> maximumPoolSize   最大线程池大小</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> keepAliveTime     线程池中超过corePoolSize数目的空闲线程最大存活时间；可以allowCoreThreadTimeOut(true)成为核心线程的有效时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unit              keepAliveTime的时间单位</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> workQueue         阻塞任务队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> threadFactory     线程工厂，对线程命名 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> handler           拒绝策略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h3><p>所有任务的调度都是由execute方法完成的，这部分完成的工作是：检查现在线程池的运行状态、运行线程数、运行策略，决定接下来执行的流程，是直接申请线程执行，或是缓冲到队列中执行，亦或是直接拒绝该任务。其执行过程如下：</p>
<ol>
<li>首先检测线程池运行状态，如果不是RUNNING，则直接拒绝，线程池要保证在RUNNING的状态下执行任务。</li>
<li>如果workerCount &lt; corePoolSize，则创建并启动一个线程来执行新提交的任务。</li>
<li>如果workerCount &gt;= corePoolSize，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中。</li>
<li>如果workerCount &gt;= corePoolSize &amp;&amp; workerCount &lt; maximumPoolSize，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务。</li>
<li>如果workerCount &gt;= maximumPoolSize，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。</li>
</ol>
<h3 id="任务存储策略"><a href="#任务存储策略" class="headerlink" title="任务存储策略"></a>任务存储策略</h3><p>使用不同的队列可以实现不一样的任务存取策略</p>
<ul>
<li><strong>ArrayBlockingQueue:</strong> 一个用数组实现的有界阻塞队列，此队列按照先进先出(FIFO)的原则对元素进行排序。支持公平锁和非公平锁</li>
<li><strong>LinkedBlockingQueue:</strong> 一个由链表结构组成的有界队列，此队列按照先进先出(FIFO)的原则对元素进行排序。此队列的默认长度是Integer.MAX_VALUE，所以默认创建的队列有容量危险</li>
<li><strong>PriorityBlockingQueue:</strong> 一个支持线程优先级排序的无界队列，默认自然序进行排序，也可以自定义实现compareTo()方法来指定元素排序规则，不能保证同优先级元素的排序</li>
<li><strong>DelayQueue:</strong> 一个实现<code>PriorityBlockingQueue</code>实现延迟获取的无界队列，在创建元素时，可以指定多久才能从队列中获取当前元素。只有延时期满后才能从队列中获取元素</li>
<li><strong>SynchronousQueue:</strong> 一个不存储元素的阻塞队列，每一个put操作必须等待take操作，否则不能添加元素。支持公平锁和非公平锁。<code>SynchronousQueue</code>的一个使用场景是在线程里。<code>Executors.newCachedThreadPool()</code>就使用了<code>SynchronousQueue</code>，这个线程池根据需要(新任务到来时)创建新的线程，如果有空闲线程则会重复使用，线程空闲60秒后会被回收</li>
<li><strong>LinkedTransferQueue:</strong> 一个由链表结构组成的无界阻塞队列，相当于其他队列，<code>LinkedTransferQueue</code>队列多了<code>transfer</code>和<code>tryTransfer</code>方法</li>
<li><strong>LinkedBlockingDeque:</strong> 一个由链表结构组成的双向阻塞队列，队列的头和尾部都可以添加和移除元素，多线程并发时，可以将锁的竞争最多降低一半</li>
</ul>
<h3 id="RejectedExecutionHandler拒绝策略"><a href="#RejectedExecutionHandler拒绝策略" class="headerlink" title="RejectedExecutionHandler拒绝策略"></a>RejectedExecutionHandler拒绝策略</h3><ul>
<li><p><strong>AbortPolicy:</strong> 默认策略，直接抛出异常阻止系统正常运行</p>
</li>
<li><p><strong>CallerRunsPolicy:</strong> “调用者运行”一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将任务回馈至发起方比如main线程</p>
</li>
<li><p><strong>DiscardOldestPolicy:</strong> 抛弃队列中等待最久的任务，然后把当前任务加入队列中尝试再次提交当前任务</p>
</li>
<li><p><strong>DiscardPolicy:</strong> 直接丢弃任务，不给予任何处理也不跑出异常，如果允许任务丢失，这是最好的一种方案</p>
</li>
</ul>
<h3 id="execute-和submit-区别"><a href="#execute-和submit-区别" class="headerlink" title="execute()和submit()区别"></a>execute()和submit()区别</h3><ol>
<li>接收的参数不一样</li>
<li>submit有返回值，而execute没有</li>
<li>submit方便Exception处理：可以通过捕获Future.get抛出的异常</li>
</ol>
<h3 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ThreadFactory factory &#x3D; new ThreadFactoryBuilder().setDaemon(true).setNameFormat(&quot;test-666-%d&quot;).build();</span><br><span class="line">ExecutorService threadPoolExecutor &#x3D; new ThreadPoolExecutor(5, 5, 0L, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(), factory);</span><br><span class="line">threadPoolExecutor.execute(()-&gt;&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br><span class="line">&lt;!--threadPoolExecutor.submit(()-&gt;&#123;--&gt;</span><br><span class="line">&lt;!--    ...--&gt;</span><br><span class="line">&lt;!--&#125;);--&gt;</span><br><span class="line">threadPoolExecutor.shutdown();</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Web fragments</title>
    <url>/2021/02/19/Web%20fragments/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p><code>Web fragments</code>是<code>servlet 3.0</code>开始支持的一个特性(可插性支持)，通过插件的方式很方便的扩充已有<code>Web</code>应用的功能，而不需要修改原有的应用</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><blockquote>
<p>Servlet 3.0 的部署描述文件 web.xml 的顶层标签 有一个 metadata-complete 属性，该属性指定当前的部署描述文件是否是完全的。如果设置为 true，则容器在部署时将只依赖部署描述文件，忽略所有的注解（同时也会跳过 web-fragment.xml 的扫描，亦即禁用可插性支持，具体请看后文关于 <a href="https://www.ibm.com/developerworks/cn/java/j-lo-servlet30/#major4">可插性支持</a> 的讲解）；如果不配置该属性，或者将其设置为 false，则表示启用注解支持（和可插性支持）。</p>
</blockquote>
<h3 id="Web-fragments语法和规则"><a href="#Web-fragments语法和规则" class="headerlink" title="Web fragments语法和规则"></a>Web fragments语法和规则</h3><ol>
<li><code>Web fragments</code> 需要有 <code>web-fragment.xml</code> 的部署描述文件，该文件必须存放在 <code>JAR</code> 文件的 <code>META-INF</code> 目录下，该部署描述文件可以包含一切可以在 <code>web.xml</code> 中定义的内容(过滤器、监听器与<code>Servlet</code>)</li>
<li>包含 <code>web-fragment.xml</code> 的 <code>JAR</code> 应该部署到 <code>Web</code> 应用程序的 <code>WEBINF/lib</code> 目录中</li>
<li><code>web-fragment.xml</code> 的根元素是 <code>&lt;web-fragment&gt;</code>，它可以包含 <code>DD(web.xml)</code> 中 <code>&lt;web-app&gt;</code> 元素的任何子元素。</li>
<li>每个 <code>web-fragment.xml</code> 都可以包含一个 <code>name</code> 元素。<code>name</code> 元素在所有 <code>Web</code> 片段中应该是唯一的，并且不应有任何循环引用或循环，否则容器将因有意义的错误中止应用程序部署。该名称将用于 <code>Web</code> 片段的任何排序。</li>
<li>可以使用元素 <code>&lt;absolute-ordering&gt;</code> 从 <code>web.xml</code> 中指定 <code>Web</code> 片段的顺序。也可以使用元素 <code>&lt;ordering&gt;</code> 从 <code>Web</code> 片段本身内部指定 <code>Web</code> 片段的顺序。在 <code>web.xml</code> 或 <code>Web</code> 片段中，元素按照声明的顺序加载。</li>
<li>并且如果 <code>web-fragment.xml</code> 和 <code>web.xml</code> 之间存在冲突，则 <code>web.xml</code> 将具有优先权。但是，如果两个片段之间存在冲突，则会引发错误。</li>
</ol>
<h3 id="配置内容"><a href="#配置内容" class="headerlink" title="配置内容"></a>配置内容</h3><blockquote>
<p>servlet、filter、listener三个可以定义任何一个，也可以全部定义</p>
</blockquote>
<ul>
<li><p>web-fragment.xml:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-fragment</span> <span class="attr">id</span>=<span class="string">&quot;WebFragment_ID&quot;</span> <span class="attr">version</span>=<span class="string">&quot;3.1&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-fragment_3_1.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Test<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- servlet --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>servletTest<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.xxx.xxx.servlets.ServletTest<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>servletTest<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- filter --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filterTest<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.xxx.xxx.FilterTest<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">async-supported</span>&gt;</span>true<span class="tag">&lt;/<span class="name">async-supported</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filterTest<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- listener --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>com.xxx.xxx.ListenerTest<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ordering</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 表示在项目所有之前进行初始化 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">before</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">others</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">before</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 表示在项目所有之后进行初始化 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">after</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">others</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">after</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ordering</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">web-fragment</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>Servlet:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletTest</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.service(req, resp);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.destroy();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Filter:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.Filter;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.FilterChain;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.FilterConfig;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterTest</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Listener:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.ServletRequestEvent;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletRequestListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListenerTest</span> <span class="keyword">implements</span> <span class="title">ServletRequestListener</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestDestroyed</span><span class="params">(ServletRequestEvent servletRequestEvent)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestInitialized</span><span class="params">(ServletRequestEvent servletRequestEvent)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>lombok—@Accessors注解</title>
    <url>/2018/02/06/lombok%E2%80%94-Accessors%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<p>@Accessors 注解用来配置lombok如何产生和显示getters和setters的方法。<br>@Accessors有三个属性，分别是fluent,chain,prefix，@Accessors注解既可以注解在类上也可以注解在属性上  </p>
<h4 id="1-fluent"><a href="#1-fluent" class="headerlink" title="1.fluent"></a>1.fluent</h4><p>fluent为一个布尔值，如果为true生成的get/set方法则没有set/get前缀，默认为false<br>例如：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Accessors(flunet &#x3D; true)</span><br><span class="line">public class MyClass &#123;</span><br><span class="line">    @Getter</span><br><span class="line">    private int num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生成的get方法为num()，而不是getNum()</p>
<h4 id="2-chain"><a href="#2-chain" class="headerlink" title="2.chain"></a>2.chain</h4><p>chain为一个布尔值，如果为true生成的set方法返回this，为false生成的set方法是void类型。默认为false，除非当fluent为true时，chain默认则为true</p>
<h4 id="3-prefix"><a href="#3-prefix" class="headerlink" title="3.prefix"></a>3.prefix</h4><p>prefix为一系列string类型，可以指定前缀，生成get/set方法时会去掉指定的前缀<br>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Accessors(prefix &#x3D; &quot;m&quot;)</span><br><span class="line">public class MyClass &#123;</span><br><span class="line">    @Getter</span><br><span class="line">    private int mNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生成的get方法为getNum()，而不是getMNum()</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>lombok</tag>
      </tags>
  </entry>
  <entry>
    <title>maven常用命令</title>
    <url>/2017/11/23/maven%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>1.mvn clean 清理项目生产的临时文件,模块下的target目录  </p>
<p>2.mvn compile 编译源代码  </p>
<p>3.mvn test-compile 编译测试代码  </p>
<p>4.mvn test 运行测试  </p>
<p>5.mvn package 打包，根据pom.xml打成war或jar，会在模块下的target目录生成jar或war等文件</p>
<blockquote>
<p>如果pom.xml中设置 war，则此命令相当于mvn war:war<br>如果pom.xml中设置 jar，则此命令相当于mvn jar:jar</p>
</blockquote>
<p>6.mvn install 在本地Repository中安装jar  </p>
<p>7.mvn -Dtest package 打包但不测试。完整命令为：mvn -D maven.test.skip=true package  </p>
<p>8.mvn eclipse:eclipse 生成eclipse项目  </p>
<p>9.mvn idea:idea 生成idea项目  </p>
<p>10.mvn package -Prelease 打包，并生成部署用的包，比如deploy/*.tgz  </p>
<p>11.mvn site 生成项目相关信息的网站  </p>
<p>12.mvn deploy 在整合或者发布环境下执行，将最终版本的包拷贝到远程的repository，使得其他的开发者或者工程可以共享  </p>
<p>13.mvn dependency:sources 下载源码  </p>
<p>14.mvn validate 验证工程是否正确，所有需要的资源是否可用  </p>
<p>15.mvn verify 运行任何检查，验证包是否有效且达到质量标准  </p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>readonly 和 disable的区别</title>
    <url>/2017/12/21/readonly-%E5%92%8C-disable%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>Readonly只针对input(text / password)和textarea有效，而disabled对于所有的表单元素都有效。  </p>
<p>当表单数据提交时，Readonly作用的元素的数据可以和form表单一起提交数据，而disabled作用的表单元素则不可提交数据。  </p>
<p>当一个输入项的disabled为true时，该表单数据项不能获得焦点，用户的所有操作都无效，提交表单时不会提交。<br><img src="/content/images/2017/12/QQ20171221-153145.png"></p>
<p>readonly只是针对文本输入框这类可以输入文本的输入项，当readonly设置为true时，用户只是不能编辑，但还有焦点，在提交表单的时候会随表单一起提交。<br><img src="/content/images/2017/12/QQ20171221-153745.png"></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>rest easy注解</title>
    <url>/2017/11/02/rest-easy%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<p>@Path，标注资源类或方法的相对路径,@Path不仅仅接收简单的路径表达式,也可以使用正则表达式</p>
<p>@GET，@PUT，@POST，@DELETE，标注方法是用的HTTP请求的类型</p>
<p>@Produces，当服务器端实行完成相关的逻辑需要返回对象的时候，程序会根据@Produces返回相应的对象类型</p>
<p>@Consumes，我们从页面提交数据到后台的时候,数据的类型可以是text的,xml的,json的,但是我们在请求资源的时候想要请求到同一个资源路径上面去，此时怎么来区分处理呢?使用@Consumes标注</p>
<p>@PathParam，@QueryParam，@HeaderParam，@CookieParam，@MatrixParam，@FormParam,分别标注方法的参数来自于HTTP请求的不同位置，例如@PathParam来自于URL的路径，@QueryParam来自于URL的查询参数，@HeaderParam来自于HTTP请求的头信息，@CookieParam来自于HTTP请求的Cookie，@FormParam来自Form表单中的参数</p>
<p>@DefaultValue，有些参数值在没有值的情况下如果需要有默认值,则使用这个标注</p>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Resteasy</tag>
      </tags>
  </entry>
  <entry>
    <title>ssh-ControlMaster</title>
    <url>/2020/11/18/ssh-ControlMaster/</url>
    <content><![CDATA[<blockquote>
<p><code>ssh</code> 的配置文件<code>~/.ssh/config</code>可以大大的简化 <code>ssh</code> 的一些操作，如果没有这个文件则自己在 <code>~/.ssh/</code> 下<code>touch</code>一个即可</p>
</blockquote>
<blockquote>
<p>该文主要介绍使用 <code>ControlMaster</code> 来复用连接，每次<code>ssh</code>一台服务器时不需要每次输入密码</p>
</blockquote>
<h3 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h3><h4 id="ControlMaster"><a href="#ControlMaster" class="headerlink" title="ControlMaster"></a>ControlMaster</h4><blockquote>
<p>SSH支持 <code>ControlMaster</code> 模式，单一网络共享多个seesion，复用之前建立的连接，</p>
</blockquote>
<p>值可以为 <code>no(default)/yes/ask/auto</code>需要和 <code>ControlPath</code> 配合使用，当值为 yes 时，ssh 会监听该路径下的 <code>control socket</code>，多个 session 会去连接该 socket，则会尽可能的复用连接</p>
<h4 id="ControlPath"><a href="#ControlPath" class="headerlink" title="ControlPath"></a>ControlPath</h4><blockquote>
<p>指定 control socket 的路径</p>
</blockquote>
<p>值可以使用下面这些参数：</p>
<ul>
<li>%L 本地主机名的第一个组件</li>
<li>%l 本地主机名（包括域名）</li>
<li>%h 远程主机名（命令行输入）</li>
<li>%n 远程原始主机名</li>
<li>%p 远程主机端口</li>
<li>%r 远程登录用户名</li>
<li>%u 本地 ssh 正在使用的用户名</li>
<li>%i 本地 ssh 正在使用 uid</li>
<li>%C 值为 %l%h%p%r 的 hash</li>
</ul>
<h4 id="ControlPersist"><a href="#ControlPersist" class="headerlink" title="ControlPersist"></a>ControlPersist</h4><blockquote>
<p>结合 <code>ControlMaster</code> 使用，指定连接打开后后台保持的时间。值可以为 no/yes/整数，单位 s。如果为 no，最初的客户端关闭就关闭。如果 yes/0，无限期的，直到杀死或通过其它机制，如：<code>ssh -O exit</code></p>
</blockquote>
<h3 id="实际配置"><a href="#实际配置" class="headerlink" title="实际配置"></a>实际配置</h3><h4 id="ssh-config文件"><a href="#ssh-config文件" class="headerlink" title="~/.ssh/config文件"></a>~/.ssh/config文件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">host *</span><br><span class="line">ControlPersist yes</span><br><span class="line">ControlMaster auto</span><br><span class="line">ControlPath ~&#x2F;.ssh&#x2F;master-%r@%h:%p</span><br></pre></td></tr></table></figure>
<ul>
<li><code>host</code> 标识匹配的主机名，<code>*</code>代表所有，也可匹配的主机</li>
<li><code>ControlPersist</code> 保持连接，客户端关闭并不会真的关闭连接</li>
<li><code>ControlMaster</code> 开启连接复用</li>
<li><code>ControlPath</code> 指定<code>control socket</code>的路径，当开启<code>ssh</code>连接后，会在<code>~/.ssh/</code>下产生一个master开头的文件，当有这这个文件时，再次<code>ssh</code>连接同一个服务器时判断有该文件则不需要输入密码</li>
</ul>
<h4 id="修改expect脚本"><a href="#修改expect脚本" class="headerlink" title="修改expect脚本"></a>修改expect脚本</h4><p>经常会使用<code>expect</code>脚本来连接服务器，开启<code>ControlMaster</code>模式后可能会使之前的<code>expect</code>脚本有问题，所以需要修改<code>expect</code>脚本</p>
<ul>
<li><p>before</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/expect</span></span><br><span class="line">set host [lindex $argv 0]</span><br><span class="line">set username &quot;&quot;</span><br><span class="line"></span><br><span class="line">spawn ssh $username@$host</span><br><span class="line">expect &#123;</span><br><span class="line">		&quot;*yes/no)? &quot; &#123;send &quot;yes\n&quot;; exp_continue&#125;</span><br><span class="line">		&quot;password:&quot; &#123;send &quot;password&quot;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">interact</span><br></pre></td></tr></table></figure></li>
<li><p>after</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/expect</span></span><br><span class="line">set host [lindex $argv 0]</span><br><span class="line">set username &quot;&quot;</span><br><span class="line"></span><br><span class="line">set controlMaster [file exists ~/.ssh/master-$username@$host:22]</span><br><span class="line"></span><br><span class="line">if &#123; $controlMaster&#125; &#123;</span><br><span class="line">	spawn ssh $username@$host</span><br><span class="line">&#125; else &#123;</span><br><span class="line">	spawn ssh $username@$host</span><br><span class="line">	expect &#123;</span><br><span class="line">	    &quot;*yes/no)? &quot; &#123;send &quot;yes\n&quot;; exp_continue&#125;</span><br><span class="line">		&quot;password:&quot; &#123;send &quot;password&quot;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">interact</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>事物隔离级别</title>
    <url>/2020/02/01/%E4%BA%8B%E7%89%A9%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</url>
    <content><![CDATA[<h3 id="事物"><a href="#事物" class="headerlink" title="事物"></a>事物</h3><p>事务是由一组SQL语句组成的逻辑处理单元，是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。事务具有以下4个属性，通常简称为事务的ACID属性:</p>
<ul>
<li><p><strong>原子性(Atomicity):</strong> 事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。</p>
</li>
<li><p><strong>一致性(Consistent):</strong> 在事务开始和完成时，数据都必须保持一致状态。</p>
</li>
<li><p><strong>隔离性(Isolation):</strong> 并发访问数据库时，一个用户的事物不被其他事物所干扰，各并发事务之间数据库是独立的。</p>
</li>
<li><p><strong>持久性(Durable):</strong> 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</p>
</li>
</ul>
<h3 id="并发一致性问题"><a href="#并发一致性问题" class="headerlink" title="并发一致性问题"></a>并发一致性问题</h3><ul>
<li><p><strong>脏读(Dirty read):</strong> 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。<br>解决办法: 把数据库的事务隔离级别调整到<code>READ_COMMITTED</code></p>
</li>
<li><p><strong>更新丢失(Lost Update):</strong> 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 </p>
</li>
<li><p><strong>不可重复读(Unrepeatableread):</strong> 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。  </p>
</li>
</ul>
<p><strong>一个事务范围内两个相同的查询却返回了不同数据。</strong><br>解决办法: 把数据库的事务隔离级别调整到<code>REPEATABLE_READ</code></p>
<ul>
<li><p><strong>幻读(Phantom read):</strong> 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</p>
</li>
<li><p><strong>不可重复度和幻读区别:</strong><br>不可重复读的重点是修改，幻读的重点在于新增或者删除。</p>
</li>
</ul>
<h3 id="事物的隔离级别"><a href="#事物的隔离级别" class="headerlink" title="事物的隔离级别"></a>事物的隔离级别</h3><p>“脏读”、”不可重复读”和”幻读”，必须由事务隔离机制来解决。</p>
<h4 id="SQL-标准定义了四个隔离级别"><a href="#SQL-标准定义了四个隔离级别" class="headerlink" title="SQL 标准定义了四个隔离级别:"></a>SQL 标准定义了四个隔离级别:</h4><ul>
<li><p><strong>读未提交(Read Uncommitted):</strong><br>最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读</p>
</li>
<li><p><strong>读已提交(Read Committed):</strong><br>允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong><br>Oracle、SqlServer默认隔离级别都是<code>READ-COMMITTED</code></p>
</li>
<li><p><strong>可重复读(Repeatable Read):</strong><br>对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong><br>MYSQL默认隔离级别是<code>REPEATABLE-READ</code></p>
</li>
<li><p><strong>串行化(Serializable):</strong><br>最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong></p>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><p>读未提交: 一个事务还没提交时，它做的变更就能被别的事务看到。</p>
</li>
<li><p>读已提交: 一个事务提交之后，它做的变更才会被其他事务看到。</p>
</li>
<li><p>可重复读 : 一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。</p>
</li>
<li><p>串行化: 顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</p>
</li>
</ul>
<p>四个级别逐渐增强，每个级别解决一个问题，事务级别越高，性能越差，大多数环境(<code>Read committed</code> 就可以了)</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>读数据一致性</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>读未提交</td>
<td>最低级别</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>读已提交</td>
<td>语句级</td>
<td>N</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>可重复读</td>
<td>事物级</td>
<td>N</td>
<td>N</td>
<td>Y</td>
</tr>
<tr>
<td>串行化</td>
<td>最高级别、事物级</td>
<td>N</td>
<td>N</td>
<td>N</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>DB</category>
      </categories>
      <tags>
        <tag>DB</tag>
      </tags>
  </entry>
  <entry>
    <title>创建文档站点</title>
    <url>/2020/10/23/%E5%88%9B%E5%BB%BA%E6%96%87%E6%A1%A3%E7%AB%99%E7%82%B9/</url>
    <content><![CDATA[<blockquote>
<p>经常看到一些文档的网站很简洁，于是便调研了一下，自己动手基于<code>GitHub Pages</code>搭建了一个文档站点</p>
</blockquote>
<h3 id="文档站点生成器"><a href="#文档站点生成器" class="headerlink" title="文档站点生成器"></a>文档站点生成器</h3><blockquote>
<p>调研了5种文档站点生成器</p>
</blockquote>
<ol>
<li><p><a href="https://docsify.js.org/#/zh-cn/">docsify</a><br>不同于 <code>GitBook</code>、<code>vuePress</code>、<code>Hexo</code> 的地方是它不会生成静态的 .html 文件，所有转换工作都是在运行时。无需构建，写完文档直接发布</p>
</li>
<li><p><a href="https://docute.org/zh/">docute</a><br><code>docute</code> 和 <code>docsify</code> 几乎相同，都是运行时驱动，但具有不同的 UI 和不同的使用方式，Docute（60kB）比 Docisfy（20kB）大 3 倍，因为<code>docute</code>使用了 Vue，Vue Router 和 Vuex，而 <code>Docsify</code> 使用的是 vanilla JavaScript。</p>
</li>
<li><p><a href="https://vuepress.vuejs.org/zh/">vuePress</a><br>使用vue开发，每一个由 <code>VuePress</code> 生成的页面都带有预渲染好的 HTML，也因此具有非常好的加载性能和搜索引擎优化（SEO）</p>
</li>
<li><p><a href="https://rust-lang.github.io/mdBook/">mdBook</a><br><code>mdBook</code> 是一个命令行工具和<code>Rust crate</code>。可将Markdown文件创建为书籍。它与<code>Gitbook</code>非常相似,但用<code>Rust</code>编写</p>
</li>
<li><p><a href="https://www.gitbook.com/">gitBook</a><br><code>GitBook</code> 是一个基于 Node.js 的命令行工具，可使用 Github/Git 和 Markdown 来制作精美的电子书，支持输出多种格式文档：静态站点、PDF、eBook、单HTML网页、JSON</p>
</li>
</ol>
<h3 id="使用docsify搭建站点"><a href="#使用docsify搭建站点" class="headerlink" title="使用docsify搭建站点"></a>使用docsify搭建站点</h3><blockquote>
<p><a href="http://leetcode.tianwj.com/">leetcode.tianwj.com</a><br>把之前刷的leetcode记录生成了一个站点，并且绑定二级域名</p>
</blockquote>
<p><a href="https://docsify.js.org/#/zh-cn/">docsify</a> 官方文档写的非常详细，并且还支持中文，官方文档就是使用 <code>docsify</code> 生成的，具体可以查看官方文档</p>
<p>设置<code>GitHub Pages</code>:<br><img src="/images/gitHub-pages.png"></p>
<p>最终成品:<br><img src="/images/leetcode1.png"><br><img src="/images/leetcode2.png"></p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>Code Review</title>
    <url>/2021/06/19/Code%20Review/</url>
    <content><![CDATA[<h2 id="认识-Code-Review"><a href="#认识-Code-Review" class="headerlink" title="认识 Code Review"></a>认识 Code Review</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>Code Review是一种用来确认方案设计和代码实现的质量保证机制，通过这个机制对代码、测试过程和注释进行检查，确保整体代码运行状况随着时间的推移而得到改善。</p>
<h3 id="目的和意义"><a href="#目的和意义" class="headerlink" title="目的和意义"></a>目的和意义</h3><ul>
<li>目的：代码质量、知识共享、团队规范</li>
<li>意义：<ul>
<li>查找系统和代码的缺陷，把控风险</li>
<li>保证代码整体健康度不会随时间的推移而降低</li>
<li>提高开发者自身水平</li>
</ul>
</li>
</ul>
<h3 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h3><p>常见的 Code Review 有下面几种方式</p>
<blockquote>
<p>结对编程(瞬时评审)</p>
</blockquote>
<ul>
<li>一对一的共同编程</li>
<li>场景：复杂的业务问题、或紧急问题的修复</li>
</ul>
<blockquote>
<p>即时代码评审(同步评审)</p>
</blockquote>
<ul>
<li>提交人给审核人讲解任务详情、改动等</li>
<li>场景：不清楚任务目标、或高级指导低级</li>
</ul>
<blockquote>
<p>工具支持的代码评审(异步评审)</p>
</blockquote>
<ul>
<li>和开发流集成，只有 Review 通过才能合并</li>
<li>默认的方式，也是最常用的</li>
</ul>
<blockquote>
<p>基于会议的代码评审(偶尔评审)</p>
</blockquote>
<ul>
<li>组织会议，团队多人共同评审</li>
<li>场景：大型、比较复杂的项目；有一定风险的项目；为了提高整体水平</li>
</ul>
<h3 id="不做-Code-Review-的典型场景"><a href="#不做-Code-Review-的典型场景" class="headerlink" title="不做 Code Review 的典型场景"></a>不做 Code Review 的典型场景</h3><ul>
<li>不认同，团队整体意识不到位</li>
<li>需求多，时间紧，疲于应付需求</li>
<li>技术水平不足，无法给出有效意见</li>
</ul>
<h3 id="Code-Review-常见问题"><a href="#Code-Review-常见问题" class="headerlink" title="Code Review 常见问题"></a>Code Review 常见问题</h3><blockquote>
<p>提交人</p>
</blockquote>
<ul>
<li>提交大量代码评审</li>
<li>发起评审前没有进行自测</li>
<li>不进行评审，直接上线</li>
<li>没有给评审人留够充裕的时间</li>
</ul>
<blockquote>
<p>评审人</p>
</blockquote>
<ul>
<li>Review 不仔细，产生低级的问题</li>
<li>对业务不熟悉，无法判断影响面</li>
<li>反馈时机长，不及时处理提交人提交的 Code Review</li>
</ul>
<blockquote>
<p>全体</p>
</blockquote>
<ul>
<li>没有规范的 Code Review 机制和自测机制</li>
</ul>
<h2 id="如何做好-Code-Review"><a href="#如何做好-Code-Review" class="headerlink" title="如何做好 Code Review"></a>如何做好 Code Review</h2><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>要避免 Code Review 流于形式，而避免流于形式的关键点则是 <strong>大家都有主观意愿，并且客观条件允许</strong></p>
<p>要有代码规范、Check list、总结优化、激励机制</p>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+-------+      +---------+      +---------+      +---------+      +-----+      +------------+</span><br><span class="line">| 定标准 | +--&gt; | 全员学习 | +--&gt; | 需求梳理  | +--&gt; | 代码评审 | +--&gt; | 讨论 | +--&gt; | 评审结果落地 |</span><br><span class="line">+-------+      +---------+      +---------+      +---------+      +-----+      +------------+ </span><br></pre></td></tr></table></figure>

<ol>
<li>定标准<ul>
<li>目的：有法可依、团队一致</li>
<li>内容：<ul>
<li>共识标准：权利责任标准、冲突处理标准、特例紧急case处理标准、检查单标准</li>
<li>提交人标准：发起时机标准、选择评审人标准、Commit 标准、代码标准、合并分支标准、处理评论标准</li>
<li>评审人标准：检查内容标准、可通过标准、评论标准、反馈周期标准</li>
</ul>
</li>
</ul>
</li>
<li>全员学习<ul>
<li>目的：统一思想、确认标准可落地</li>
</ul>
</li>
<li>需求梳理<ul>
<li>统一对需求理解，设计评审有理可依</li>
<li>内容：<ul>
<li>提交人要有基于需求的代码改动设计方案</li>
<li>评审人要有基于需求理解之下的代码改造意见</li>
</ul>
</li>
</ul>
</li>
<li>代码评审<ul>
<li>目的：实现正确的业务需求，代码长期的可维护性</li>
<li>内容：参照检查单（功能拆解；架构设计；代码逻辑；库表设计；编码风格；性能；等等）</li>
<li>工具：<a href="http://www.sonar.org.cn/">Sonar</a>、<a href="https://www.gerritcodereview.com/">Gerrit</a> 等工具</li>
</ul>
</li>
<li>讨论<ul>
<li>目的：达成共识，求同存异</li>
</ul>
</li>
<li>评审结果落地<ul>
<li>总结归纳，持续优化标准</li>
</ul>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Code Review 是提高代码质量、把控项目风险的一剂良药，同时也是提高个人水平的一个重要渠道。而长期维持良好的 Code Review 并不容易，但是良好的 Code Review 是个人和团队成功不可或缺的一环。</p>
<h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><p>GoogleCR机制（原文）：<a href="https://google.github.io/eng-practices/review/reviewer/">https://google.github.io/eng-practices/review/reviewer/</a></p>
<p>GoogleCR机制（翻译版）：<a href="https://cloud.tencent.com/developer/article/1514271">https://cloud.tencent.com/developer/article/1514271</a></p>
]]></content>
      <categories>
        <category>规范</category>
      </categories>
      <tags>
        <tag>规范</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty-BetyBuf</title>
    <url>/2021/06/11/Netty-BetyBuf/</url>
    <content><![CDATA[<blockquote>
<p>ByteBuf 是 Netty 中的数据交互单位，本质是一个 Byte 数组的缓冲区，有不同实现机制，首先看 ByteBuf 的数据结构</p>
</blockquote>
<h3 id="ByteBuf结构"><a href="#ByteBuf结构" class="headerlink" title="ByteBuf结构"></a>ByteBuf结构</h3><pre><code>+-------------------+------------------+------------------+
| discardable bytes |  readable bytes  |  writable bytes  |
|                   |     (CONTENT)    |                  |
+-------------------+------------------+------------------+
|                   |                  |                  |
0      &lt;=      readerIndex   &lt;=   writerIndex    &lt;=    capacity
</code></pre>
<p>ByteBuf 包括三部分，丢弃字节、可读字节、可写字节</p>
<p>通过两个指针，读指针（readerIndex）和写指针（writerIndex）来分成三部分，当 readerIndex = writerIndex 时不可读，当 writerIndex = capacity 时不可写。还有个参数 maxCapacity，当写入数据容量不足时会自动扩容，扩容的最大容量为 maxCapacity 值</p>
<h3 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h3><h4 id="容量API"><a href="#容量API" class="headerlink" title="容量API"></a>容量API</h4><ul>
<li><p><code>capacity()</code></p>
<p>表示 ByteBuf 的占用字节内存，包括丢弃字节、可读字节、可写字节，不同的底层实现机制有不同的计算方式</p>
</li>
<li><p><code>maxCapacity()</code>  </p>
<p>表示 ByteBuf 最大能够占用多少字节的内存</p>
</li>
<li><p><code>readableBytes()</code></p>
<p>ByteBuf 当前可读的字节数，它的值等于 writerIndex-readerIndex</p>
</li>
<li><p><code>isReadable()</code></p>
<p>返回是否可读，writerIndex = readerIndex 则不可读，返回 <code>false</code></p>
</li>
<li><p><code>writableBytes()</code></p>
<p>ByteBuf 当前可写的字节数，它的值等于 capacity-writerIndex</p>
</li>
<li><p><code>isWritable()</code></p>
<p>返回是否可写，capacity = writerIndex 则不可写</p>
</li>
<li><p><code>maxWritableBytes()</code></p>
<p>ByteBuf 可写的最大字节数，它的值等于 maxCapacity-writerIndex</p>
</li>
</ul>
<h4 id="指针相关API"><a href="#指针相关API" class="headerlink" title="指针相关API"></a>指针相关API</h4><ul>
<li><p><code>readerIndex()</code></p>
<p>返回当前读指针的 readerIndex</p>
</li>
<li><p><code>readerIndex(int)</code></p>
<p>设置读指针</p>
</li>
<li><p><code>writeIndex()</code></p>
<p>返回当前写指针的 writerIndex</p>
</li>
<li><p><code>writeIndex(int)</code></p>
<p>设置读指针</p>
</li>
<li><p><code>markReaderIndex()</code>、<code>markWriterIndex()</code></p>
<p>把当前的读、写指针保存起来</p>
</li>
<li><p><code>resetReaderIndex()</code>、<code>resetWriterIndex()</code></p>
<p>把当前的读、写指针恢复到之前保存的值</p>
</li>
</ul>
<h4 id="读写API"><a href="#读写API" class="headerlink" title="读写API"></a>读写API</h4><ul>
<li><p><code>writeBytes(byte[] src)</code></p>
<p>把字节数组 src 里面的数据全部写到 ByteBuf，src 字节数组大小的长度通常小于等于 <code>writableBytes()</code></p>
</li>
<li><p><code>readBytes(byte[] dst)</code></p>
<p>把 ByteBuf 里面的数据全部读取到 dst，这里 dst 字节数组的大小通常等于 <code>readableBytes()</code></p>
</li>
<li><p><code>writeByte(byte b)</code></p>
<p>表示往 ByteBuf 中写一个字节，类似还有 <code>writeBoolean()</code>、<code>writeChar()</code>、<code>writeShort()</code>、<code>writeInt()</code>、<code>writeLong()</code>、<code>writeFloat()</code>、<code>writeDouble()</code> </p>
</li>
<li><p><code>readByte()</code></p>
<p>表示从 ByteBuf 中读取一个字节，类似还有  <code>readBoolean()</code>、<code>readChar()</code>、<code>readShort()</code>、<code>readInt()</code>、<code>readLong()</code>、<code>readFloat()</code>、<code>readDouble()</code></p>
</li>
<li><p><code>setBytes()</code>、<code>setByte()</code></p>
<p>和 <code>writeBytes()</code> 等方法类似，但是 set 不会改变读写指针，而 write 会改变写指针</p>
</li>
<li><p><code>getBytes</code>、<code>getByte()</code></p>
<p>和 <code>readBytes()</code> 等方法类似，同样 get 不会改变读写指针，而 read 会改变读指针</p>
</li>
<li><p><code>retain()</code></p>
<p>将 BetyBuf 的引用计数加一</p>
</li>
<li><p><code>release()</code></p>
<p>将 ByteBuf 的引用计数减一，减完之后如果发现引用计数为0，则直接回收 ByteBuf 底层的内存</p>
</li>
</ul>
<blockquote>
<p>由于 Netty 使用了堆外内存，而堆外内存是不被 jvm 直接管理的，也就是说申请到的内存无法被垃圾回收器直接回收，所以需要我们手动回收。有点类似于c语言里面，申请到的内存必须手工释放，否则会造成内存泄漏。</p>
<p>Netty 的 ByteBuf 是通过引用计数的方式管理的，如果一个 ByteBuf 没有地方被引用到，需要回收底层内存。默认情况下，当创建完一个 ByteBuf，它的引用为1</p>
</blockquote>
<ul>
<li><p><code>slice()</code></p>
<p>从原始 ByteBuf 中截取一段，这段数据是从 readerIndex 到 writeIndex，同时，返回的新的 ByteBuf 的最大容量 maxCapacity 为原始 ByteBuf 的 <code>readableBytes()</code>；底层内存以及引用计数与原始的 ByteBuf 共享</p>
</li>
<li><p><code>duplicate()</code></p>
<p>把整个 ByteBuf 都截取出来，包括所有的指针信息。底层内存以及引用计数与原始的 ByteBuf 共享</p>
</li>
<li><p><code>copy()</code></p>
<p>从原始的 ByteBuf 中拷贝所有的信息，包括读写指针以及底层对应的数据，底层内存以及引用计数都独立，操作 ByteBuf 中的数据不会影响到原始的 ByteBuf </p>
</li>
</ul>
<blockquote>
<p>三个方法都会返回新的 ByteBuf 对象</p>
<p><code>slice()</code> 与 <code>duplicate()</code> 的相同点是：<strong>底层内存以及引用计数与原始的 ByteBuf 共享</strong>，也就是说经过 <code>slice()</code> 或者 <code>duplicate()</code> 返回的 ByteBuf 调用 write 系列方法都会影响到原始的 ByteBuf，但是它们都维持着与原始 ByteBuf 相同的内存引用计数和不同的读写指针 </p>
<p><code>slice()</code> 与 <code>duplicate()</code> 的不同点是：<code>slice()</code> 只截取从 readerIndex 到 writerIndex 之间的数据，它返回的 ByteBuf 的最大容量被限制到 原始 ByteBuf 的 <code>readableBytes()</code>, 而 <code>duplicate()</code> 是把整个 ByteBuf 都与原始的 ByteBuf 共享 </p>
<p><code>slice()</code> 和 <code>duplicate()</code> 不会改变 ByteBuf 的引用计数，所以原始的 ByteBuf 调用 <code>release()</code> 之后发现引用计数为零，就开始释放内存，调用这两个方法返回的 ByteBuf 也会被释放，这个时候如果再对它们进行读写，就会报错。因此，我们可以通过调用一次 <code>retain()</code> 方法 来增加引用，表示它们对应的底层的内存多了一次引用，引用计数为2，在释放内存的时候，需要调用两次 <code>release()</code> 方法，将引用计数降到零，才会释放内存</p>
<p><code>slice()</code> 、<code>duplicate()</code>、<code>copy()</code> 三个方法均维护着自己的读写指针，与原始的 ByteBuf 的读写指针无关，相互之间不受影响</p>
</blockquote>
<ul>
<li><p><code>retainedSlice()</code></p>
<p>截取内存片段的同时，增加内存的引用计数，等价于 <code>slice().retain()</code></p>
</li>
<li><p><code>retainedDuplicate()</code></p>
<p>也是截取内存片段的同时，增加内存的引用计数，等价于 <code>duplicate().retain()</code></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>常用Idea插件</title>
    <url>/2018/01/17/%E5%B8%B8%E7%94%A8Idea%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<p><img src="/images/idea-plugins.jpg" alt="idea插件"></p>
]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title>收藏备用：60 余家免费正版图片网站</title>
    <url>/2017/11/16/%E6%94%B6%E8%97%8F%E5%A4%87%E7%94%A8%EF%BC%9A60-%E4%BD%99%E5%AE%B6%E5%85%8D%E8%B4%B9%E6%AD%A3%E7%89%88%E5%9B%BE%E7%89%87%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<blockquote>
<p>==<strong>原文：纷享销客KM</strong>==</p>
</blockquote>
<h3 id="第一找图梯队"><a href="#第一找图梯队" class="headerlink" title="第一找图梯队"></a>第一找图梯队</h3><p>根据二八定律，80% 的结果可能来自于 20% 的原因。这在找图片这件事上也适用。虽然这次推荐的无版权图片网站有数十家，但是真正好用的也是只有一部分，而这一部分就足够使用了。</p>
<p><strong>Unsplash</strong><br><a href="https://unsplash.com/">https://unsplash.com/</a></p>
<p>最知名的无版权图片网站，这家以风景为主，数量足够多，但是很多滤镜感太强，颜色太过厚重，比较适合做壁纸，事实上很多壁纸软件也是直接从这上面下载的图</p>
<p><strong>Pixabay</strong><br><a href="https://pixabay.com/">https://pixabay.com/</a></p>
<p>小美最常用的一家，可以说是全球最大的免费图片网站了。图多而且种类足够丰富。这其实也是一家集合网站，可以看到 Unsplash 家的很多图也能在 Pixabay 里搜到</p>
<p><strong>Pexels</strong><br><a href="https://www.pexels.com/">https://www.pexels.com/</a></p>
<p>这家也有很多精美的图片，而且比较好的一点是会有「一周精选」，平常没事的时候来收收图也挺好的</p>
<p><strong>visualhunt</strong><br><a href="https://visualhunt.com/">https://visualhunt.com/</a></p>
<p>数量超级多的无版权图片网站，可以根据颜色进行搜索</p>
<h3 id="第二找图梯队"><a href="#第二找图梯队" class="headerlink" title="第二找图梯队"></a>第二找图梯队</h3><p>这里面是一些图片资源没有那么丰富，但是质量都还不错的，如果之前的网站没有找到合适的，可以在这里再次搜寻一下。</p>
<p><strong>别样网</strong><br><a href="http://www.ssyer.com/">http://www.ssyer.com/</a></p>
<p>找图新欢，旅行日常为主，图片多为用户自己上传，所以在其他地方很少见到</p>
<p><strong>Gratisography</strong><br><a href="https://gratisography.com/">https://gratisography.com/</a></p>
<p>每周都会更新，图片角度和题材都比较另类，人物图片不少，另外他家的 logo 也比较另类……</p>
<p><strong>StreetWill</strong><br><a href="http://streetwill.co/">http://streetwill.co/</a></p>
<p>优点是图片都比较精致小众，缺点是更新慢</p>
<p><strong>IM FREE</strong><br><a href="http://imcreator.com/free">http://imcreator.com/free</a></p>
<p>图片分类详细，可按分类进行筛选</p>
<p><strong>Magdeleine</strong><br><a href="https://magdeleine.co/browse/">https://magdeleine.co/browse/</a></p>
<p>有编辑精选，图片也比较厚重</p>
<p><strong>FancyCrave</strong><br><a href="http://fancycrave.com/">http://fancycrave.com/</a></p>
<p>每天两张手工筛选精品照片，每张都在诉说一个故事</p>
<h3 id="精准找图梯队"><a href="#精准找图梯队" class="headerlink" title="精准找图梯队"></a>精准找图梯队</h3><p>一般搜索图片都是用关键词进行搜索，搜索单一的关键词还好，一旦稍复杂些的就很容易搜索不出来，这时候你就需要一些精准找图方案。</p>
<p><strong>Flickr</strong><br><a href="https://www.flickr.com/">https://www.flickr.com/</a></p>
<p>第一个是雅虎著名的图片社区——Flickr，由于汇集了大批的摄影师，所以 Flickr 家的图片质量都相当之高，不过你可能会说 Flickr 的图片不都是有版权的吗？别急，在「授权」那里选择「所有创用CC」或者「允许商业用途」即可找到那些可以使用的图片啦</p>
<p>ps.由于 Flickr 目前没有简体中文版，所以搜索时用英文或者繁体中文会得到比较好的结果</p>
<p><strong>Google</strong><br><a href="https://www.google.com/?gws_rd=ssl">https://www.google.com/?gws_rd=ssl</a></p>
<p>第二个是我大谷歌，谷歌的图片搜索那是相当的强大，选择右侧的「工具」，可以自定义很多东西，包括大小、颜色及使用权限</p>
<h3 id="分类找图"><a href="#分类找图" class="headerlink" title="分类找图"></a>分类找图</h3><p><strong>Life of Pix</strong><br><a href="http://www.lifeofpix.com/">http://www.lifeofpix.com/</a></p>
<p>景色建筑为主，色调比较统一</p>
<p><strong>pngimg</strong><br><a href="http://pngimg.com/">http://pngimg.com/</a></p>
<p>这个厉害了，2 万多张不同种类的无背景素材图片！全都是抠好图的，直接免费用！</p>
<p><strong>Moveast</strong><br><a href="http://moveast.me/">http://moveast.me/</a></p>
<p>全部都是旅行风景图片</p>
<p><strong>旅行日记</strong><br><a href="http://travelcoffeebook.com/">http://travelcoffeebook.com/</a></p>
<p>从名字就能看出来，主要是旅行题材的图片</p>
<p><strong>FoodiesFeed</strong><br><a href="https://www.foodiesfeed.com/">https://www.foodiesfeed.com/</a></p>
<p>全是好吃的！全是免费的（图片）！</p>
<p><strong>Sozai-Page</strong><br><a href="http://www.sozai-page.com/">http://www.sozai-page.com/</a></p>
<p>日本的高清食物无背景素材图片</p>
<p><strong>PEEKSPACE</strong><br><a href="http://peek.space/">http://peek.space/</a></p>
<p>超清的太空图片，大多来自 NASA</p>
<p><strong>kaboompics</strong><br><a href="https://kaboompics.com/">https://kaboompics.com/</a></p>
<p>以生活化场景为主，比方说手机、日历之类的，也有一些 mockup</p>
<p><strong>泼辣有图</strong><br><a href="http://www.polayoutu.com/collections">http://www.polayoutu.com/collections</a></p>
<p>泼辣修图出的开源摄影网站，全部是无版权的摄影作品</p>
<p><strong>Oliur Rahman</strong><br><a href="http://photos.oliur.com/">http://photos.oliur.com/</a></p>
<p>各种 iPhone、MacBook 和其他物件的好照片</p>
<p><strong>Pixite Source</strong><br><a href="http://source.pixite.co/">http://source.pixite.co/</a></p>
<p>出品了图像编辑应用 Union、涂色应用 Pigment、矢量制作工具 Assembly 等知名应用的 Pixite，出的一个图库网站，可以搜索图片、材质、色调搜索，里面有很多比较精致的小众插图</p>
<p><strong>Free Nature Stock</strong><br><a href="http://freenaturestock.com/">http://freenaturestock.com/</a></p>
<p>如网站名，全部是自然风光图片</p>
<p><strong>New Old Stock</strong><br><a href="https://nos.twnsnd.co/">https://nos.twnsnd.co/</a></p>
<p>公共领域的一些老照片，可以免费使用</p>
<p><strong>Freely Photos</strong><br><a href="https://freelyphotos.com/">https://freelyphotos.com/</a></p>
<p>很多十字架，很多宗教祈祷的图片</p>
<h3 id="备选方案"><a href="#备选方案" class="headerlink" title="备选方案"></a>备选方案</h3><p>接下来这些就是上述都找不到的情况下的备选方案啦，多达XX个网站，不信没有合适的，哼。</p>
<p>这些网站有的是因为图片质量参差不齐，有的是因为上述的网站已经能够解决需求，所以没怎么刷，大家平时有时间的时候可以多逛逛这些网站，收集一些素材。</p>
<p><strong>MMT</strong><br><a href="https://mmtstock.com/">https://mmtstock.com/</a></p>
<p>色调比较亮丽，有很多花，也有很多 iPhone……</p>
<p><strong>Realistic Shots</strong><br><a href="http://realisticshots.com/">http://realisticshots.com/</a></p>
<p>生活化场景为主，每周 7 张图片</p>
<p><strong>DesignerPics</strong><br><a href="http://www.designerspics.com/">http://www.designerspics.com/</a></p>
<p>多为局部特写，也可按种类进行筛选</p>
<p><strong>Stokpic</strong><br><a href="http://stokpic.com/">http://stokpic.com/</a></p>
<p>有很多人物图片，每两周更新 10 张</p>
<p><strong>JÉSHOOTS</strong><br><a href="http://jeshoots.com/">http://jeshoots.com/</a></p>
<p>2014 年开始运营的无版权图片网站，图片质量还不错</p>
<p><strong>ISO REPUBLIC</strong><br><a href="https://isorepublic.com/">https://isorepublic.com/</a></p>
<p>多走简洁风格</p>
<p><strong>jay mantri</strong><br><a href="http://jaymantri.com/">http://jaymantri.com/</a></p>
<p>个人博客网站，每周更新 7 张图片</p>
<p><strong>picjumbo</strong><br><a href="https://picjumbo.com/">https://picjumbo.com/</a></p>
<p>日常场景居多，有不少数码设备</p>
<p><strong>ZEROSPACE</strong>  </p>
<p>台湾的无版权图片网站，质量还行</p>
<p><strong>public domain archive</strong><br><a href="http://publicdomainarchive.com/">http://publicdomainarchive.com/</a></p>
<p>很多黑白照片，也有很多可供个人使用的无版权图片</p>
<p><strong>RAUMROT</strong><br><a href="https://www.howtostartanllc.org/free-stock-photos/">https://www.howtostartanllc.org/free-stock-photos/</a></p>
<p>里面有很多可供商用的图片选集，在主页的底部</p>
<p><strong>FFCU</strong><br><a href="http://freeforcommercialuse.net/">http://freeforcommercialuse.net/</a></p>
<p>图片数量不多，不过有一些好图</p>
<p><strong>REFE</strong><br><a href="http://niceappslave1.zuimeia.com/">http://niceappslave1.zuimeia.com</a></p>
<p>个人博客，收集真实生活的无版权图片</p>
<p><strong>StockSnap</strong><br><a href="https://stocksnap.io/">https://stocksnap.io/</a></p>
<p>生活类图片，角度和主题都不错</p>
<p><strong>My Stock Photos</strong><br><a href="http://mystock.photos/">http://mystock.photos/</a></p>
<p>这里面的图片都挺好看的</p>
<p><strong>skuawk</strong><br><a href="http://skuawk.com/">http://skuawk.com/</a></p>
<p>摄影师拍摄的无版权图片网站，分类浏览</p>
<p><strong>BARN IMAGES</strong><br><a href="https://barnimages.com/">https://barnimages.com/</a></p>
<p>有很多比较生活化和小清新的图片</p>
<p><strong>freejpg</strong><br><a href="http://en.freejpg.com.ar/">http://en.freejpg.com.ar/</a></p>
<p>有一些动物的图片，可直接搜索，也可按照颜色搜索</p>
<p><strong>stockvault</strong><br><a href="http://www.stockvault.net/">http://www.stockvault.net/</a></p>
<p>大部分为摄影作品，也有少量的插图</p>
<p><strong>goodfreephotos</strong><br><a href="https://www.goodfreephotos.com/">https://www.goodfreephotos.com/</a></p>
<p>1 万 8 千多张无版权图片，质量嘛，参差不齐……</p>
<p><strong>Snapwire Snaps</strong><br><a href="http://snapwiresnaps.tumblr.com/">http://snapwiresnaps.tumblr.com/</a></p>
<p>Tumblr 图片博客，以自然风景和食物为主</p>
<p><strong>tookapic</strong><br><a href="https://stock.tookapic.com/">https://stock.tookapic.com/</a></p>
<p>63000+ 的无版权真实照片</p>
<p><strong>FREEMAGEBANK</strong><br><a href="http://www.freemagebank.com/">http://www.freemagebank.com/</a></p>
<p>多为日常生活图片，另外简笔画的图质量也蛮高的</p>
<p><strong>Cupcake</strong><br><a href="http://cupcake.nilssonlee.se/">http://cupcake.nilssonlee.se/</a></p>
<p>图片色调厚实，适合做背景图</p>
<p><strong>Trunklog</strong><br><a href="http://trunklog.com/">http://trunklog.com/</a></p>
<p>瑞典的一位摄影师旅行所拍摄的照片，全部无偿使用</p>
<p>接下来介绍一些日本的无版权图片网站。</p>
<p><strong>PAKUTASO</strong><br><a href="https://www.pakutaso.com/">https://www.pakutaso.com/</a></p>
<p>一看就知道是霓虹国的网站，稀奇古怪的图片一大堆，不过网站 logo 好萌……</p>
<p><strong>Photock</strong><br><a href="https://www.photock.jp/">https://www.photock.jp/</a></p>
<p>日本的无版权图片网站，在里面能很容易地找到富士山、樱花、东京等元素</p>
<p><strong>無料写真素材</strong><br><a href="http://freephoto.bizutart.com/">http://freephoto.bizutart.com/</a></p>
<p>日本无版权图片，全部都是日式元素图片，红叶啊、樱花啊、猫啊啥的</p>
<p><strong>photosku</strong><br><a href="http://photosku.com/">http://photosku.com/</a></p>
<p>还是日本的，基本没用过……</p>
<p><strong>東京デート</strong><br><a href="https://www.tokyo-date.net/">https://www.tokyo-date.net/</a></p>
<p>日本东京专门的无版权图片网站</p>
<p><strong>沖縄写真素材</strong><br><a href="http://image.ajima.jp/">http://image.ajima.jp/</a></p>
<p>恩…日本冲绳专门的无版权图片网站…</p>
<p><strong>Futta</strong><br><a href="http://www.futta.net/">http://www.futta.net/</a></p>
<p>日本无版权图片网站，基本为风景图片</p>
<p><strong>Imgstyle</strong><br><a href="http://www.imgstyle.info/index.php">http://www.imgstyle.info/index.php</a></p>
<p>如其描述：无料、商业利用可、加工自由、登录不要（全部都是高清植物图片）</p>
<p><strong>ソザイング</strong><br><a href="http://sozaing.com/">http://sozaing.com/</a></p>
<p>这家网站有个分类叫做「365日365枚」，就像一本无版权图片的日记本一样，里面有很多很有意思的图片，比方说纯蓝色的水彩、并立的企鹅、一颗土豆等</p>
<h3 id="终极图片合集"><a href="#终极图片合集" class="headerlink" title="终极图片合集"></a>终极图片合集</h3><p>对于像小美这样的懒人来说，挨个网站去搜还是略麻烦，如果有集合类的网站就好了……</p>
<p>……等会，谁说没有的？！</p>
<p><strong>The Stocks</strong><br><a href="http://thestocks.im/">http://thestocks.im/</a></p>
<p>The Stocks 就是家无版权图片集合网站，集合了 Unsplash、Stocksy、Pixabay、Free Range、Little Visuals、New Old Stock、Visual Hunt、Super Famous、Startup Stock、GRATISOGRAPHY、GETREFE、PEXELS、jay mantri、Magdeleine、travel coffee、MOVEAST、Barn Images 一共 17 家图片网站，全部 CC0 协议！全部无版权免费使用！</p>
<p>除了无版权图片外，The Stocks 里还有多家配色、图标、视频、手机/电脑外壳、字体等网站集合……想给这家网站捐钱！</p>
<p>（不过由于是集合网站，所以刷新速度上可能会慢点，但这网站我依然给满分）</p>
<p><strong>AllTheFreeStock</strong><br><a href="http://allthefreestock.com/">http://allthefreestock.com/</a></p>
<p>这个跟 Stocks 差不多，但却更加强大！一个地址，找到所有无版权图片、模型、视频、声效、配色、网页模板、字体、图标、邮件模板……</p>
<p>简直就是懒人福音！</p>
<p><strong>EVERYPIXEL</strong><br><a href="https://everypixel.com/">https://everypixel.com/</a></p>
<p>智能搜图工具，可以搜索各大图片网站的图片，并对齐进行精准化的分类。颜色、类型、尺寸、版权，而且可以九宫格单独设置……除了赞美，我无能为力</p>
<p><strong>LibreStock</strong><br><a href="http://librestock.com/">http://librestock.com/</a></p>
<p>一键搜索 47 家无版权图片网站的精品好图</p>
<p><strong>Finda Photo</strong><br><a href="http://finda.photo/">http://finda.photo/</a></p>
<p>一键搜索 Barn Images、Life Of Pix 等十余家的无版权图片，网站本身做得很简洁</p>
]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>比较两个Json串或两个JsonArray串是否完全相等</title>
    <url>/2017/10/23/%E6%AF%94%E8%BE%83%E4%B8%A4%E4%B8%AAJson%E4%B8%B2%E6%88%96%E4%B8%A4%E4%B8%AAJsonArray%E4%B8%B2%E6%98%AF%E5%90%A6%E5%AE%8C%E5%85%A8%E7%9B%B8%E7%AD%89/</url>
    <content><![CDATA[<p>比较两个Json串或两个JsonArray串是否完全相等，使用google提供的包com.google.gson</p>
<blockquote>
<p>比较两个Json串是否相等</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import com.google.gson.JsonObject;  </span><br><span class="line">import com.google.gson.JsonParser;  </span><br><span class="line">  </span><br><span class="line">     JsonParser parser1 &#x3D; new JsonParser();  </span><br><span class="line">     JsonObject obj1 &#x3D; (JsonObject) parser1.parse(str1);  </span><br><span class="line">     JsonParser parser2 &#x3D; new JsonParser();  </span><br><span class="line">     JsonObject obj2 &#x3D; (JsonObject) parser2.parse(str2);  </span><br><span class="line">          </span><br><span class="line">     System.out.println(obj1.equals(obj2)); </span><br></pre></td></tr></table></figure>

<blockquote>
<p>比较两个JsonArray串是否相等</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import com.google.gson.JsonArray;</span><br><span class="line">import com.google.gson.JsonParser;</span><br><span class="line"></span><br><span class="line">    JsonParser parser1 &#x3D; new JsonParser();</span><br><span class="line">    JsonArray array1 &#x3D; (JsonArray) parser1.parse(str1);</span><br><span class="line">    JsonParser parser2 &#x3D; new JsonParser();</span><br><span class="line">    JsonArray array2 &#x3D; (JsonArray) parser2.parse(str2);</span><br><span class="line"></span><br><span class="line">    System.out.println(array1.equals(array2)); </span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Json</tag>
      </tags>
  </entry>
  <entry>
    <title>线程安全与锁优化</title>
    <url>/2020/04/06/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><h4 id="Java中的线程安全"><a href="#Java中的线程安全" class="headerlink" title="Java中的线程安全"></a>Java中的线程安全</h4><p>按照线程安全的“安全程度”分为五大类：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立</p>
<ol>
<li><strong>不可变</strong><br>在Java中不可变(Immutable)对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要再进行任何线程安全保护措施。如<code>final</code>关键字</li>
<li><strong>绝对线程安全</strong><br>绝对的线程安全是指“不管运行时环境如何，调用者都不需要任何额外的同步策略”，绝对的线程安全是需要付出非常高的代价的，甚至是不切实际的代价。而在Java API中标注是线程安全的类，大多数都不是绝对的线程安全，都是相对的线程安全</li>
<li><strong>相对线程安全</strong><br>相对线程安全就是我们通常意义上所讲的线程安全。它需要保证<strong>对象单次的操作是安全的,</strong> 如<code>Vector</code>的<code>get()</code>方法，这个方法是同步的。但是对于一些特定顺序的连续调用，则需要调用端使用额外的同步手段来保证正确性，如使用<code>synchronized</code>关键字<br>在Java中，大部分声明线程安全的类都属于这种类型，如<code>Vector</code>、<code>HashTable</code>、<code>ConcurrentHashMap</code>和<code>Collections</code>的<code>synchronizedCollection()</code>方法包装的集合等</li>
<li><strong>线程兼容</strong><br>线程兼容是值对象本身并不是线程安全的，但是通过调用端正确的使用同步手段来保证对象在并发环境中可以安全的使用。平常我们说一个类不是线程安全的，指的就是这种情况。<br>Java类库中大部分类都是线程兼容的，如<code>ArrayList</code>和<code>HashMap</code>等</li>
<li><strong>线程对立</strong><br>线程独立是指不管调用端是否采取了同步措施，都无法在多线程环境中并发使用。<br>线程对立这种情况是很少出现的，而且通常都是有害的，应当避免<br>如<code>Thread</code>类的<code>suspend()</code>和<code>resume()</code>方法。</li>
</ol>
<h4 id="线程安全的实现方法"><a href="#线程安全的实现方法" class="headerlink" title="线程安全的实现方法"></a>线程安全的实现方法</h4><ol>
<li><p><strong>互斥同步</strong><br>互斥同步是最常见也是最主要的并发保障手段。同步是指共享数据在同一时刻只能背一个线程使用，而互斥是实现同步的一种手段，<code>临界区(Critical Section)</code>、<code>互斥量(Mutex)</code>和<code>信号量(Semaphore)</code>都是常见的互斥实现方式</p>
<ul>
<li>synchronized关键字:<br>在Java中，最基本的互斥同步手段就是<code>synchronized关键字</code>，这是一个块结构的语法。<code>synchronized</code>关键字经过javac编译后，会在同步块前后形成<code>monitorenter</code>和<code>monitorexit</code>两个字节码指令。<br>在执行<code>monitorenter</code>指令时，首先尝试去获取对象锁，如果对象没有被锁定或当前线程已经持有了该对象的锁，就把锁的计数器增加一，而在执行<code>monitorexit</code>指令时将会将锁计数器的值减一。当锁计数器的值为0时，锁则被释放了。如果获取对象锁失败则会一直阻塞等待，直到获取到锁  </li>
</ul>
</li>
</ol>
<p><strong><code>synchronized</code>对于一个线程来说是可重入的，同时<code>synchronized</code>中的锁是非公平的</strong></p>
<pre><code>- 重入锁(ReentrantLock):  
</code></pre>
<p>重入锁(ReentrantLock)是Lock接口最常见的一种实现，与<code>synchronized</code>相似，但是比<code>synchronized</code>相比多了一些高级功能，主要是：等待可中断、可实现公平锁(默认也是非公平锁)、可以绑定多个条件</p>
<ol start="2">
<li><p><strong>非阻塞同步</strong><br>互斥同步也被称为阻塞同步，是一种悲观悲观的并发策略，主要问题是进行线程阻塞和唤醒所带来的性能开销。与之对应的则是乐观的并发策略，最常用的是不断的重试，直接操作共享数据，当出现冲突时，不断的重试，直到没有冲突。<br>最常见的方法是CAS(Compare-and-Swap)，如juc包中的<code>Atomic</code>类则是通过自旋和CAS实现的，同时CAS可能会出现ABA问题，但是大部分情况下ABA问题不会影响程序并发的正确性</p>
</li>
<li><p><strong>无同步方案</strong><br>如果让一个方法不涉及多线程共享数据，自然也不需要去保证线程安全，因为他们天生就是线程安全的，如<code>ThreadLocal</code>这个类，每一个<code>Thread</code>对象都有一个<code>ThreadLocalMap</code>对象，用来存储当前线程的变量</p>
</li>
</ol>
<h3 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h3><blockquote>
<p>JDK 5升级到JDK 6后，进行了大量的锁优化</p>
</blockquote>
<h4 id="自旋锁和自适应自旋"><a href="#自旋锁和自适应自旋" class="headerlink" title="自旋锁和自适应自旋"></a>自旋锁和自适应自旋</h4><ul>
<li>自旋锁：当线程尝试获取锁时发现冲突，则让获取锁的线程等一会，但不放弃CPU的执行时间，而让线程等待则让线程执行一个循环(自旋)即可</li>
<li>自适应自旋：自旋所等待的时间必须有一定的限度，如果超过了限定的次数仍然没有获取到锁，则使用传统的方法挂起该线程，自旋次数默认是10次。而自适应自旋则是自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定</li>
</ul>
<h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><p>锁消除是虚拟机即时编译器在运行时，检测到数据不可能被其他线程访问，则会对锁进行消除。锁消除的主要判断依据来源于逃逸分析的数据支持，如果判断一段代码在堆上的所有数据都不会逃逸出去被其他线程访问到，则可以把他们当作栈上的数据对待，认为他们是线程私有的</p>
<h4 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h4><p>如果虚拟机探测到有一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展(粗化)到整个操作序列的外部。如果<code>StringBuffer.append()</code>方法，连续操作append方法，锁则会扩展到第一个append方法之前和最后一个append方法之后，只需加一次锁就可以</p>
<h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><blockquote>
<p>轻量级锁是通过CAS来实现的</p>
</blockquote>
<p>HotSpot虚拟机的对象头中有一部分用来存储对象自身的运行时数据，如哈希码，GC分代年龄、存储标识位、偏向模式等，官方称它为“Mark Word”。</p>
<p>在代码即将进入同步块之前，如果同步对象没有被锁定，则在当前线程的栈帧中建立一个锁记录(Lock Record)的空间，用来存储锁对象Mark Word的拷贝。<br>然后虚拟机使用CAS操作尝试把对象的Mark Word更新为Lock Record的指针，如果更新成功，则代表该线程拥有了这个对象的所，如果更新失败了，首先检查是否是当前线程拥有了这个对象的锁，如果是的话直接执行即可，如果不是则说明锁被其他线程抢占了。解锁反之。</p>
<p>如果出现两个线程争用一个锁的情况，那轻量级锁则不再有效，必须膨胀为重量级锁</p>
<h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>轻量级锁是在无竞争的情况下使用CAS来消除同步的互斥量，而偏向锁是在无竞争的情况下把整个同步都消除掉，连CAS都不再操作</p>
<p>具体是这样的，当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设置为“01”、把偏向模式设置为“1”，标识进入偏向模式。同时使用CAS操作把获取这个锁的线程ID记录在了对象头的Mark Word中，如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁都不需要有任何同步操作。但是如果另外的线程去尝试获取这个锁，偏向模式则马上宣告结束</p>
<p>偏向锁是一种权衡的优化，如果程序中的大多数锁都总是被多个不同的线程访问，那偏向模式反而是多余的。具体情况具体分析，可以使用参数<code>-CC:-UseBiasedLocking</code>来禁止偏向锁优化</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>缓存更新的套路</title>
    <url>/2017/10/23/%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%9A%84%E5%A5%97%E8%B7%AF/</url>
    <content><![CDATA[<blockquote>
<p>==<strong>原文链接:<a href="https://coolshell.cn/articles/17416.html">https://coolshell.cn/articles/17416.html</a></strong>==</p>
</blockquote>
<p><img src="https://coolshell.cn/wp-content/uploads/2016/07/cache-300x158.png"><br>看到好些人在写更新缓存数据代码时，<strong>先删除缓存，然后再更新数据库</strong>，而后续的操作会把数据再装载的缓存中。<strong>然而，这个是逻辑是错误的</strong>。试想，两个并发操作，一个是更新操作，另一个是查询操作，更新操作删除缓存后，查询操作没有命中缓存，先把老数据读出来后放到缓存中，然后更新操作更新了数据库。于是，在缓存中的数据还是老的数据，导致缓存中的数据是脏的，而且还一直这样脏下去了。</p>
<p>我不知道为什么这么多人用的都是这个逻辑，当我在微博上发了这个贴以后，我发现好些人给了好多非常复杂和诡异的方案，所以，我想写这篇文章说一下几个缓存更新的Design Pattern（让我们多一些套路吧）。</p>
<p>这里，我们先不讨论更新缓存和更新数据这两个事是一个事务的事，或是会有失败的可能，我们先假设更新数据库和更新缓存都可以成功的情况（我们先把成功的代码逻辑先写对）。</p>
<p>更新缓存的的Design Pattern有四种：Cache aside, Read through, Write through, Write behind caching，我们下面一一来看一下这四种Pattern。</p>
<blockquote>
<p><strong>Cache Aside Pattern</strong></p>
</blockquote>
<p>这是最常用最常用的pattern了。其具体逻辑如下：</p>
<ul>
<li><strong>失效</strong>：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。</li>
<li><strong>命中</strong>：应用程序从cache中取数据，取到后返回。</li>
<li><strong>更新</strong>：先把数据存到数据库中，成功后，再让缓存失效。</li>
</ul>
<p><img src="https://coolshell.cn/wp-content/uploads/2016/07/Cache-Aside-Design-Pattern-Flow-Diagram-e1470471723210.png"></p>
<p><img src="https://coolshell.cn/wp-content/uploads/2016/07/Updating-Data-using-the-Cache-Aside-Pattern-Flow-Diagram-1-e1470471761402.png"></p>
<p>注意，我们的更新是先更新数据库，成功后，让缓存失效。那么，这种方式是否可以没有文章前面提到过的那个问题呢？我们可以脑补一下。</p>
<p>一个是查询操作，一个是更新操作的并发，首先，没有了删除cache数据的操作了，而是先更新了数据库中的数据，此时，缓存依然有效，所以，并发的查询操作拿的是没有更新的数据，但是，更新操作马上让缓存的失效了，后续的查询操作再把数据从数据库中拉出来。而不会像文章开头的那个逻辑产生的问题，后续的查询操作一直都在取老的数据。</p>
<p>这是标准的design pattern，包括Facebook的论文《Scaling Memcache at Facebook》也使用了这个策略。为什么不是写完数据库后更新缓存？你可以看一下Quora上的这个问答《Why does Facebook use delete to remove the key-value pair in Memcached instead of updating the Memcached during write request to the backend?》，主要是怕两个并发的写操作导致脏数据。</p>
<p>那么，是不是Cache Aside这个就不会有并发问题了？不是的，比如，一个是读操作，但是没有命中缓存，然后就到数据库中取数据，此时来了一个写操作，写完数据库后，让缓存失效，然后，之前的那个读操作再把老的数据放进去，所以，会造成脏数据。</p>
<p>但，这个case理论上会出现，不过，实际上出现的概率可能非常低，因为这个条件需要发生在读缓存时缓存失效，而且并发着有一个写操作。而实际上数据库的写操作会比读操作慢得多，而且还要锁表，而读操作必需在写操作前进入数据库操作，而又要晚于写操作更新缓存，所有的这些条件都具备的概率基本并不大。</p>
<p><strong>所以，这也就是Quora上的那个答案里说的，要么通过2PC或是Paxos协议保证一致性，要么就是拼命的降低并发时脏数据的概率，而Facebook使用了这个降低概率的玩法，因为2PC太慢，而Paxos太复杂。当然，最好还是为缓存设置上过期时间。</strong></p>
<blockquote>
<p><strong>Read/Write Through Pattern</strong></p>
</blockquote>
<p>我们可以看到，在上面的Cache Aside套路中，我们的应用代码需要维护两个数据存储，一个是缓存（Cache），一个是数据库（Repository）。所以，应用程序比较啰嗦。而Read/Write Through套路是把更新数据库（Repository）的操作由缓存自己代理了，所以，对于应用层来说，就简单很多了。<strong>可以理解为，应用认为后端就是一个单一的存储，而存储自己维护自己的Cache</strong>。</p>
<p><strong>Read Through</strong></p>
<p>Read Through 套路就是在查询操作中更新缓存，也就是说，当缓存失效的时候（过期或LRU换出），Cache Aside是由调用方负责把数据加载入缓存，而Read Through则用缓存服务自己来加载，从而对应用方是透明的。</p>
<p><strong>Write Through</strong></p>
<p>Write Through 套路和Read Through相仿，不过是在更新数据时发生。当有数据更新的时候，如果没有命中缓存，直接更新数据库，然后返回。如果命中了缓存，则更新缓存，然后再由Cache自己更新数据库（这是一个同步操作）</p>
<p>下图自来Wikipedia的Cache词条。其中的Memory你可以理解为就是我们例子里的数据库。</p>
<p><img src="https://coolshell.cn/wp-content/uploads/2016/07/460px-Write-through_with_no-write-allocation.svg_.png"></p>
<blockquote>
<p><strong>Write Behind Caching Pattern</strong></p>
</blockquote>
<p>Write Behind 又叫 Write Back。<strong>一些了解Linux操作系统内核的同学对write back应该非常熟悉，这不就是Linux文件系统的Page Cache的算法吗？是的，你看基础这玩意全都是相通的</strong>。所以，基础很重要，我已经不是一次说过基础很重要这事了。</p>
<p>Write Back套路，一句说就是，在更新数据的时候，只更新缓存，不更新数据库，而我们的缓存会异步地批量更新数据库。这个设计的好处就是让数据的I/O操作飞快无比（因为直接操作内存嘛 ），因为异步，write backg还可以合并对同一个数据的多次操作，所以性能的提高是相当可观的。</p>
<p>但是，其带来的问题是，数据不是强一致性的，而且可能会丢失（我们知道Unix/Linux非正常关机会导致数据丢失，就是因为这个事）。在软件设计上，我们基本上不可能做出一个没有缺陷的设计，就像算法设计中的时间换空间，空间换时间一个道理，有时候，强一致性和高性能，高可用和高性性是有冲突的。软件设计从来都是取舍Trade-Off。</p>
<p>另外，Write Back实现逻辑比较复杂，因为他需要track有哪数据是被更新了的，需要刷到持久层上。操作系统的write back会在仅当这个cache需要失效的时候，才会被真正持久起来，比如，内存不够了，或是进程退出了等情况，这又叫lazy write。</p>
<p>在wikipedia上有一张write back的流程图，基本逻辑如下：</p>
<p><img src="https://coolshell.cn/wp-content/uploads/2016/07/Write-back_with_write-allocation.png"></p>
<blockquote>
<p><strong>再多唠叨一些</strong></p>
</blockquote>
<p>1）上面讲的这些Design Pattern，其实并不是软件架构里的mysql数据库和memcache/redis的更新策略，这些东西都是计算机体系结构里的设计，比如CPU的缓存，硬盘文件系统中的缓存，硬盘上的缓存，数据库中的缓存。<strong>基本上来说，这些缓存更新的设计模式都是非常老古董的，而且历经长时间考验的策略</strong>，所以这也就是，工程学上所谓的Best Practice，遵从就好了。</p>
<p>2）有时候，我们觉得能做宏观的系统架构的人一定是很有经验的，其实，宏观系统架构中的很多设计都来源于这些微观的东西。比如，云计算中的很多虚拟化技术的原理，和传统的虚拟内存不是很像么？Unix下的那些I/O模型，也放大到了架构里的同步异步的模型，还有Unix发明的管道不就是数据流式计算架构吗？TCP的好些设计也用在不同系统间的通讯中，仔细看看这些微观层面，你会发现有很多设计都非常精妙……所以，<strong>请允许我在这里放句观点鲜明的话——如果你要做好架构，首先你得把计算机体系结构以及很多老古董的基础技术吃透了</strong>。</p>
<p>3）在软件开发或设计中，我非常建议在之前先去参考一下已有的设计和思路，<strong>看看相应的guideline，best practice或design pattern，吃透了已有的这些东西，再决定是否要重新发明轮子</strong>。千万不要似是而非地，想当然的做软件设计。</p>
<p>4）上面，我们没有考虑缓存（Cache）和持久层（Repository）的整体事务的问题。比如，更新Cache成功，更新数据库失败了怎么吗？或是反过来。关于这个事，如果你需要强一致性，你需要使用“两阶段提交协议”——prepare, commit/rollback，比如Java 7 的XAResource，还有MySQL 5.7的 XA Transaction，有些cache也支持XA，比如EhCache。当然，XA这样的强一致性的玩法会导致性能下降，关于分布式的事务的相关话题，你可以看看《分布式系统的事务处理》一文。</p>
]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>Cache</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>服务缓存优化</title>
    <url>/2021/02/03/%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h3 id="服务介绍"><a href="#服务介绍" class="headerlink" title="服务介绍"></a>服务介绍</h3><p><code>bizconf</code>服务是公司所有业务的通用配置服务，用来保存所有企业、以及用户的业务配置。分为三个级别的配置，系统级、租户级和用户级。</p>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>之前就有发现<code>bizconf</code>调用量比较大，需要优化缓存来降低调用，而最初现状是只在<code>server</code>端有<code>Redis</code>缓存</p>
<p>问题爆发点：元旦前最后几天，数据库负载高，导致<code>bizconf</code>服务调用耗时从几毫米升高到 20~30 毫秒，这时客户反馈系统库卡顿、反应慢，经过排查发现调用耗时长的请求和<code>bizconf</code>耗时曲线一致，各个业务都用调用<code>bizconf</code>，还有的业务调用多次，<code>bizconf</code>耗时上涨导致整个系统卡顿</p>
<h3 id="优化目标"><a href="#优化目标" class="headerlink" title="优化目标"></a>优化目标</h3><p>在<code>client</code>添加<code>jvm cahce</code>来降低调用，从而做到服务降级，前后共经过俩次优化，第一次优化因为缓存穿透的原因效果不明显，第二次优化后效果显著</p>
<p>优化前调用量：<br><img src="/images/%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%960.png"></p>
<h3 id="第一次优化"><a href="#第一次优化" class="headerlink" title="第一次优化"></a>第一次优化</h3><p>优化范围：在<code>server</code>和<code>client</code>中添加<code>jvm cache</code></p>
<p>使用缓存：使用<code>caffeine cache</code>，分级缓存，在<code>server</code>和<code>client</code>中分别添加两个<code>cache</code>，企业级和用户级的<code>cache</code></p>
<p>缓存设置：</p>
<ul>
<li>size：<code>server</code>中<code>cache size</code>为50000，<code>client</code>中<code>cache size</code>为5000，</li>
<li>过期时间：一个小时</li>
<li>过期策略：<code>expireAfterAccess(long, TimeUnit)</code>按最后访问时间计时</li>
<li>基于引用：<code>softValues()</code>设置为软引用</li>
</ul>
<p>优化后观察：<br>观察发现虽然添加了<code>jvm cache</code>，但是调用量降低的效果不明显，甚至可以说无效果</p>
<p>又观察<code>Redis</code>调用量和<code>db</code>调用量，发现<code>db</code>调用量和<code>Redis</code>调用量差不多，少的很有限，这时觉得这种情况不对，怀疑发生了缓存穿透，缓存没有生效</p>
<p><code>Redis</code>和<code>db</code>调用量：<br><img src="/images/%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%961.png"></p>
<p>经过排查发现一些数据多次的访问数据库，询问对应业务，是在判断企业的某些状态，如果返回<code>false</code>或不存在则认为没有，至此问题定位，缓存穿透导致大量访问数据库，从而解释了为什么优化的效果不明显</p>
<p>针对缓存穿透有了下面的第二次的优化</p>
<h3 id="第二次优化"><a href="#第二次优化" class="headerlink" title="第二次优化"></a>第二次优化</h3><p>针对缓存穿透一般有两种处理方式：使用布隆过滤器和缓存空值</p>
<h4 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h4><p>布隆过滤器具体可以参考<a href="https://blog.csdn.net/yuanlong122716/article/details/104402602">https://blog.csdn.net/yuanlong122716/article/details/104402602</a></p>
<p>布隆过滤器有两个非常重要的缺点：</p>
<ol>
<li>存在误算率，虽然不会错判但是会误判，什么意思呢，返回不存在则一定不存在，返回存在但是并不能判断一定存在</li>
<li>不可以删除</li>
</ol>
<p>如果使用布隆过滤器则有两个场景，保存白名单和黑名单：</p>
<ul>
<li>白名单：如果保存白名单，需要把数据库中所有的数据(表示存在的逻辑true)都保存起来，并且新增时需要同步的维护布隆过滤器数据，但因为是分布式服务需要保证所有服务都同步的维护布隆过滤器，难度比较大；同时布隆过滤器不支持删除，所以不考虑使用白名单</li>
<li>黑名单：如果保存黑名单，把不存在的数据保存起来，但因为会有误判，可能会把存在的数据认为不存在从而返回了空，从而使数据错误，所以不可取</li>
</ul>
<p>分析考虑，不采用布隆过滤器，采用缓存空值的方法更为有效和简单</p>
<h4 id="缓存空值"><a href="#缓存空值" class="headerlink" title="缓存空值"></a>缓存空值</h4><p>优化目标：<br><img src="/images/fs-paas-bizconf%E9%87%8D%E6%9E%84.png"></p>
<p>优化范围：在<code>client</code>中添加<code>jvm cache</code>，在<code>server</code>中只使用<code>Redis cache</code></p>
<p>使用缓存：第一次优化时<code>client</code>端缓存的数据有限，这次决定使用<code>ehcache</code>，可以缓存更大的数据量，同样也是分级缓存</p>
<p>缓存设置：</p>
<ul>
<li>size：每个<code>cache</code>堆内存5000条、堆外内存1MB、磁盘50MB</li>
<li>过期时间：<code>client</code>的<code>jvm cache</code>5小时；<code>server</code>的<code>redis</code>存在的数据24小时，不存在的空值半小时(防止大量不存在的数据把<code>Redis</code>搞崩，还可以更短一些)</li>
<li>过期策略：<code>ExpiryPolicyBuilder.timeToLiveExpiration(Duration timeToLive)</code> 按创建时间计时</li>
</ul>
<p>优化后观察：<br>这次优化后效果显著，调用量就下降了90%，预计所有业务方改完后调用量还会进一步下降</p>
<p>优化前后对比：<br><img src="/images/%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%962.png"></p>
<h3 id="审计日志优化"><a href="#审计日志优化" class="headerlink" title="审计日志优化"></a>审计日志优化</h3><p>优化缓存的同时，增加了审计日志，可以用来分析业务方的不合理调用</p>
]]></content>
      <categories>
        <category>优化</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Cache</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title>服务日志优化</title>
    <url>/2021/01/04/%E6%9C%8D%E5%8A%A1%E6%97%A5%E5%BF%97%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><blockquote>
<p>功能权限服务之前经手的人比较多，不同人日志打印比较乱，并且服务日志打印量很大，但当需要排查问题时，大日志量 <code>grep</code> 困难、关键信息打印不全或没有打印等问题很痛苦，决定对日志方面进行统一的优化</p>
</blockquote>
<h3 id="优化目标"><a href="#优化目标" class="headerlink" title="优化目标"></a>优化目标</h3><ol>
<li>对服务日志量大、关键信息不全、代码中侵入式打印日志乱等问题进行优化</li>
<li>人员角色模块，经常有用户、业务不知道什么时候人员角色发生了变化，针对这个模块增加审计日志，便于观察分析调用、排查问题，给出证据</li>
<li>日志上报日志中心，使得服务发布后日志不丢失</li>
</ol>
<h3 id="优化记录"><a href="#优化记录" class="headerlink" title="优化记录"></a>优化记录</h3><h4 id="服务日志优化"><a href="#服务日志优化" class="headerlink" title="服务日志优化"></a>服务日志优化</h4><ul>
<li><p>日志级别<br><img src="/images/%E6%9C%8D%E5%8A%A1%E6%97%A5%E5%BF%97%E4%BC%98%E5%8C%960.png"></p>
</li>
<li><p>日志内容<br><code>traceId</code>，方法名，方法调用链路，每个方法耗时，入参，出参，异常堆栈</p>
</li>
<li><p>相关类<br>使用 <code>Spring AOP</code>、<code>ThreadLocal</code>、<code>Spring StopWatch</code>、<code>Annotation</code> 注解<br>支持两种日志打印方式，<code>AOP</code> 打印和手动调用<br><img src="/images/%E6%9C%8D%E5%8A%A1%E6%97%A5%E5%BF%97%E4%BC%98%E5%8C%961.png"></p>
</li>
<li><p>使用方式  </p>
</li>
</ul>
<ol>
<li>新建切面类，继承 <code>TraceLogAop</code> 抽象类</li>
<li>编写切点，使用环绕通知，切在需要打印日志的地方</li>
<li>通知中调用父类的 <code>around</code> 方法，传入 <code>ProceedingJoinPoint</code> 和打印耗时日志阈值</li>
<li>如需要特殊处理异常，则重写 <code>exceptionHandler</code> 方法<br><img src="/images/%E6%9C%8D%E5%8A%A1%E6%97%A5%E5%BF%97%E4%BC%98%E5%8C%962.png"></li>
<li>在需要打印 <code>info</code> 日志的方法上添加 <code>@InOutLog(&quot;info&quot;)</code> 注解，<code>debug</code> 级别不用添加，默认就是 <code>debug</code> 级别<br><img src="/images/%E6%9C%8D%E5%8A%A1%E6%97%A5%E5%BF%97%E4%BC%98%E5%8C%963.png"></li>
<li>也可以修改 <code>logback.xml</code> 文件，添加一个 <code>logger</code> 把日志打印到独立的文件中<br><img src="/images/%E6%9C%8D%E5%8A%A1%E6%97%A5%E5%BF%97%E4%BC%98%E5%8C%964.png"></li>
</ol>
<ul>
<li>优化效果<br>入参、出参效果<br><img src="/images/%E6%9C%8D%E5%8A%A1%E6%97%A5%E5%BF%97%E4%BC%98%E5%8C%965.jpg"><br>方法调用链路、耗时效果<br><img src="/images/%E6%9C%8D%E5%8A%A1%E6%97%A5%E5%BF%97%E4%BC%98%E5%8C%966.jpg"><br>根据详细的入参、出参可以快速、准确的排查问题；根据调用链路和耗时可以来分析耗时长的接口，以及耗时的占比，找到最耗时的方法，从而进行优化</li>
</ul>
<h4 id="添加审计日志"><a href="#添加审计日志" class="headerlink" title="添加审计日志"></a>添加审计日志</h4><blockquote>
<p>人员角色模块增加审计日志，上报ES，使用 kibana 展示，便于观察分析调用、排查问题，给出证据</p>
</blockquote>
<p><img src="/images/%E6%9C%8D%E5%8A%A1%E6%97%A5%E5%BF%97%E4%BC%98%E5%8C%967.jpg"></p>
<h4 id="上报日志中心"><a href="#上报日志中心" class="headerlink" title="上报日志中心"></a>上报日志中心</h4><p>有时查问题前一天晚上有过发版，日志信息丢失，导致查询问题困难，针对这种情况把日志上报到日志中心的 Grafana Explore中</p>
<hr>
<p>把日志整体优化后，再也没有了以前的苦恼，有什么问题一目了然(<em>^▽^</em>)</p>
]]></content>
      <categories>
        <category>优化</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式——工厂模式</title>
    <url>/2018/07/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h3><p>工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<br>在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</p>
<h3 id="工厂模式分类："><a href="#工厂模式分类：" class="headerlink" title="工厂模式分类："></a>工厂模式分类：</h3><ol>
<li>简单工厂（Simple Factory）模式，又称静态工厂方法模式（Static Factory Method Pattern）</li>
<li>工厂方法（Factory Method）模式，又称多态性工厂（Polymorphic Factory）模式</li>
<li>抽象工厂（Abstract Factory）模式，又称工具箱（Kit 或Toolkit）模式</li>
</ol>
<hr>
<h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式:"></a>简单工厂模式:</h3><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><ul>
<li>工厂类负责创建的对象比较少：由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂</li>
<li>客户端只知道传入工厂类的参数，对于如何创建对象不关心：客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数。</li>
</ul>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>假设一家工厂，生产电视，汽车等等，我们先为所有产品定义一个共同的产品接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后工厂的产品实现这个接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tv</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Tv</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;product Tv&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;product Car&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建工厂</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Product <span class="title">produce</span><span class="params">(String productName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (productName) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;tv&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Tv();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;car&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Car();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的实现有个问题，如果我们新增产品类的话，需要不断的在工厂类中新增case，这样需要修改的地方比较多，所以利用反射来优化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductFactory2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Product <span class="title">produce</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Product product = (Product) Class.forName(className).newInstance();</span><br><span class="line">            <span class="keyword">return</span> product;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>金字塔原理</title>
    <url>/2021/09/24/%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="结构思考力三层次模型"><a href="#结构思考力三层次模型" class="headerlink" title="结构思考力三层次模型"></a>结构思考力三层次模型</h2><h3 id="三层模型"><a href="#三层模型" class="headerlink" title="三层模型"></a>三层模型</h3><p>理解 -&gt; 重构 -&gt; 呈现</p>
<p><img src="/images/%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%860.png"></p>
<h3 id="模型目标"><a href="#模型目标" class="headerlink" title="模型目标"></a>模型目标</h3><p>隐形思维显性化 -&gt; 显性思维结构化 -&gt; 结构思维形象化</p>
<ul>
<li>隐形思维显性化：要提高自己的思考，首先要看到它</li>
<li>显性思维结构化：看到之后发现不清晰，需要结构化</li>
<li>结构思维形象化：结构化之后还需要把它传递出去，需要形象化的表达</li>
</ul>
<h3 id="金字塔结构"><a href="#金字塔结构" class="headerlink" title="金字塔结构"></a>金字塔结构</h3><p><img src="/images/%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%861.png"></p>
<blockquote>
<p>结构化思维是一种“从无序到有序”的思考过程</p>
<p>需要建立一个“先总后分”的思维方式。先找到解决问题的关键要点，然后再深入分析</p>
</blockquote>
<h2 id="理解：隐形思维显性化"><a href="#理解：隐形思维显性化" class="headerlink" title="理解：隐形思维显性化"></a>理解：隐形思维显性化</h2><h3 id="概况全文的“万能公式”"><a href="#概况全文的“万能公式”" class="headerlink" title="概况全文的“万能公式”"></a>概况全文的“万能公式”</h3><blockquote>
<p><code>在___的基础上，</code></p>
<p><code>从__，__，__N个方面，</code></p>
<p><code>说明了_____________。</code></p>
</blockquote>
<h3 id="结构思考力识别概况技术"><a href="#结构思考力识别概况技术" class="headerlink" title="结构思考力识别概况技术"></a>结构思考力识别概况技术</h3><blockquote>
<p>识别 -&gt; 判断 -&gt; 概况</p>
</blockquote>
<p><img src="/images/%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%862.png"></p>
<h3 id="隐形思维显性化前提"><a href="#隐形思维显性化前提" class="headerlink" title="隐形思维显性化前提"></a>隐形思维显性化前提</h3><p>隐形思维显性化的前提———有审视问题的坐标系</p>
<p><img src="/images/%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%863.png"></p>
<ul>
<li>审视问题的坐标系：<blockquote>
<p>这个事情有没有证据和理由支撑？</p>
<p>这个理由/逻辑是否能够推出结论？</p>
<p>其中的证据/事实是否能有效支撑理由？</p>
<p>是否存在隐藏或模糊不利的证据/事实？</p>
</blockquote>
</li>
</ul>
<h2 id="重构：显性思维结构化"><a href="#重构：显性思维结构化" class="headerlink" title="重构：显性思维结构化"></a>重构：显性思维结构化</h2><h3 id="重构四原则"><a href="#重构四原则" class="headerlink" title="重构四原则"></a>重构四原则</h3><ul>
<li><p>论-结论先行</p>
<blockquote>
<p>一段表达有一个核心观点，最好放在开头</p>
</blockquote>
</li>
<li><p>证-以上统下</p>
<blockquote>
<p>任何一层的论点，是下一层思想的概括</p>
</blockquote>
</li>
<li><p>类-归类分组</p>
<blockquote>
<p>每一组思想属于同一个范畴</p>
</blockquote>
</li>
<li><p>比-逻辑递进</p>
<blockquote>
<p>每一组思想按照一定的逻辑顺序排列</p>
</blockquote>
</li>
</ul>
<h3 id="论-结论先行"><a href="#论-结论先行" class="headerlink" title="论-结论先行"></a>论-结论先行</h3><p>结论先行可以提升我们的表达效率，让人快速理解你的核心意思。结论先行的难点不是先行，而是如何得出结论，需要反复联系</p>
<p><img src="/images/%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%864.png"></p>
<h3 id="证-以上统下"><a href="#证-以上统下" class="headerlink" title="证-以上统下"></a>证-以上统下</h3><p>上有结论，下有理由，结论概括理由，理由支撑结论，上下对应</p>
<p><img src="/images/%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%865.png"></p>
<h3 id="类-归类分组"><a href="#类-归类分组" class="headerlink" title="类-归类分组"></a>类-归类分组</h3><blockquote>
<p>人类大脑一次性接收的信息量是有范围的，这个范围有两个说法：5+-2 和 7+-2，不管是哪个说法，7都是一个临界值，当超过7时都会对记忆造成负担，所以在写方案时最好不要超过7条</p>
</blockquote>
<blockquote>
<p>而很多领导讲话都喜欢讲3点，理由有</p>
<ol>
<li>好记</li>
<li>对方更容易倾听</li>
<li>具有说服力；同时在物理结构中，3是稳定结构</li>
</ol>
<p>但是3点要能把事情说轻，说全，而这依赖 归类分组</p>
</blockquote>
<h4 id="MECE原则"><a href="#MECE原则" class="headerlink" title="MECE原则"></a>MECE原则</h4><blockquote>
<p>归类分组标准采用 MECE原则</p>
</blockquote>
<p>相互独立、完全穷尽</p>
<p>分类时不能有交叉、更不能有遗漏，不重不漏</p>
<p><img src="/images/%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%866.png"></p>
<h3 id="比-逻辑递进"><a href="#比-逻辑递进" class="headerlink" title="比-逻辑递进"></a>比-逻辑递进</h3><p>三种顺序</p>
<ul>
<li>时间顺序</li>
<li>结构顺序</li>
<li>重要性顺序</li>
</ul>
<p><strong>在同一个层级、同一个分支，必须使用同一种逻辑顺序</strong></p>
<p><img src="/images/%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%867.png"></p>
<h2 id="呈现：结构思维形象化"><a href="#呈现：结构思维形象化" class="headerlink" title="呈现：结构思维形象化"></a>呈现：结构思维形象化</h2><blockquote>
<p>形象化表达是结构化思考最有力的输出方式，结构化思考是形象化表达的基础</p>
</blockquote>
<h3 id="结构罗盘"><a href="#结构罗盘" class="headerlink" title="结构罗盘"></a>结构罗盘</h3><blockquote>
<p>形象化表达工具——结构罗盘</p>
</blockquote>
<blockquote>
<p>“配”关系 -&gt; “得”图示 -&gt; “上”包装</p>
</blockquote>
<p><img src="/images/%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%868.png"></p>
<ul>
<li>配关系：确定关系结构图下的一个分支的要素之间是什么关系</li>
<li>得图示：根据关系选择不同图示</li>
<li>上包装：对观点进行高度浓缩提炼，变得更加简洁、明了、容易记忆，及所谓“卖点包装”</li>
</ul>
<h3 id="配关系"><a href="#配关系" class="headerlink" title="配关系"></a>配关系</h3><p>四种模式，十六种关系</p>
<p>根据关系分支下的要素判断属于哪一种模式中的哪一种关系</p>
<p><img src="/images/%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%869.png"></p>
<h3 id="得图示"><a href="#得图示" class="headerlink" title="得图示"></a>得图示</h3><h3 id="上包装"><a href="#上包装" class="headerlink" title="上包装"></a>上包装</h3><p>可以把观点凝练成一句口诀，既好记，又有高度，这种方法为“卖点包装”</p>
<p>可以根据四种包装方法来进行包装</p>
<ul>
<li>简化</li>
<li>类比</li>
<li>整合</li>
<li>引用</li>
</ul>
<p><img src="/images/%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%8610.png"></p>
]]></content>
      <categories>
        <category>通用能力</category>
      </categories>
      <tags>
        <tag>通用能力</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 下各文件夹的结构说明及用途介绍</title>
    <url>/2018/03/02/Linux-%E4%B8%8B%E5%90%84%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E7%BB%93%E6%9E%84%E8%AF%B4%E6%98%8E%E5%8F%8A%E7%94%A8%E9%80%94%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<blockquote>
<p>==<strong>原文链接：<a href="http://www.cnblogs.com/xningge/p/8331631.html">http://www.cnblogs.com/xningge/p/8331631.html</a></strong>==  </p>
</blockquote>
<h3 id="linux下各文件夹的结构说明及用途介绍："><a href="#linux下各文件夹的结构说明及用途介绍：" class="headerlink" title="linux下各文件夹的结构说明及用途介绍："></a>linux下各文件夹的结构说明及用途介绍：</h3><p>/bin：二进制可执行命令。<br>/dev：设备特殊文件。<br>/etc：系统管理和配置文件。<br>/etc/rc.d：启动的配 置文件和脚本。<br>/home：用户主目录的基点，比如用户user的主目录就是/home/user，可以用~user表示。<br>/lib：标准程序设计库，又 叫动态链接共享库，作用类似windows里的.dll文件。<br>/sbin：系统管理命令，这 里存放的是系统管理员使用的管理程序。<br>/tmp：公用的临时文件存储 点。<br>/root：系统管理员的主目 录。<br>/mnt：系统提供这个目录是 让用户临时挂载其他的文件系统。<br>/lost+found：这个 目录平时是空的，系统非正常关机而留下“无家可归”的文件就在这里。<br>/proc：虚拟的目录，是系 统内存的映射。可直接访问这个目录来获取系统信息。<br>/var：某些大文件的溢出 区，比方说各种服务的日志文件。<br>/usr：最庞大的目录，要用 到的应用程序和文件几乎都在这个目录。其中包含：<br>/usr/x11r6：存放x window的目录。<br>/usr/bin：众多的应用程序。<br>/usr/sbin：超级用户的一些管理程序。<br>/usr/doc：linux文档。<br>/usr/include：linux下开发和编译应用程序所需要的头文件。<br>/usr/lib：常用的动态链接库和软件包的配置文件。<br>/usr/man：帮助文档。<br>/usr/src：源代码，linux内核的源代码就放在/usr/src/linux 里。<br>/usr/local/bin：本地增加的命令。<br>/usr/local/lib：本地增加的库根文件系统。  </p>
<p>通常情况下，根文件系统所占空间一般应该比较小，因为其中的绝大部分文件都不需要经常改动，而且包括严格的文件和一个小的 不经常改变的文件系统不容易损坏。除了可能的一个叫/vmlinuz标准的系统引导映像之外，根目录一般不含任何文 件。所有其他文件在根文件系统的子目录中。   </p>
<h4 id="1-bin目录"><a href="#1-bin目录" class="headerlink" title="1. /bin目录"></a>1. /bin目录</h4><p>/bin目录包含了引导启动所需的命令或普通用户可能用的命令(可能在引导启动后)。这些命 令都是二进制文件的可执行程序(bin是binary的简称)，多是系统中重要的系统文件。   </p>
<h4 id="2-sbin目录"><a href="#2-sbin目录" class="headerlink" title="2. /sbin目录"></a>2. /sbin目录</h4><p>/sbin目录类似/bin ，也用于存储二进制文件。因为其中的大部分文件多是系统管理员使用的基本的系统程序，所以虽然普通用户必要且允许时可以使用，但一般不给普通用户使 用。   </p>
<h4 id="3-etc目录"><a href="#3-etc目录" class="headerlink" title="3. /etc目录"></a>3. /etc目录</h4><p>/etc目录存放着各种系统配置文件，其中包括了用户信息文件/etc/passwd， 系统初始化文件/etc/rc等。linux正是靠这些文件才得以正常地运行。   </p>
<h4 id="4-root目录"><a href="#4-root目录" class="headerlink" title="4. /root目录"></a>4. /root目录</h4><p>/root目录是超级用户的目录。   </p>
<h4 id="5-lib目录"><a href="#5-lib目录" class="headerlink" title="5. /lib目录"></a>5. /lib目录</h4><p>/lib目录是根文件系统上的程序所需的共享库，存放了根文件系统程序运行所需的共享文件。 这些文件包含了可被许多程序共享的代码，以避免每个程序都包含有相同的子程序的副本，故可以使得可执行文件变得更小，节省空间。   </p>
<h4 id="6-lib-modules目录"><a href="#6-lib-modules目录" class="headerlink" title="6. /lib/modules目录"></a>6. /lib/modules目录</h4><p>/lib/modules目录包含系统核心可加载各种模块，尤其是那些在恢复损坏的系统时重 新引导系统所需的模块(例如网络和文件系统驱动)。   </p>
<h4 id="7-dev目录"><a href="#7-dev目录" class="headerlink" title="7. /dev目录"></a>7. /dev目录</h4><p>/dev目录存放了设备文件，即设备驱动程序，用户通过这些文件访问外部设备。比如，用户可 以通过访问/dev/mouse来访问鼠标的输入，就像访问其他文件一样。   </p>
<h4 id="8-tmp目录"><a href="#8-tmp目录" class="headerlink" title="8. /tmp目录"></a>8. /tmp目录</h4><p>/tmp目录存放程序在运行时产生的信息和数据。但在引导启动后，运行的程序最好使用/var/tmp来 代替/tmp，因为前者可能拥有一个更大的磁盘空间。   </p>
<h4 id="9-boot目录"><a href="#9-boot目录" class="headerlink" title="9. /boot目录"></a>9. /boot目录</h4><p>/boot目录存放引导加载器(bootstrap loader)使用的文件，如lilo，核心映像也经常放在这里，而不是放在根目录中。但是如果有许多核心映像，这个目录就可能变得很大，这时使用单独的 文件系统会更好一些。还有一点要注意的是，要确保核心映像必须在ide硬盘的前1024柱面内。   </p>
<h4 id="10-mnt目录"><a href="#10-mnt目录" class="headerlink" title="10. /mnt目录"></a>10. /mnt目录</h4><p>/mnt目录是系统管理员临时安装(mount)文件系统的安装点。程序并不自动支持安装到/mnt 。/mnt下面可以分为许多子目录，例如/mnt/dosa可能是使用 msdos文件系统的软驱，而/mnt/exta可能是使用ext2文件系统的软驱，/mnt/cdrom光 驱等等。   </p>
<h4 id="11-proc-usr-var-home目录"><a href="#11-proc-usr-var-home目录" class="headerlink" title="11. /proc, /usr, /var, /home目录"></a>11. /proc, /usr, /var, /home目录</h4><p>其他文件系统的安装点。</p>
<p>目录树可以分为小的部分，每个部分可以在自己的磁盘或分区上。主要部分是根、/usr 、/var 和 /home 文件系统。每个部分有不同的目的。<br>　　每台机器都有根文件系统，它包含系统引导和使其他文件系统得以mount所必要的文件，根文件系统应该有单用户状态所必须的足够的内容。还应该包括修复损坏 系统、恢复备份等的工具。<br>　　/usr 文件系统包含所有命令、库、man页和其他一般操作中所需的不改变的文件。 /usr 不应该有 一般使用中要修改的文件。这样允许此文件系统中的文件通过网络共享，这样可以更有效，因为这样节省了磁盘空间(/usr 很容易是数百兆)，且易于管理 (当升级应用时，只有主/usr 需要改变，而无须改变每台机器) 即使此文件系统在本地盘上，也可以只读mount，以减少系统崩溃时文件系统的损 坏。<br>　　/var 文件系统包含会改变的文件，比如spool目录(mail、news、打印机等用的)， log文件、 formatted manual pages和暂存文件。传统上/var 的所有东西曾在 /usr 下的某个地方，但这样/usr 就不可能只读安装 了。<br>　　/home 文件系统包含用户家目录，即系统上的所有实际数据。一个大的/home 可能要分为若干文件系统，需要在 /home 下加一级名字，如/home/students 、/home/staff 等。 </p>
<p>下面详细介绍：  </p>
<h4 id="etc文件系统"><a href="#etc文件系统" class="headerlink" title="/etc文件系统"></a>/etc文件系统</h4><p>/etc目录包含各种系统配置文件，下面说明其中的一些。其他的你应该知道它们属于哪个程序， 并阅读该程序的man页。许多网络配置文件也在/etc中。  </p>
<ol>
<li>/etc/rc或/etc/rc.d或/etc/rc?.d：启动、或改变运行级时运 行的脚本或脚本的目录。  </li>
<li>/etc/passwd：用户数据库，其中的域给出了用户名、真实姓名、用户起始目 录、加密口令和用户的其他信息。  </li>
<li>/etc/fdprm：软盘参数表，用以说明不同的软盘格式。可用setfdprm进 行设置。更多的信息见setfdprm的帮助页。  </li>
<li>/etc/fstab：指定启动时需要自动安装的文件系统列表。也包括用swapon -a启用的swap区的信息。  </li>
<li>/etc/group：类似/etc/passwd ，但说明的不是用户信息而是组的信息。包括组的各种数据。  </li>
<li>/etc/inittab：init 的配置文件。  </li>
<li>/etc/issue：包括用户在登录提示符前的输出信息。通常包括系统的一段短说明 或欢迎信息。具体内容由系统管理员确定。  </li>
<li>/etc/magic：“file”的配置文件。包含不同文件格式的说 明，“file”基于它猜测文件类型。  </li>
<li>/etc/motd：motd是message of the day的缩写，用户成功登录后自动输出。内容由系统管理员确定。<br>常用于通告信息，如计划关机时间的警告等。</li>
<li>/etc/mtab：当前安装的文件系统列表。由脚本(scritp)初始化，并由 mount命令自动更新。当需要一个当前安装的文件系统的列表时使用(例如df命令)。  </li>
<li>/etc/shadow：在安装了影子(shadow)口令软件的系统上的影子口令 文件。影子口令文件  将/etc/passwd文件中的加密口令移动到/etc/shadow中，而后者只对超级用户(root)可读。这使破译口令更困 难，以此增加系统的安全性。  </li>
<li>/etc/login.defs：login命令的配置文件。  </li>
<li>/etc/printcap：类似/etc/termcap ，但针对打印机。语法不同。  </li>
<li>/etc/profile 、/etc/csh.login、/etc/csh.cshrc：登 录或启动时bourne或cshells执行的文件。这允许系统管理员为所有用户建立全局缺省环境。  </li>
<li>/etc/securetty：确认安全终端，即哪个终端允许超级用户(root) 登录。一般只列出虚拟控制台，这样就不可能(至少很困难)通过调制解调器(modem)或网络闯入系统并得到超级用户特权。  </li>
<li>/etc/shells：列出可以使用的shell。chsh命令允许用户在本文件 指定范围内改变登录的shell。提供一台机器ftp服务的服务进程ftpd检查用户shell是否列在/etc/shells文件 中，如果不是，将不允许该用户登录。  </li>
<li>/etc/termcap：终端性能数据库。说明不同的终端用什么“转义序列”控 制。写程序时不直接输出转义<br>序列(这样只能工作于特定品牌的终端)，而是从/etc/termcap中查找要做的工作的 正确序列。这样，多数的程序可以在多数终端上运行。  </li>
</ol>
<h4 id="dev文件系统"><a href="#dev文件系统" class="headerlink" title="/dev文件系统"></a>/dev文件系统</h4><p>/dev目录包括所有设备的设备文件。设备文件用特定的约定命名，这在设备列表中说明。设备文件在安装时由系 统产生，以后可以用/dev/makedev描述。/dev/makedev.local 是系统管理员为本地设备文件(或连接)写的描述文稿(即如一些非标准设备驱动不是标准makedev 的一部分)。下面简要介绍/dev下 一些常用文件。  </p>
<ol>
<li>/dev/console：系统控制台，也就是直接和系统连接的监视器。  </li>
<li>/dev/hd：ide硬盘驱动程序接口。如：/dev/hda指的是第一个硬 盘，had1则是指/dev/hda的第一个分区。如系统中有其他的硬盘，则依次为/dev /hdb、/dev/hdc、. . . . . .；如有多个分区则依次为hda1、hda2 . . . . . .  </li>
<li>/dev/sd：scsi磁盘驱动程序接口。如系统有scsi硬盘，就不会访问/dev/had， 而会访问/dev/sda。</li>
<li>/dev/fd：软驱设备驱动程序。如：/dev/fd0指 系统的第一个软盘，也就是通常所说的a盘，/dev/fd1指第二个软盘，. . . . . .而/dev/fd1 h1440则表示访问驱动器1中的4.5高密盘。  </li>
<li>/dev/st：scsi磁带驱动器驱动程序。  </li>
<li>/dev/tty：提供虚拟控制台支持。如：/dev/tty1指 的是系统的第一个虚拟控制台，/dev/tty2则是系统的第二个虚拟控制台。  </li>
<li>/dev/pty：提供远程登陆伪终端支持。在进行telnet登录时就要用到/dev/pty设备。  </li>
<li>/dev/ttys：计算机串行接口，对于dos来说就是“com1”口。  </li>
<li>/dev/cua：计算机串行接口，与调制解调器一起使用的设备。  </li>
<li>/dev/null：“黑洞”，所有写入该设备的信息都将消失。例如：当想要将屏幕 上的输出信息隐藏起来<br>时，只要将输出信息输入到/dev/null中即可。  </li>
</ol>
<h4 id="usr文件系统"><a href="#usr文件系统" class="headerlink" title="/usr文件系统"></a>/usr文件系统</h4><p>/usr是个很重要的目录，通常这一文件系统很大，因为所有程序安装在这里。/usr里 的所有文件一般来自linux发行版；本地安装的程序和其他东西在/usr/local下，因为这样可以在升级新版系 统或新发行版时无须重新安装全部程序。/usr目录下的许多内容是可选的，但这些功能会使用户使用系统更加有效。/usr可容纳许多大型的软件包和它们的 配置文件。下面列出一些重要的目录(一些不太重要的目录被省略了)。  </p>
<ol>
<li>/usr/x11r6：包含x window系统的所有可执行程序、配置文件和支持文件。为简化x的开发和安装，x的文件没有集成到系统中。x window系统是一个功能强大的图形环境，提供了大量的图形工具程序。用户如果对microsoft windows比较熟悉的话，就不会对x window系统感到束手无策了。  </li>
<li>/usr/x386：类似/usr/x11r6 ，但是是专门给x 11 release 5的。  </li>
<li>/usr/bin：集中了几乎所有用户命令，是系统的软件库。另有些命令在/bin或/usr/local/bin中。  </li>
<li>/usr/sbin：包括了根文件系统不必要的系统管理命令，例如多数服务程序。  </li>
<li>/usr/man、/usr/info、/usr/doc：这些目录包含所有手册页、 gnu信息文档和各种其他文档文件。每个联机手册的“节”都有两个子目录。例如：/usr/man/man1中包含联机手册第一节的源码(没有格式化的原 始文件)，/usr/man/cat1包含第一节已格式化的内容。联机手册分为以下九节：内部命令、系统调用、库函数、设备、文件格式、游戏、宏软件包、 系统管理和核心程序。  </li>
<li>/usr/include：包含了c语言的头文件，这些文件多以.h结尾，用来描述c 语言程序中用到的数据结构、<br>子过程和常量。为了保持一致性，这实际上应该放在/usr/lib下，但习惯上一直沿用了这个名字。  </li>
<li>/usr/lib：包含了程序或子系统的不变的数据文件，包括一些site - wide配置文件。名字lib来源于库(library); 编程的原始库也存在/usr/lib 里。当编译程序时，程序便会和其中的库进行连接。也有许多程序把配置文件存入其中。  </li>
<li>/usr/local：本地安装的软件和其他文件放在这里。这与/usr很相似。用户 可能会在这发现一些比较大<br>的软件包，如tex、emacs等。  </li>
</ol>
<h4 id="var文件系统"><a href="#var文件系统" class="headerlink" title="/var文件系统"></a>/var文件系统</h4><p>/var包含系统一般运行时要改变的数据。通常这些数据所在的目录的大小是要经常变化或扩充 的。原来/var目录中有些内容是在/usr中的，但为了保持/usr目录的相对稳定，就把那些需要经常改变的目录放到/var中了。每个系统是特定的， 即不通过网络与其他计算机共享。下面列出一些重要的目录(一些不太重要的目录省略了)。  </p>
<ol>
<li>/var/catman：包括了格式化过的帮助(man)页。帮助页的源文件一般存在 /usr/man/catman中；有些man页可能有预格式化的版本，存在/usr/man/cat中。而其他的man页在第一次看时都需要格式化，格 式化完的版本存在/var/man中，这样其他人再看相同的页时就无须等待格式化了。(/var/catman经常被 清除，就像清除临时目录一样。)  </li>
<li>/var/lib：存放系统正常运行时要改变的文件。  </li>
<li>/var/local：存放/usr/local中 安装的程序的可变数据(即系统管理员安装的程序)。注意，如果必要，即使本地安装的程序也会使用其他/var目录，例如/var/lock 。  </li>
<li>/var/lock：锁定文件。许多程序遵循在/var/lock中 产生一个锁定文件的约定，以用来支持他们正在<br>使用某个特定的设备或文件。其他程序注意到这个锁定文件时，就不会再使用这个设备或文件。  </li>
<li>/var/log：各种程序的日志(log)文件，尤其是login (/var/log/wtmplog纪 录所有到系统的登录和注销) 和syslog (/var/log/messages 纪录存储所有核心和系统程序信息)。/var/log 里的文件经常不确定地增长，应该定期清除。  </li>
<li>/var/run：保存在下一次系统引导前有效的关于系统的信息文件。例如，/var/run/utmp包 含当前登录的用户的信息。  </li>
<li>/var/spool：放置“假脱机(spool)”程序的目录，如mail、 news、打印队列和其他队列工作的目录。每个不同的spool在/var/spool下有自己的子目录，例如，用户的邮箱就存放在/var/spool/mail 中。  </li>
<li>/var/tmp：比/tmp允许更大的或需要存在较长时间的临时文件。注意系统管理 员可能不允许/var/tmp有很旧的文件。  </li>
</ol>
<h4 id="proc文件系统"><a href="#proc文件系统" class="headerlink" title="/proc文件系统"></a>/proc文件系统</h4><p>/proc文件系统是一个伪的文件系统，就是说它是一个实际上不存在的目录，因而这是一个非 常特殊的目录。它并不存在于某个磁盘上，而是由核心在内存中产生。这个目录用于提供关于系统的信息。下面说明一些最重要的文件和目录(/proc文件系统 在proc man页中有更详细的说明)。  </p>
<ol>
<li>/proc/x：关于进程x的信息目录，这x是这一进程的标识号。每个进程在 /proc下有一个名为自己进程号的目录。  </li>
<li>/proc/cpuinfo：存放处理器(cpu)的信息，如cpu的类型、制造商、 型号和性能等。  </li>
<li>/proc/devices：当前运行的核心配置的设备驱动的列表。  </li>
<li>/proc/dma：显示当前使用的dma通道。  </li>
<li>/proc/filesystems：核心配置的文件系统信息。  </li>
<li>/proc/interrupts：显示被占用的中断信息和占用者的信息，以及被占用 的数量。  </li>
<li>/proc/ioports：当前使用的i/o端口。  </li>
<li>/proc/kcore：系统物理内存映像。与物理内存大小完全一样，然而实际上没有 占用这么多内存；它仅<br>仅是在程序访问它时才被创建。(注意：除非你把它拷贝到什么地方，否则/proc下没有任何东西占用任何磁盘空间。)  </li>
<li>/proc/kmsg：核心输出的消息。也会被送到syslog。  </li>
<li>/proc/ksyms：核心符号表。  </li>
<li>/proc/loadavg：系统“平均负载”；3个没有意义的指示器指出系统当前 的工作量。  </li>
<li>/proc/meminfo：各种存储器使用信息，包括物理内存和交换分区 (swap)。  </li>
<li>/proc/modules：存放当前加载了哪些核心模块信息。  </li>
<li>/proc/net：网络协议状态信息。  </li>
<li>/proc/self：存放到查看/proc的 程序的进程目录的符号连接。当2个进程查看/proc时，这将会是不同的连接。这主要便于程序得到它自己的进程目录。  </li>
<li>/proc/stat：系统的不同状态，例如，系统启动后页面发生错误的次数。  </li>
<li>/proc/uptime：系统启动的时间长度。  </li>
<li>/proc/version：核心版本。  </li>
</ol>
<h4 id="usr-local"><a href="#usr-local" class="headerlink" title="/usr/local"></a>/usr/local</h4><p>一般是你安装软件的目录，这个目录就相当于在windows下的programefiles这个目录   </p>
<h4 id="opt"><a href="#opt" class="headerlink" title="/opt"></a>/opt</h4><p>这个目录是一些大型软件的安装目录，或者是一些服务程序的安装目录  </p>
<p>举个例子：刚才装的测试版firefox，就可以装到/opt/firefox_beta目录下，/opt/firefox_beta目录下面就包含了运 行firefox所需要的所有文件、库、数据等等。要删除firefox的时候，你只需删除/opt/firefox_beta目录即可，非常简单。  </p>
<h4 id="usr-local-1"><a href="#usr-local-1" class="headerlink" title="/usr/local"></a>/usr/local</h4><p>这里主要存放那些手动安装的软件，即 不是通过“新立得”或apt-get安装的软件 。 它和/usr目录具有相类似的目录结构 。让软件包管理器来管理/usr目录，而把自定义的脚本(scripts)放到/usr/local目录下面，我想这应该是个不错的主意</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL介绍</title>
    <url>/2021/11/26/PostgreSQL%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p><img src="/images/postgresql0.png"></p>
<h1 id="关于PostgreSQL"><a href="#关于PostgreSQL" class="headerlink" title="关于PostgreSQL"></a>关于PostgreSQL</h1><p><code>PostgreSQL</code> 是一个强大的开源对象关系数据库系统，它使用并扩展了 SQL 语言，并结合了许多安全存储和扩展最复杂数据工作负载的功能。</p>
<p><code>PostgreSQL</code> 是以加州大学伯克利分校计算机系开发的<a href="https://dsf.berkeley.edu/postgres.html">POSTGRES， 版本 4.2</a>为基础的对象关系型数据库系统</p>
<p><code>PostgreSQL</code>，也称为 <code>Postgres</code>，简称<strong>PG</strong>(以下都简称PG)</p>
<p>PG 号称是“世界上最先进的开源关系型数据库”，和“世界上最好的语言”不同，PG的自吹自擂并没有受到大家的调侃</p>
<p>PG 不属于任何一家公司，它背后的控制机构是——<strong>PostgreSQL全球开发小组</strong>，是一个松散的组织</p>
<p>其核心成员来自全球各地的不同公司，如果感兴趣，可以在PG<a href="https://www.postgresql.org/community/contributors/">官网</a>查询到这个组织的成员列表</p>
<p>可以这么说，没有任何一个公司享有对 PG 的绝对控制权，PG永远是属于社区</p>
<h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><blockquote>
<p>开源大家都不陌生，但是开源并不等于免费，下面是几种协议的区别</p>
</blockquote>
<p><img src="/images/postgresql1.png"></p>
<ul>
<li><p>GPL 协议：</p>
<p>GPL 是一种传染协议，如果修改了源码，也必须使用 GPL 协议</p>
<p>GPL 是一种“非商业”友好协议，如果是商业项目，那一定要注意 GPL 的可能带来的问题</p>
<p>Linux 内核 使用的就是 GPL 协议，免费的 MySQL 社区版使用的也是 GPL 协议</p>
</li>
<li><p>BSD 协议：</p>
<p>BSD 是一个给予使用者很大自由的协议</p>
<p>基本上使用者可以“为所欲为”可以自由的使用,修改源代码,也可以将修改后的代码作为开源或者专有软件再发布</p>
</li>
</ul>
<p>PG 早期使用的就是 BSD 协议，后面换成了自有协议——<strong>PostgreSQL License</strong>，虽然换了自由协议，但并没有多少改变，依然属于最为友好的协议类型</p>
<p>不论是自用还是商用，都是完全没有问题，修改代码并且用来盈利也是毫无商业风险的</p>
<h2 id="PG影响力"><a href="#PG影响力" class="headerlink" title="PG影响力"></a>PG影响力</h2><ul>
<li><p>在行业中的应用(几年前的图)</p>
<p><img src="/images/postgresql2.png"></p>
</li>
<li><p><a href="https://db-engines.com/en/ranking_trend">DB-Engines 排名</a></p>
<p><img src="/images/postgresql3.png"></p>
</li>
<li><p>Stack Overflow 问卷调查</p>
<p><a href="https://insights.stackoverflow.com/survey/2021#section-most-loved-dreaded-and-wanted-databases">2021最受欢迎数据库排名</a></p>
<p><img src="/images/postgresql4.png"></p>
<p><a href="https://insights.stackoverflow.com/survey/2021#section-most-loved-dreaded-and-wanted-databases">2021使用数据库排名</a></p>
<p><img src="/images/postgresql5.png"></p>
</li>
</ul>
<h1 id="PG功能"><a href="#PG功能" class="headerlink" title="PG功能"></a>PG功能</h1><h2 id="SQL标准"><a href="#SQL标准" class="headerlink" title="SQL标准"></a>SQL标准</h2><p>最新的 SQL 标准是 SQL:2016</p>
<p>SQL:2016 标准中的核心标准中的<strong>179</strong>项特性，而 PG 至少实现了<strong>170</strong>项，在数据库中也算名列前茅的</p>
<h2 id="Schema"><a href="#Schema" class="headerlink" title="Schema"></a>Schema</h2><h3 id="Schema定义"><a href="#Schema定义" class="headerlink" title="Schema定义"></a>Schema定义</h3><p>一个 PG 集群可以包含多个数据库，一个数据库包含一个或多个命名<em>模式</em>，模式中包含着表</p>
<p><code>schema</code> 还包含其他类型的命名对象，包括数据类型、函数和操作符。相同的对象名称可以被用于不同的模式中而不会出现冲突，例如 schema1 和 myschema 都可以包含名为 mytable 的表</p>
<p>下面是一些使用 <code>schema</code> 的原因：</p>
<ul>
<li>允许多个用户使用一个数据库并且不会互相干扰</li>
<li>将数据库对象组织成逻辑组以便更容易管理</li>
<li>第三方应用的对象可以放在独立的模式中，这样它们就不会与其他对象的名称发生冲突</li>
</ul>
<p><code>schema</code> 类似于操作系统层的目录，但是 <code>schema</code> 不能嵌套</p>
<img src="/images/postgresql6.png" style="zoom:50%;" />

<p>默认情况下，新创建的数据库有一个 <code>public</code> 的模式，但可以添加任何其他模式，并且 <code>public</code> 模式不是必需的</p>
<h3 id="Schema使用"><a href="#Schema使用" class="headerlink" title="Schema使用"></a>Schema使用</h3><p>在 SQL 中需要在表名前添加 <code>schema</code> 前缀，如不添加则默认是 <code>public</code> 模式，或使用 <code>search_path</code> 指定 <code>schema</code></p>
<img src="/images/postgresql7.png" style="zoom: 50%;" />



<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>PG 支持非常丰富的数据类型，下面是普通数据类型，同时下面所有普通数据类型都支持数组类型</p>
<table>
<thead>
<tr>
<th align="left">名字</th>
<th align="left">别名(曾经使用过)</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">bigint</td>
<td align="left">int8</td>
<td align="left">有符号的8字节整数</td>
</tr>
<tr>
<td align="left">bigserial</td>
<td align="left">serial8</td>
<td align="left">自动增长的8字节整数</td>
</tr>
<tr>
<td align="left">bit [ (<em><strong>n</strong></em>) ]</td>
<td align="left"></td>
<td align="left">定长位串</td>
</tr>
<tr>
<td align="left">bit varying [ (<em><strong>n</strong></em>) ]</td>
<td align="left">varbit [ (<em><strong>n</strong></em>) ]</td>
<td align="left">变长位串</td>
</tr>
<tr>
<td align="left">boolean</td>
<td align="left">bool</td>
<td align="left">逻辑布尔值（真/假）</td>
</tr>
<tr>
<td align="left">box</td>
<td align="left"></td>
<td align="left">平面上的普通方框</td>
</tr>
<tr>
<td align="left">bytea</td>
<td align="left"></td>
<td align="left">二进制数据（“字节数组”）</td>
</tr>
<tr>
<td align="left">character [ (<em><strong>n</strong></em>) ]</td>
<td align="left">char [ (<em><strong>n</strong></em>) ]</td>
<td align="left">定长字符串</td>
</tr>
<tr>
<td align="left">character varying [ (<em><strong>n</strong></em>) ]</td>
<td align="left">varchar [ (<em><strong>n</strong></em>) ]</td>
<td align="left">变长字符串</td>
</tr>
<tr>
<td align="left">cidr</td>
<td align="left"></td>
<td align="left">IPv4或IPv6网络地址</td>
</tr>
<tr>
<td align="left">circle</td>
<td align="left"></td>
<td align="left">平面上的圆</td>
</tr>
<tr>
<td align="left">date</td>
<td align="left"></td>
<td align="left">日历日期（年、月、日）</td>
</tr>
<tr>
<td align="left">double precision</td>
<td align="left">float8</td>
<td align="left">双精度浮点数（8字节）</td>
</tr>
<tr>
<td align="left">inet</td>
<td align="left"></td>
<td align="left">IPv4或IPv6主机地址</td>
</tr>
<tr>
<td align="left">integer</td>
<td align="left">int, int4</td>
<td align="left">有符号4字节整数</td>
</tr>
<tr>
<td align="left">interval [ <em><strong>fields</strong></em> ] [ (<em><strong>p</strong></em>) ]</td>
<td align="left"></td>
<td align="left">时间段</td>
</tr>
<tr>
<td align="left">json</td>
<td align="left"></td>
<td align="left">文本 JSON 数据</td>
</tr>
<tr>
<td align="left">jsonb</td>
<td align="left"></td>
<td align="left">二进制 JSON 数据，已分解</td>
</tr>
<tr>
<td align="left">line</td>
<td align="left"></td>
<td align="left">平面上的无限长的线</td>
</tr>
<tr>
<td align="left">lseg</td>
<td align="left"></td>
<td align="left">平面上的线段</td>
</tr>
<tr>
<td align="left">macaddr</td>
<td align="left"></td>
<td align="left">MAC（Media Access Control）地址</td>
</tr>
<tr>
<td align="left">macaddr8</td>
<td align="left"></td>
<td align="left">MAC（Media Access Control）地址（EUI-64格式）</td>
</tr>
<tr>
<td align="left">money</td>
<td align="left"></td>
<td align="left">货币数量</td>
</tr>
<tr>
<td align="left">numeric [ (<em><strong>p</strong></em>, <em><strong>s</strong></em>) ]</td>
<td align="left">decimal [ (<em><strong>p</strong></em>, <em><strong>s</strong></em>) ]</td>
<td align="left">可选择精度的精确数字</td>
</tr>
<tr>
<td align="left">path</td>
<td align="left"></td>
<td align="left">平面上的几何路径</td>
</tr>
<tr>
<td align="left">pg_lsn</td>
<td align="left"></td>
<td align="left">PostgreSQL日志序列号</td>
</tr>
<tr>
<td align="left">pg_snapshot</td>
<td align="left"></td>
<td align="left">用户级事务ID快照</td>
</tr>
<tr>
<td align="left">point</td>
<td align="left"></td>
<td align="left">平面上的几何点</td>
</tr>
<tr>
<td align="left">polygon</td>
<td align="left"></td>
<td align="left">平面上的封闭几何路径</td>
</tr>
<tr>
<td align="left">real</td>
<td align="left">float4</td>
<td align="left">单精度浮点数（4字节）</td>
</tr>
<tr>
<td align="left">smallint</td>
<td align="left">int2</td>
<td align="left">有符号2字节整数</td>
</tr>
<tr>
<td align="left">smallserial</td>
<td align="left">serial2</td>
<td align="left">自动增长的2字节整数</td>
</tr>
<tr>
<td align="left">serial</td>
<td align="left">serial4</td>
<td align="left">自动增长的4字节整数</td>
</tr>
<tr>
<td align="left">text</td>
<td align="left"></td>
<td align="left">变长字符串</td>
</tr>
<tr>
<td align="left">time [ (<em><strong>p</strong></em>) ] [ without time zone ]</td>
<td align="left"></td>
<td align="left">一天中的时间（无时区）</td>
</tr>
<tr>
<td align="left">time [ (<em><strong>p</strong></em>) ] with time zone</td>
<td align="left">timetz</td>
<td align="left">一天中的时间，包括时区</td>
</tr>
<tr>
<td align="left">timestamp [ (<em><strong>p</strong></em>) ] [ without time zone ]</td>
<td align="left"></td>
<td align="left">日期和时间（无时区）</td>
</tr>
<tr>
<td align="left">timestamp [ (<em><strong>p</strong></em>) ] with time zone</td>
<td align="left">timestamptz</td>
<td align="left">日期和时间，包括时区</td>
</tr>
<tr>
<td align="left">tsquery</td>
<td align="left"></td>
<td align="left">文本搜索查询</td>
</tr>
<tr>
<td align="left">tsvector</td>
<td align="left"></td>
<td align="left">文本搜索文档</td>
</tr>
<tr>
<td align="left">txid_snapshot</td>
<td align="left"></td>
<td align="left">用户级别事务ID快照(废弃; 参见 pg_snapshot)</td>
</tr>
<tr>
<td align="left">uuid</td>
<td align="left"></td>
<td align="left">通用唯一标识码</td>
</tr>
<tr>
<td align="left">xml</td>
<td align="left"></td>
<td align="left">XML数据</td>
</tr>
</tbody></table>
<p>PG 还可以自定义数据类型，用户可以使用<a href="http://www.postgres.cn/docs/13/sql-createtype.html">CREATE TYPE</a>命令为 <code>PostgreSQL</code>增加新的数据类型</p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h3><p>PG 提供了多种索引类型： <code>B-tree</code>、<code>Hash</code>、<code>GiST</code>、<code>SP-GiST</code> 、<code>GIN</code> 和 <code>BRIN</code></p>
<ul>
<li><p><code>B-tree</code> 可以在可排序数据上的处理等值和范围查询</p>
</li>
<li><p><code>Hash</code> 索引只能处理简单等值比较</p>
</li>
<li><p><code>GiST</code> 索引并不是一种单独的索引，是一个通用的索引接口</p>
</li>
<li><p><code>SP-GiST</code> 类似 <code>GiST</code>，是一个通用的索引接口，但是 <code>SP-GIST</code> 使用了空间分区的方法，使得 <code>SP-GiST</code> 可以更好的支持非平衡数据结构，例如四叉树、k-d树和radix树</p>
</li>
<li><p><code>GIN</code> 索引是“倒排索引”，它适合于包含多个组成值的数据值，例如数组</p>
</li>
<li><p><code>BRIN</code> 索引是块级索引，有别于 <code>B-TREE</code> 等索引，BRIN 记录并不是以行号为单位记录索引明细，而是记录每个数据块或者每段连续的数据块的统计信息</p>
<p>因此 <code>BRIN</code> 索引空间占用特别的小，对数据写入、更新、删除的影响也很小</p>
<p>被索引列的值与物理存储相关性很强时，BRIN 索引的效果非常的好。例如时序数据，在时间或序列字段创建 <code>BRIN</code> 索引，进行等值、范围查询时效果很棒</p>
</li>
</ul>
<p>用户可以通过索引接口自定义索引</p>
<p>所以除上面的内置索引外，还有许多自定义索引，可以根据需求安装其他索引</p>
<h3 id="部分索引"><a href="#部分索引" class="headerlink" title="部分索引"></a>部分索引</h3><p>部分索引 又习惯称 <code>条件索引</code></p>
<p>一个条件索引是建立在表的一个子集上，而该子集则由一个条件表达式定义</p>
<p>而索引中只包含那些符合条件表达式的行。条件索引是一种专门的特性，但在很多种情况下它们也很有用</p>
<p>使用场景：</p>
<p>多租户的场景下，数据存在一个表中，不同租户存储的数据不同，使用场景不同，可以根据不同租户场景建立条件索引</p>
<h3 id="表达式索引"><a href="#表达式索引" class="headerlink" title="表达式索引"></a>表达式索引</h3><p>部分索引 又习惯称 <code>函数索引</code></p>
<p>一个索引列并不一定是底层表的一个列，也可以是从表的一列或多列计算而来的一个函数或者标量表达式</p>
<h2 id="过程语言"><a href="#过程语言" class="headerlink" title="过程语言"></a>过程语言</h2><blockquote>
<p>Procedural Language（过程语言）简称 PL</p>
</blockquote>
<p>几乎每个关系型数据库都有自己的PL实现，比如 Oracle 的 PL/SQL、SQL Server 的 T-SQL，而在 PG 中，提供的就是 PL/pgSQL</p>
<p>但是 PG 的 PL 支持多种语言，如下：</p>
<ul>
<li>PL/Java</li>
<li>PL/PHP</li>
<li>PL/Perl</li>
<li>PL/Python</li>
<li>PL/V8(JavaScript)</li>
</ul>
<h2 id="PostGIS"><a href="#PostGIS" class="headerlink" title="PostGIS"></a>PostGIS</h2><blockquote>
<p>官网：<a href="https://postgis.net/">https://postgis.net/</a></p>
</blockquote>
<h3 id="PostGIS介绍"><a href="#PostGIS介绍" class="headerlink" title="PostGIS介绍"></a>PostGIS介绍</h3><p><code>PostGIS</code> 是 PG 的一个空间对象扩展模块</p>
<p><code>PostGIS</code> 通过向 PG 添加对空间数据类型、空间索引和空间函数的支持，使其成为一个真正的大型空间数据库</p>
<p><code>PostGIS</code> 使 PG 目前成为开源空间信息软件领域性能最优的数据库</p>
<h3 id="PostGIS特性与功能"><a href="#PostGIS特性与功能" class="headerlink" title="PostGIS特性与功能"></a>PostGIS特性与功能</h3><ul>
<li><p><code>PostGIS</code> 支持所有的空间数据类型</p>
<p>这些类型包括：点（POINT）、线（LINESTRING）、多边形（POLYGON）、多点 （MULTIPOINT）、多线（MULTILINESTRING）、多多边形（MULTIPOLYGON）和集合对象集 （GEOMETRYCOLLECTION）等</p>
</li>
<li><p><code>PostGIS</code> 支持所有的对象表达方法</p>
<p>比如WKT和WKB。</p>
</li>
<li><p><code>PostGIS</code> 支持所有的数据存取和构造方法</p>
<p>如GeomFromText()、AsBinary()，以及GeometryN()等</p>
</li>
<li><p><code>PostGIS</code> 提供简单的空间分析函数</p>
<p>如Area和Length</p>
<p>同时也提供其他一些具有复杂分析功能的函数</p>
<p>比如Distance。</p>
</li>
<li><p><code>PostGIS</code> 提供了对于元数据的支持</p>
<p>如GEOMETRY_COLUMNS和SPATIAL_REF_SYS</p>
<p>同时，PostGIS也提供了相应的支持函数</p>
<p>如AddGeometryColumn和DropGeometryColumn。</p>
</li>
<li><p><code>PostGIS</code> 提供了一系列的二元谓词（如Contains、Within、Overlaps和Touches）用于检测空间对象之间的空间关系，同时返回布尔值来表征对象之间符合这个关系</p>
</li>
<li><p><code>PostGIS</code> 提供了空间操作符（如Union和Difference）用于空间数据操作</p>
<p>比如，Union操作符融合多边形之间的边界。两个交迭的多边形通过Union运算就会形成一个新的多边形，这个新的多边形的边界为两个多边形中最大边界</p>
</li>
<li><p>数据库坐标变换</p>
</li>
<li><p>球体长度运算</p>
</li>
<li><p>三维的几何类型</p>
</li>
<li><p>空间聚集函数</p>
</li>
<li><p>栅格数据类型</p>
</li>
<li><p>……</p>
</li>
</ul>
<p>PostGIS 的功能非常强大，PG 有目前的影响力 PostGIS 功不可没~</p>
<h1 id="PG的特殊能力"><a href="#PG的特殊能力" class="headerlink" title="PG的特殊能力"></a>PG的特殊能力</h1><h2 id="用户自定义对象"><a href="#用户自定义对象" class="headerlink" title="用户自定义对象"></a>用户自定义对象</h2><p>用户可以创建数据库中几乎所有对象的新类型，包括但不限于：</p>
<ul>
<li>自定义数据类型</li>
<li>自定义类型转换</li>
<li>自定义操作符</li>
<li>自定义函数，包括聚合函数和窗口函数</li>
<li>自定义索引</li>
<li>自定义过程语言</li>
</ul>
<h2 id="窗口函数"><a href="#窗口函数" class="headerlink" title="窗口函数"></a>窗口函数</h2><p>一个窗口函数在一系列与当前行有某种关联的表行上执行一种计算。这与一个聚集函数所完成的计算有可比之处。但是窗口函数并不会使多行被聚集成一个单独的输出行，这与通常的非窗口聚集函数不同。取而代之，行保留它们独立的标识。在这些现象背后，窗口函数可以访问的不仅仅是查询结果的当前行。</p>
<ol>
<li>可以访问与当前记录相关的多行记录；</li>
<li>不会使多行聚集成一行， 与聚集函数的区别；</li>
</ol>
<p>例如结合窗口函数得到总行数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">select * from testtable;</span><br><span class="line"> id | value</span><br><span class="line">----+-------</span><br><span class="line"> <span class="number">1</span> | <span class="number">1</span></span><br><span class="line"> <span class="number">2</span> | <span class="number">2</span></span><br><span class="line"> <span class="number">3</span> | <span class="number">3</span></span><br><span class="line"> <span class="number">4</span> | <span class="number">4</span></span><br><span class="line"> <span class="number">5</span> | <span class="number">5</span></span><br><span class="line"> <span class="number">6</span> | <span class="number">6</span></span><br><span class="line"> <span class="number">7</span> | <span class="number">7</span></span><br><span class="line"> <span class="number">8</span> | <span class="number">8</span></span><br><span class="line"> <span class="number">9</span> | <span class="number">9</span></span><br><span class="line"> <span class="number">10</span> | <span class="number">10</span></span><br><span class="line">(<span class="number">10</span> rows)</span><br><span class="line">select id,count(*) over () from testtable where id &lt; <span class="number">9</span> limit <span class="number">3</span>;</span><br><span class="line"> id | count</span><br><span class="line">----+-------</span><br><span class="line"> <span class="number">1</span> | <span class="number">8</span></span><br><span class="line"> <span class="number">2</span> | <span class="number">8</span></span><br><span class="line"> <span class="number">3</span> | <span class="number">8</span></span><br><span class="line">即，count over会在limit 和 offset之前计算，结果就是总行数。</span><br></pre></td></tr></table></figure>



<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2><blockquote>
<p>PG 还有许多特殊的能力，只有想不到的，没有做不到的</p>
</blockquote>
<ul>
<li><p>表继承</p>
</li>
<li><p>触发器不光可以拦截 DML 还可以拦截 DDL 语句</p>
</li>
<li><p>时序数据支持</p>
</li>
<li><p>分区表</p>
</li>
<li><p>外部数据源FDW，PG 中可以引用多种外部数据，包括MySQL、Oracle等主流关系型数据库，甚至还支持Redis、MongoDB等非关系型数据库</p>
</li>
<li><p>……</p>
</li>
</ul>
<h1 id="PG、MySQL对比"><a href="#PG、MySQL对比" class="headerlink" title="PG、MySQL对比"></a>PG、MySQL对比</h1><h2 id="数据表存储结构对比"><a href="#数据表存储结构对比" class="headerlink" title="数据表存储结构对比"></a>数据表存储结构对比</h2><p>堆表(heap table）和索引组织表（Index Oragnization Table，简称IOT)是两种数据表的存储结构</p>
<p><strong>PG 中的表是堆表。MySQL Innodb引擎中的表是索引组织表</strong></p>
<ul>
<li><p>堆表</p>
<p>堆表的特点就是索引和数据分开存储</p>
<p>表数据行在堆中存储，没有任何特定顺序，向一个全新的没有做过更新和删除的堆中插入一行时候，总是 append 到堆表文件的最后一页当中。因为不用考虑排序，所以插入速度会比较快。</p>
<p>索引存储在索引里，所有索引都是二级索引，或叫辅助索引。所以主键索引也是二级索引，没有完整记录，区别只有唯一或非唯一</p>
<p><strong>优点：</strong>写入速度快、辅助索引查询较快、全表扫描快</p>
<p><strong>缺点：</strong>磁盘空间消耗较大、主键查询较慢，需要先按主键索引找到数据的物理位置、</p>
</li>
<li><p>索引组织表</p>
<p>索引组织表特点是数据和主键索引一起存储</p>
<p>数据存储在聚簇索引中，或者说，数据按照主键的顺序来组织数据，两者合二为一。主键索引，叶子节点存放整行数据。其他索引称为辅助索引(二级索引），叶子节点存放键值和主键值</p>
<p><strong>优点：</strong>主键查询比较快、比较节约磁盘、更新效率更高</p>
<p><strong>缺点：</strong>二级索引查询慢，需要回表</p>
</li>
</ul>
<h2 id="MVCC对比"><a href="#MVCC对比" class="headerlink" title="MVCC对比"></a>MVCC对比</h2><p>MVCC的两种实现方法：</p>
<ol>
<li><p>当写入新数据时，把原有数据转移到一个单独的地方，如undo段中，其他人读数据时，会读取undo中的旧数据</p>
</li>
<li><p>当写入新数据时，原有数据不删除，而是把新数据插入，在不同版本的原有数据不需要时，垃圾回收器将回收这些过期的数据</p>
</li>
</ol>
<p>MySQL：</p>
<p>MySQL采用的就是第一种方式，详细不在说明</p>
<p>PG：</p>
<p>PG 采用的第二种方式，数据文件中存放着每一逻辑行的多个版本，问题随之而来，表空间会非常容易膨胀</p>
<p>为了解决表空间膨胀的问题，PG 采用 <a href="http://postgres.cn/docs/13/sql-vacuum.html">VACUUM</a> 方式，来回收历史数据，且需要定期手动进行 VACUUM</p>
<h2 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h2><p>任何系统都有它的性能极限，在高并发读写，负载逼近极限下，PG的性能指标仍可以维持双曲线甚至对数曲线，到顶峰之后不再下降，而 MySQL 明显出现一个波峰后下滑（5.5版本之后，在企业级版本中有个插件可以改善很多，不过需要付费）</p>
<h2 id="其他对比"><a href="#其他对比" class="headerlink" title="其他对比"></a>其他对比</h2><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">PG</th>
<th align="left">MySQL</th>
</tr>
</thead>
<tbody><tr>
<td align="left">口号性特点</td>
<td align="left">最先进的开源数据库</td>
<td align="left">最流行的开源数据库</td>
</tr>
<tr>
<td align="left">SQL编程能力</td>
<td align="left">强大的SQL能力，包括丰富的统计函数和统计分析，对BI 有很好的支持</td>
<td align="left">没有强大的统计功能支持</td>
</tr>
<tr>
<td align="left">数据类型</td>
<td align="left">丰富的数据类型支持，包括地理信息、几何图形、 json、数组等，json也可以建立索引</td>
<td align="left">在地理信息支持度上不如PG，不支持几何图形等数据 类型</td>
</tr>
<tr>
<td align="left">事务能力</td>
<td align="left">完整的ACID事务支持</td>
<td align="left">不是完整的支持ACID事务特性</td>
</tr>
<tr>
<td align="left">join</td>
<td align="left">支持nested-loop, sort-merge, hash三种类型</td>
<td align="left">只支持nested-loop</td>
</tr>
<tr>
<td align="left">Text类型</td>
<td align="left">没有长度限制，可以直接访问，可以索引，可以全文索 引</td>
<td align="left">有长度限制</td>
</tr>
<tr>
<td align="left">复杂查询</td>
<td align="left">支持窗口函数，支持递归，支持with语句</td>
<td align="left">不支持窗口函数、递归等</td>
</tr>
<tr>
<td align="left">索引</td>
<td align="left">多种索引类型，包括b-tree，hash，gin，gist等，可以 对模糊查询、正则表达式、地理信息系统等建立索引</td>
<td align="left">主要是b-tree索引</td>
</tr>
<tr>
<td align="left">数据复制</td>
<td align="left">同步，异步，半同步复制，以及基于日志逻辑复制，可以实现表级别的订阅和发布</td>
<td align="left">只支持异步复制</td>
</tr>
<tr>
<td align="left">查询优化器</td>
<td align="left">功能更强大，对子查询的支持更高效</td>
<td align="left">子查询效率不高</td>
</tr>
<tr>
<td align="left">7*24</td>
<td align="left">隔一段时间需要进行VACUUM</td>
<td align="left">适用7*24</td>
</tr>
<tr>
<td align="left">性能和适用场景</td>
<td align="left">复杂查询</td>
<td align="left">简单业务场景，更高的TPS</td>
</tr>
<tr>
<td align="left">大小写</td>
<td align="left">大小写敏感</td>
<td align="left">大小写不敏感</td>
</tr>
<tr>
<td align="left">行大小限制</td>
<td align="left">无限制</td>
<td align="left">65535</td>
</tr>
</tbody></table>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><p>官方文档</p>
<p><a href="https://www.postgresql.org/">https://www.postgresql.org/</a></p>
</li>
<li><p>PG中文社区</p>
<p><a href="http://www.postgres.cn/v2/home">http://www.postgres.cn/v2/home</a></p>
</li>
<li><p>PG官方客户端工具</p>
<p><a href="https://www.pgadmin.org/">https://www.pgadmin.org/</a></p>
</li>
<li><p>PG相关高质量博客</p>
<p><a href="https://postgres.fun/">https://postgres.fun/</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>DB</category>
      </categories>
      <tags>
        <tag>DB</tag>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring缓存</title>
    <url>/2017/11/16/Spring%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<blockquote>
<p>==<strong>原文链接：<a href="http://www.cnblogs.com/fashflying/p/6908028.html">http://www.cnblogs.com/fashflying/p/6908028.html</a></strong>==</p>
</blockquote>
<p>从3.1开始，Spring引入了对Cache的支持。其使用方法和原理都类似于Spring对事务管理的支持。Spring Cache是作用在方法上的，其核心思想是这样的：当我们在调用一个缓存方法时会把该方法参数和返回结果作为一个键值对存放在缓存中，等到下次利用同样的参数来调用该方法时将不再执行该方法，而是直接从缓存中获取结果进行返回。所以在使用Spring Cache的时候我们要保证我们缓存的方法对于相同的方法参数要有相同的返回结果。</p>
<p>使用Spring Cache需要我们做两方面的事：</p>
<ol>
<li><p>声明某些方法使用缓存</p>
</li>
<li><p>配置Spring对Cache的支持</p>
</li>
</ol>
<p>和Spring对事务管理的支持一样，Spring对Cache的支持也有基于注解和基于XML配置两种方式。下面我们先来看看基于注解的方式。</p>
<h3 id="1-基于注解的支持"><a href="#1-基于注解的支持" class="headerlink" title="1. 基于注解的支持"></a>1. 基于注解的支持</h3><p>Spring为我们提供了几个注解来支持Spring Cache。其核心主要是@Cacheable和@CacheEvict。使用@Cacheable标记的方法在执行后Spring Cache将缓存其返回结果，而使用@CacheEvict标记的方法会在方法执行前或者执行后移除Spring Cache中的某些元素。下面我们将来详细介绍一下Spring基于注解对Cache的支持所提供的几个注解。</p>
<h4 id="1-1-Cacheable"><a href="#1-1-Cacheable" class="headerlink" title="1.1 @Cacheable"></a>1.1 @Cacheable</h4><p>@Cacheable可以标记在一个方法上，也可以标记在一个类上。当标记在一个方法上时表示该方法是支持缓存的，当标记在一个类上时则表示该类所有的方法都是支持缓存的。对于一个支持缓存的方法，Spring会在其被调用后将其返回值缓存起来，以保证下次利用同样的参数来执行该方法时可以直接从缓存中获取结果，而不需要再次执行该方法。Spring在缓存方法的返回值时是以键值对进行缓存的，值就是方法的返回结果，至于键的话，Spring又支持两种策略，默认策略和自定义策略，这个稍后会进行说明。需要注意的是当一个支持缓存的方法在对象内部被调用时是不会触发缓存功能的。@Cacheable可以指定三个属性，value、key和condition。</p>
<h5 id="1-1-1-value属性指定Cache名称"><a href="#1-1-1-value属性指定Cache名称" class="headerlink" title="1.1.1 value属性指定Cache名称"></a>1.1.1 value属性指定Cache名称</h5><p>value属性是必须指定的，其表示当前方法的返回值是会被缓存在哪个Cache上的，对应Cache的名称。其可以是一个Cache也可以是多个Cache，当需要指定多个Cache时其是一个数组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Cacheable(&quot;cache1&quot;)&#x2F;&#x2F;Cache是发生在cache1上的</span><br><span class="line">public User find(Integer id) &#123;</span><br><span class="line">   returnnull;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Cacheable(&#123;&quot;cache1&quot;, &quot;cache2&quot;&#125;)&#x2F;&#x2F;Cache是发生在cache1和cache2上的</span><br><span class="line">public User find(Integer id) &#123;</span><br><span class="line">   returnnull;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-1-2-使用key属性自定义key"><a href="#1-1-2-使用key属性自定义key" class="headerlink" title="1.1.2 使用key属性自定义key"></a>1.1.2 使用key属性自定义key</h5><p>key属性是用来指定Spring缓存方法的返回结果时对应的key的。该属性支持SpringEL表达式。当我们没有指定该属性时，Spring将使用默认策略生成key。我们这里先来看看自定义策略，至于默认策略会在后文单独介绍。</p>
<p>自定义策略是指我们可以通过Spring的EL表达式来指定我们的key。这里的EL表达式可以使用方法参数及它们对应的属性。使用方法参数时我们可以直接使用“#参数名”或者“#p参数index”。下面是几个使用参数作为key的示例。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Cacheable(value&#x3D;&quot;users&quot;, key&#x3D;&quot;#id&quot;)</span><br><span class="line">public User find(Integer id) &#123;</span><br><span class="line">   returnnull;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Cacheable(value&#x3D;&quot;users&quot;, key&#x3D;&quot;#p0&quot;)</span><br><span class="line">public User find(Integer id) &#123;</span><br><span class="line">   returnnull;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">@Cacheable(value&#x3D;&quot;users&quot;, key&#x3D;&quot;#user.id&quot;)</span><br><span class="line">public User find(User user) &#123;</span><br><span class="line">   returnnull;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">@Cacheable(value&#x3D;&quot;users&quot;, key&#x3D;&quot;#p0.id&quot;)</span><br><span class="line">public User find(User user) &#123;</span><br><span class="line">   returnnull;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了上述使用方法参数作为key之外，Spring还为我们提供了一个root对象可以用来生成key。通过该root对象我们可以获取到以下信息。</p>
<table>
<thead>
<tr>
<th>属性名称</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>methodName</td>
<td>当前方法名</td>
<td>＃root.methodName</td>
</tr>
<tr>
<td>method</td>
<td>当前方法</td>
<td>#root.method.name</td>
</tr>
<tr>
<td>target</td>
<td>当前被调用的对象</td>
<td>#root.target</td>
</tr>
<tr>
<td>targetClass</td>
<td>当前被调用的对象的class</td>
<td>#root.targetClass</td>
</tr>
<tr>
<td>args</td>
<td>当前方法参数组成的数组</td>
<td>#root.args[0]</td>
</tr>
<tr>
<td>caches</td>
<td>当前被调用的方法使用的Cache</td>
<td>#root.caches[0].name</td>
</tr>
</tbody></table>
<p>当我们要使用root对象的属性作为key时我们也可以将“#root”省略，因为Spring默认使用的就是root对象的属性。如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Cacheable(value&#x3D;&#123;&quot;users&quot;, &quot;xxx&quot;&#125;, key&#x3D;&quot;caches[1].name&quot;)</span><br><span class="line">public User find(User user) &#123;</span><br><span class="line">   returnnull;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="1-1-3-condition属性指定发生的条件"><a href="#1-1-3-condition属性指定发生的条件" class="headerlink" title="1.1.3 condition属性指定发生的条件"></a>1.1.3 condition属性指定发生的条件</h5><p>有的时候我们可能并不希望缓存一个方法所有的返回结果。通过condition属性可以实现这一功能。condition属性默认为空，表示将缓存所有的调用情形。其值是通过SpringEL表达式来指定的，当为true时表示进行缓存处理；当为false时表示不进行缓存处理，即每次调用该方法时该方法都会执行一次。如下示例表示只有当user的id为偶数时才会进行缓存。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Cacheable(value&#x3D;&#123;&quot;users&quot;&#125;, key&#x3D;&quot;#user.id&quot;, condition&#x3D;&quot;#user.id%2&#x3D;&#x3D;0&quot;)</span><br><span class="line">public User find(User user) &#123;</span><br><span class="line">   System.out.println(&quot;find user by user &quot; + user);</span><br><span class="line">   return user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-2-CachePut"><a href="#1-2-CachePut" class="headerlink" title="1.2 @CachePut"></a>1.2 @CachePut</h4><p>在支持Spring Cache的环境下，对于使用@Cacheable标注的方法，Spring在每次执行前都会检查Cache中是否存在相同key的缓存元素，如果存在就不再执行该方法，而是直接从缓存中获取结果进行返回，否则才会执行并将返回结果存入指定的缓存中。@CachePut也可以声明一个方法支持缓存功能。与@Cacheable不同的是使用@CachePut标注的方法在执行前不会去检查缓存中是否存在之前执行过的结果，而是每次都会执行该方法，并将执行结果以键值对的形式存入指定的缓存中。</p>
<p> @CachePut也可以标注在类上和方法上。使用@CachePut时我们可以指定的属性跟@Cacheable是一样的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@CachePut(&quot;users&quot;)&#x2F;&#x2F;每次都会执行方法，并将结果存入指定的缓存中</span><br><span class="line">public User find(Integer id) &#123;</span><br><span class="line">   returnnull;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-3-CacheEvict"><a href="#1-3-CacheEvict" class="headerlink" title="1.3 @CacheEvict"></a>1.3 @CacheEvict</h4><p>@CacheEvict是用来标注在需要清除缓存元素的方法或类上的。当标记在一个类上时表示其中所有的方法的执行都会触发缓存的清除操作。@CacheEvict可以指定的属性有value、key、condition、allEntries和beforeInvocation。其中value、key和condition的语义与@Cacheable对应的属性类似。即value表示清除操作是发生在哪些Cache上的（对应Cache的名称）；key表示需要清除的是哪个key，如未指定则会使用默认策略生成的key；condition表示清除操作发生的条件。下面我们来介绍一下新出现的两个属性allEntries和beforeInvocation。</p>
<h5 id="1-3-1-allEntries属性"><a href="#1-3-1-allEntries属性" class="headerlink" title="1.3.1 allEntries属性"></a>1.3.1 allEntries属性</h5><p>allEntries是boolean类型，表示是否需要清除缓存中的所有元素。默认为false，表示不需要。当指定了allEntries为true时，Spring Cache将忽略指定的key。有的时候我们需要Cache一下清除所有的元素，这比一个一个清除元素更有效率。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@CacheEvict(value&#x3D;&quot;users&quot;, allEntries&#x3D;true)</span><br><span class="line">public void delete(Integer id) &#123;</span><br><span class="line">   System.out.println(&quot;delete user by id: &quot; + id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="1-3-2-beforeInvocation属性"><a href="#1-3-2-beforeInvocation属性" class="headerlink" title="1.3.2 beforeInvocation属性"></a>1.3.2 beforeInvocation属性</h5><p>清除操作默认是在对应方法成功执行之后触发的，即方法如果因为抛出异常而未能成功返回时也不会触发清除操作。使用beforeInvocation可以改变触发清除操作的时间，当我们指定该属性值为true时，Spring会在调用该方法之前清除缓存中的指定元素。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@CacheEvict(value&#x3D;&quot;users&quot;, beforeInvocation&#x3D;true)</span><br><span class="line">public void delete(Integer id) &#123;</span><br><span class="line">   System.out.println(&quot;delete user by id: &quot; + id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实除了使用@CacheEvict清除缓存元素外，当我们使用Ehcache作为实现时，我们也可以配置Ehcache自身的驱除策略，其是通过Ehcache的配置文件来指定的。由于Ehcache不是本文描述的重点，这里就不多赘述了，想了解更多关于Ehcache的信息，请查看我关于Ehcache的专栏。</p>
<h4 id="1-4-Caching"><a href="#1-4-Caching" class="headerlink" title="1.4 @Caching"></a>1.4 @Caching</h4><p>@Caching注解可以让我们在一个方法或者类上同时指定多个Spring Cache相关的注解。其拥有三个属性：cacheable、put和evict，分别用于指定@Cacheable、@CachePut和@CacheEvict。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Caching(cacheable &#x3D; @Cacheable(&quot;users&quot;), evict &#x3D; &#123; @CacheEvict(&quot;cache2&quot;),@CacheEvict(value &#x3D; &quot;cache3&quot;, allEntries &#x3D; true) &#125;)</span><br><span class="line">public User find(Integer id) &#123;</span><br><span class="line">   returnnull;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-5-使用自定义注解"><a href="#1-5-使用自定义注解" class="headerlink" title="1.5 使用自定义注解"></a>1.5 使用自定义注解</h4><p>Spring允许我们在配置可缓存的方法时使用自定义的注解，前提是自定义的注解上必须使用对应的注解进行标注。如我们有如下这么一个使用@Cacheable进行标注的自定义注解。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Cacheable(value&#x3D;&quot;users&quot;)</span><br><span class="line">public @interface MyCacheable &#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么在我们需要缓存的方法上使用@MyCacheable进行标注也可以达到同样的效果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@MyCacheable</span><br><span class="line">public User findById(Integer id) &#123;</span><br><span class="line">   System.out.println(&quot;find user by id: &quot; + id);</span><br><span class="line">   User user &#x3D; new User();</span><br><span class="line">   user.setId(id);</span><br><span class="line">   user.setName(&quot;Name&quot; + id);</span><br><span class="line">   return user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-配置Spring对Cache的支持"><a href="#2-配置Spring对Cache的支持" class="headerlink" title="2 配置Spring对Cache的支持"></a>2 配置Spring对Cache的支持</h3><h4 id="2-1-声明对Cache的支持"><a href="#2-1-声明对Cache的支持" class="headerlink" title="2.1 声明对Cache的支持"></a>2.1 声明对Cache的支持</h4><h5 id="2-1-1-基于注解"><a href="#2-1-1-基于注解" class="headerlink" title="2.1.1 基于注解"></a>2.1.1 基于注解</h5><p>配置Spring对基于注解的Cache的支持，首先我们需要在Spring的配置文件中引入cache命名空间，其次通过&lt;cache:annotation-driven /&gt;就可以启用Spring对基于注解的Cache的支持。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">   xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">   xmlns:cache&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;cache&quot;</span><br><span class="line">   xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">     http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans-3.0.xsd</span><br><span class="line">     http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;cache</span><br><span class="line">     http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;cache&#x2F;spring-cache.xsd&quot;&gt;</span><br><span class="line">   &lt;cache:annotation-driven&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>
<p><code>&lt;cache:annotation-driven/&gt;</code>有一个cache-manager属性用来指定当前所使用的CacheManager对应的bean的名称，默认是cacheManager，所以当我们的CacheManager的id为cacheManager时我们可以不指定该参数，否则就需要我们指定了。</p>
<p><code>&lt;cache:annotation-driven/&gt;</code>还可以指定一个mode属性，可选值有proxy和aspectj。默认是使用proxy。当mode为proxy时，只有缓存方法在外部被调用的时候Spring Cache才会发生作用，这也就意味着如果一个缓存方法在其声明对象内部被调用时Spring Cache是不会发生作用的。而mode为aspectj时就不会有这种问题。另外使用proxy时，只有public方法上的@Cacheable等标注才会起作用，如果需要非public方法上的方法也可以使用Spring Cache时把mode设置为aspectj。</p>
<p>此外，<code>&lt;cache:annotation-driven/&gt;</code>还可以指定一个proxy-target-class属性，表示是否要代理class，默认为false。我们前面提到的@Cacheable、@cacheEvict等也可以标注在接口上，这对于基于接口的代理来说是没有什么问题的，但是需要注意的是当我们设置proxy-target-class为true或者mode为aspectj时，是直接基于class进行操作的，定义在接口上的@Cacheable等Cache注解不会被识别到，那对应的Spring Cache也不会起作用了。</p>
<p>需要注意的是<a href="cache:annotation-driven/">cache:annotation-driven/</a>只会去寻找定义在同一个ApplicationContext下的@Cacheable等缓存注解。</p>
<h5 id="2-1-2-基于XML配置"><a href="#2-1-2-基于XML配置" class="headerlink" title="2.1.2 基于XML配置"></a>2.1.2 基于XML配置</h5><p>除了使用注解来声明对Cache的支持外，Spring还支持使用XML来声明对Cache的支持。这主要是通过类似于aop:advice的cache:advice来进行的。在cache命名空间下定义了一个cache:advice元素用来定义一个对于Cache的advice。其需要指定一个cache-manager属性，默认为cacheManager。cache:advice下面可以指定多个cache:caching元素，其有点类似于使用注解时的@Caching注解。cache:caching元素下又可以指定cache:cacheable、cache:cache-put和cache:cache-evict元素，它们类似于使用注解时的@Cacheable、@CachePut和@CacheEvict。下面来看一个示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;cache:advice id&#x3D;&quot;cacheAdvice&quot; cache-manager&#x3D;&quot;cacheManager&quot;&gt;</span><br><span class="line">   &lt;cache:caching cache&#x3D;&quot;users&quot;&gt;</span><br><span class="line">      &lt;cache:cacheable method&#x3D;&quot;findById&quot; key&#x3D;&quot;#p0&quot;&#x2F;&gt;</span><br><span class="line">      &lt;cache:cacheable method&#x3D;&quot;find&quot; key&#x3D;&quot;#user.id&quot;&#x2F;&gt;</span><br><span class="line">      &lt;cache:cache-evict method&#x3D;&quot;deleteAll&quot; all-entries&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">   &lt;&#x2F;cache:caching&gt;</span><br><span class="line">&lt;&#x2F;cache:advice&gt;</span><br></pre></td></tr></table></figure>

<p>上面配置定义了一个名为cacheAdvice的cache:advice，其中指定了将缓存findById方法和find方法到名为users的缓存中。这里的方法还可以使用通配符“<em>”，比如“find</em>”表示任何以“find”开始的方法。</p>
<p>有了cache:advice之后，我们还需要引入aop命名空间，然后通过aop:config指定定义好的cacheAdvice要应用在哪些pointcut上。如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;aop:config proxy-target-class&#x3D;&quot;false&quot;&gt;</span><br><span class="line">   &lt;aop:advisor advice-ref&#x3D;&quot;cacheAdvice&quot; pointcut&#x3D;&quot;execution(* com.xxx.UserService.*(..))&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;aop:config&gt;</span><br></pre></td></tr></table></figure>
<p>上面的配置表示在调用com.xxx.UserService中任意公共方法时将使用cacheAdvice对应的cache:advice来进行Spring Cache处理。更多关于Spring Aop的内容不在本文讨论范畴内。</p>
<h4 id="2-2-配置CacheManager"><a href="#2-2-配置CacheManager" class="headerlink" title="2.2 配置CacheManager"></a>2.2 配置CacheManager</h4><p>CacheManager是Spring定义的一个用来管理Cache的接口。Spring自身已经为我们提供了两种CacheManager的实现，一种是基于Java API的ConcurrentMap，另一种是基于第三方Cache实现——Ehcache，如果我们需要使用其它类型的缓存时，我们可以自己来实现Spring的CacheManager接口或AbstractCacheManager抽象类。下面分别来看看Spring已经为我们实现好了的两种CacheManager的配置示例。</p>
<h5 id="2-2-1-基于ConcurrentMap的配置"><a href="#2-2-1-基于ConcurrentMap的配置" class="headerlink" title="2.2.1 基于ConcurrentMap的配置"></a>2.2.1 基于ConcurrentMap的配置</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;cacheManager&quot;class&#x3D;&quot;org.springframework.cache.support.SimpleCacheManager&quot;&gt;</span><br><span class="line">     &lt;property name&#x3D;&quot;caches&quot;&gt;</span><br><span class="line">        &lt;set&gt;</span><br><span class="line">           &lt;bean class&#x3D;&quot;org.springframework.cache.concurrent.ConcurrentMapCacheFactoryBean&quot; p:name&#x3D;&quot;xxx&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;set&gt;</span><br><span class="line">     &lt;&#x2F;property&gt;</span><br><span class="line">  &lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<p>上面的配置使用的是一个SimpleCacheManager，其中包含一个名为“xxx”的ConcurrentMapCache。</p>
<h5 id="2-2-2-基于Ehcache的配置"><a href="#2-2-2-基于Ehcache的配置" class="headerlink" title="2.2.2  基于Ehcache的配置"></a>2.2.2  基于Ehcache的配置</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- Ehcache实现 --&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;cacheManager&quot; class&#x3D;&quot;org.springframework.cache.ehcache.EhCacheCacheManager&quot; p:cache-manager-ref&#x3D;&quot;ehcacheManager&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id&#x3D;&quot;ehcacheManager&quot; class&#x3D;&quot;org.springframework.cache.ehcache.EhCacheManagerFactoryBean&quot; p:config-location&#x3D;&quot;ehcache-spring.xml&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>上面的配置使用了一个Spring提供的EhCacheCacheManager来生成一个Spring的CacheManager，其接收一个Ehcache的CacheManager，因为真正用来存入缓存数据的还是Ehcache。Ehcache的CacheManager是通过Spring提供的EhCacheManagerFactoryBean来生成的，其可以通过指定ehcache的配置文件位置来生成一个Ehcache的CacheManager。若未指定则将按照Ehcache的默认规则取classpath根路径下的ehcache.xml文件，若该文件也不存在，则获取Ehcache对应jar包中的ehcache-failsafe.xml文件作为配置文件。更多关于Ehcache的内容这里就不多说了，它不属于本文讨论的内容，欲了解更多关于Ehcache的内容可以参考我之前发布的Ehcache系列文章，也可以参考官方文档等。</p>
<h3 id="3-键的生成策略"><a href="#3-键的生成策略" class="headerlink" title="3 键的生成策略"></a>3 键的生成策略</h3><p>键的生成策略有两种，一种是默认策略，一种是自定义策略。</p>
<h4 id="3-1-默认策略"><a href="#3-1-默认策略" class="headerlink" title="3.1 默认策略"></a>3.1 默认策略</h4><p>默认的key生成策略是通过KeyGenerator生成的，其默认策略如下：</p>
<ol>
<li><p>如果方法没有参数，则使用0作为key。</p>
</li>
<li><p>如果只有一个参数的话则使用该参数作为key。</p>
</li>
<li><p>如果参数多余一个的话则使用所有参数的hashCode作为key。</p>
</li>
</ol>
<p>如果我们需要指定自己的默认策略的话，那么我们可以实现自己的KeyGenerator，然后指定我们的Spring Cache使用的KeyGenerator为我们自己定义的KeyGenerator。</p>
<p>使用基于注解的配置时是通过cache:annotation-driven指定的.</p>
<p>   <code>&lt;cache:annotation-driven key-generator=&quot;userKeyGenerator&quot;/&gt;</code><br>   <code>&lt;bean id=&quot;userKeyGenerator&quot; class=&quot;com.xxx.cache.UserKeyGenerator&quot;/&gt;</code><br>而使用基于XML配置时是通过cache:advice来指定的。</p>
<p>   <code>&lt;cache:advice id=&quot;cacheAdvice&quot; cache-manager=&quot;cacheManager&quot; key-generator=&quot;userKeyGenerator&quot;&gt;</code><br>   <code>&lt;/cache:advice&gt;</code></p>
<p>需要注意的是此时我们所有的Cache使用的Key的默认生成策略都是同一个KeyGenerator。</p>
<h4 id="3-2-自定义策略"><a href="#3-2-自定义策略" class="headerlink" title="3.2 自定义策略"></a>3.2 自定义策略</h4><p>自定义策略是指我们可以通过Spring的EL表达式来指定我们的key。这里的EL表达式可以使用方法参数及它们对应的属性。使用方法参数时我们可以直接使用“#参数名”或者“#p参数index”。下面是几个使用参数作为key的示例。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Cacheable(value&#x3D;&quot;users&quot;, key&#x3D;&quot;#id&quot;)</span><br><span class="line">public User find(Integer id) &#123;</span><br><span class="line">   returnnull;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">@Cacheable(value&#x3D;&quot;users&quot;, key&#x3D;&quot;#p0&quot;)</span><br><span class="line">public User find(Integer id) &#123;</span><br><span class="line">   returnnull;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Cacheable(value&#x3D;&quot;users&quot;, key&#x3D;&quot;#user.id&quot;)</span><br><span class="line">public User find(User user) &#123;</span><br><span class="line">   returnnull;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">@Cacheable(value&#x3D;&quot;users&quot;, key&#x3D;&quot;#p0.id&quot;)</span><br><span class="line">public User find(User user) &#123;</span><br><span class="line">   returnnull;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了上述使用方法参数作为key之外，Spring还为我们提供了一个root对象可以用来生成key。通过该root对象我们可以获取到以下信息。</p>
<table>
<thead>
<tr>
<th>属性名称</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>methodName</td>
<td>当前方法名</td>
<td>＃root.methodName</td>
</tr>
<tr>
<td>method</td>
<td>当前方法</td>
<td>#root.method.name</td>
</tr>
<tr>
<td>target</td>
<td>当前被调用的对象</td>
<td>#root.target</td>
</tr>
<tr>
<td>targetClass</td>
<td>当前被调用的对象的class</td>
<td>#root.targetClass</td>
</tr>
<tr>
<td>args</td>
<td>当前方法参数组成的数组</td>
<td>#root.args[0]</td>
</tr>
<tr>
<td>caches</td>
<td>当前被调用的方法使用的Cache</td>
<td>#root.caches[0].name</td>
</tr>
</tbody></table>
<p>当我们要使用root对象的属性作为key时我们也可以将“#root”省略，因为Spring默认使用的就是root对象的属性。如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Cacheable(value&#x3D;&#123;&quot;users&quot;, &quot;xxx&quot;&#125;, key&#x3D;&quot;caches[1].name&quot;)</span><br><span class="line">public User find(User user) &#123;</span><br><span class="line">   returnnull;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-Spring单独使用Ehcache"><a href="#4-Spring单独使用Ehcache" class="headerlink" title="4 Spring单独使用Ehcache"></a>4 Spring单独使用Ehcache</h3><p>前面介绍的内容是Spring内置的对Cache的支持，其实我们也可以通过Spring自己单独的使用Ehcache的CacheManager或Ehcache对象。通过在Application Context中配置EhCacheManagerFactoryBean和EhCacheFactoryBean，我们就可以把对应的EhCache的CacheManager和Ehcache对象注入到其它的Spring bean对象中进行使用。</p>
<h4 id="4-1-EhCacheManagerFactoryBean"><a href="#4-1-EhCacheManagerFactoryBean" class="headerlink" title="4.1 EhCacheManagerFactoryBean"></a>4.1 EhCacheManagerFactoryBean</h4><p>EhCacheManagerFactoryBean是Spring内置的一个可以产生Ehcache的CacheManager对象的FactoryBean。其可以通过属性configLocation指定用于创建CacheManager的Ehcache配置文件的路径，通常是ehcache.xml文件的路径。如果没有指定configLocation，则将使用默认位置的配置文件创建CacheManager，这是属于Ehcache自身的逻辑，即如果在classpath根路径下存在ehcache.xml文件，则直接使用该文件作为Ehcache的配置文件，否则将使用ehcache-xxx.jar中的ehcache-failsafe.xml文件作为配置文件来创建Ehcache的CacheManager。此外，如果不希望创建的CacheManager使用默认的名称（在ehcache.xml文件中定义的，或者是由CacheManager内部定义的），则可以通过cacheManagerName属性进行指定。下面是一个配置EhCacheManagerFactoryBean的示例。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 定义CacheManager --&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;cacheManager&quot; class&#x3D;&quot;org.springframework.cache.ehcache.EhCacheManagerFactoryBean&quot;&gt;</span><br><span class="line">   &lt;!-- 指定配置文件的位置 --&gt;</span><br><span class="line">   &lt;property name&#x3D;&quot;configLocation&quot; value&#x3D;&quot;&#x2F;WEB-INF&#x2F;config&#x2F;ehcache.xml&quot;&#x2F;&gt;</span><br><span class="line">   &lt;!-- 指定新建的CacheManager的名称 --&gt;</span><br><span class="line">   &lt;property name&#x3D;&quot;cacheManagerName&quot; value&#x3D;&quot;cacheManagerName&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-EhCacheFactoryBean"><a href="#4-2-EhCacheFactoryBean" class="headerlink" title="4.2 EhCacheFactoryBean"></a>4.2 EhCacheFactoryBean</h4><p>EhCacheFactoryBean是用来产生Ehcache的Ehcache对象的FactoryBean。定义EhcacheFactoryBean时有两个很重要的属性我们可以来指定。一个是cacheManager属性，其可以指定将用来获取或创建Ehcache的CacheManager对象，若未指定则将通过CacheManager.create()获取或创建默认的CacheManager。另一个重要属性是cacheName，其表示当前EhCacheFactoryBean对应的是CacheManager中的哪一个Ehcache对象，若未指定默认使用beanName作为cacheName。若CacheManager中不存在对应cacheName的Ehcache对象，则将使用CacheManager创建一个名为cacheName的Cache对象。此外我们还可以通过EhCacheFactoryBean的timeToIdle、timeToLive等属性指定要创建的Cache的对应属性，注意这些属性只对CacheManager中不存在对应Cache时新建的Cache才起作用，对已经存在的Cache将不起作用，更多属性设置请参考Spring的API文档。此外还有几个属性是对不管是已经存在还是新创建的Cache都起作用的属性：statisticsEnabled、sampledStatisticsEnabled、disabled、blocking和cacheEventListeners，其中前四个默认都是false，最后一个表示为当前Cache指定CacheEventListener。下面是一个定义EhCacheFactoryBean的示例。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   &lt;!-- 定义CacheManager --&gt;</span><br><span class="line">   &lt;bean id&#x3D;&quot;cacheManager&quot; class&#x3D;&quot;org.springframework.cache.ehcache.EhCacheManagerFactoryBean&quot;&gt;</span><br><span class="line"></span><br><span class="line">      &lt;!-- 指定配置文件的位置 --&gt;</span><br><span class="line">      &lt;property name&#x3D;&quot;configLocation&quot; value&#x3D;&quot;&#x2F;WEB-INF&#x2F;config&#x2F;ehcache.xml&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">      &lt;!-- 指定新建的CacheManager的名称 --&gt;</span><br><span class="line">      &lt;property name&#x3D;&quot;cacheManagerName&quot; value&#x3D;&quot;cacheManagerName&quot;&#x2F;&gt;</span><br><span class="line">   &lt;&#x2F;bean&gt;</span><br><span class="line">&#96;&#96;&#96;&#96;</span><br></pre></td></tr></table></figure>
   <!-- 定义一个Ehcache -->
   <bean id="userCache" class="org.springframework.cache.ehcache.EhCacheFactoryBean">

<pre><code>  &lt;property name=&quot;cacheName&quot; value=&quot;user&quot;/&gt;
  &lt;property name=&quot;cacheManager&quot; ref=&quot;cacheManager&quot;/&gt;
</code></pre>
   </bean>
```

]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>Cache</tag>
        <tag>转载</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>常用方法论总结</title>
    <url>/2022/11/25/%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E8%AE%BA%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="5WHY"><a href="#5WHY" class="headerlink" title="5WHY"></a>5WHY</h2><blockquote>
<p>根因分析法</p>
</blockquote>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>根本原因分析的一种方法，所谓5why分析法，又称“5问法”，也就是对一个问题点连续以5个“为什么”来自问，以追究其根本原因。</p>
<p>虽为5个为什么，但使用时不限定只做“5次为什么的探讨”，主要是必须找到根本原因为止，有时可能只要3次，有时也许要10次，如古话所言：打破砂锅问到底。</p>
<p>5why法的关键所在：鼓励解决问题的人要努力避开主观或自负的假设和逻辑陷阱，从结果着手，沿着因果关系链条，顺藤摸瓜，直至找出原有问题的根本原因。</p>
<h3 id="实施"><a href="#实施" class="headerlink" title="实施"></a>实施</h3><p>5WHY从三个层面来实施：</p>
<p>一、为什么会发生？从“制造”的角度。</p>
<p>二、为什么没有发现？从“检验”的角度。</p>
<p>三、为什么没有从系统上预防事故？从“体系”或“流程”的角度。</p>
<p>每个层面连续5次或N次的询问，得出最终结论。只有以上三个层面的问题都探寻出来，才能发现根本问题，并寻求解决。</p>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>丰田汽车公司前副社长大野耐一曾举了一个例子来找出停机的真正原因</p>
<p>问题一：为什么机器停了？</p>
<p>答案一：因为机器超载，保险丝烧断了。</p>
<p>问题二：为什么机器会超载？</p>
<p>答案二：因为轴承的润滑不足。</p>
<p>问题三：为什么轴承会润滑不足？</p>
<p>答案三：因为润滑泵失灵了。</p>
<p>问题四：为什么润滑泵会失灵？</p>
<p>答案四：因为它的轮轴耗损了。</p>
<p>问题五：为什么润滑泵的轮轴会耗损？</p>
<p>答案五：因为杂质跑到里面去了。</p>
<p>经过连续五次不停地问“为什么”，才找到问题的真正原因和解决的方法，在润滑泵上加装滤网。</p>
<p>如果员工没有以这种追根究底的精神来发掘问题，他们很可能只是换根保险丝草草了事，真正的问题还是没有解决。</p>
<h2 id="5W1H-amp-5W2H"><a href="#5W1H-amp-5W2H" class="headerlink" title="5W1H&amp;5W2H"></a>5W1H&amp;5W2H</h2><blockquote>
<p>问题分析法</p>
</blockquote>
<h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>5W+1H：也称<strong>六何分析法</strong>，是一种思考方法，也是一种创造技法。是对选定的项目、工序或操作，都要从原因（何因Why）、对象（何事What）、地点（何地Where）、时间（何时When）、人员（何人Who）、方法（何法How）等六个方面提出问题进行思考。</p>
<p>1、<strong>对象 （What）</strong>——什么事情</p>
<p>公司生产什么产品？车间生产什么零配件？为什么要生产这5W1H分析法思路个产品？能不能生产别的？我到底应该生产什么？例如:如果这个产品不挣钱，换个利润高点的好不好？</p>
<p>2、<strong>场所 （Where）</strong>——什么地点</p>
<p>生产是在哪里干的？为什么偏偏要在这个地方干？换个地方行不行？到底应该在什么地方干？这是选择工作场所应该考虑的。</p>
<p>3、<strong>时间和程序 （When）</strong>——什么时候</p>
<p>例如这个工序或者零部件是在什么时候干的？为什么要在这个时候干？能不能在其他时候干？把后工序提到前面行不行？到底应该在什么时间干？</p>
<p>4、<strong>人员 （Who）</strong>——责任人</p>
<p>这个事情是谁在干？为什么要让他干？如果他既不负责任，脾气又很大，是不是可以换个人？有时候换一个人，整个生产就有起色了。</p>
<p>5、<strong>为什么（Why）</strong>——原因</p>
<p>为什么采用这个技术参数？为什么不能有变动？为什么不能使用？为什么变成红色？为什么要做成这个形状？为什么采用机器代替人力？为什么非做不可？</p>
<p>6、<strong>方式 （How）</strong>——如何</p>
<p>手段也就是工艺方法，例如，我们是怎样干的？为什么用这种方法来干？有没有别的方法可以干？到底应该怎么干？有时候方法一改，全局就会改变。</p>
<h3 id="5W2H"><a href="#5W2H" class="headerlink" title="5W2H"></a>5W2H</h3><p>5W2H分析法又叫<strong>七问分析法</strong>，是二战中美国陆军兵器修理部首创。简单、方便，易于理解、使用，富有启发意义，广泛用于企业管理和技术活动，对于决策执行性的活动措施也非常有帮助，也有助于弥补考虑问题的疏漏。增加一项How much</p>
<h2 id="SWOT"><a href="#SWOT" class="headerlink" title="SWOT"></a>SWOT</h2><blockquote>
<p>战略分析法</p>
</blockquote>
<h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p>SWOT分析法（也称TOWS分析法、道斯矩阵）即态势分析法，帮您清晰地把握全局，分析自己在资源方面的优势与劣势，把握环境提供的机会，防范可能存在的风险与威胁，对我们的成功有非常重要的意义</p>
<p>S （strengths）是优势、W （weaknesses）是劣势、O （opportunities）是机会、T （threats）是威胁</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>SWOT分析法是基于内外部竞争环境和竞争条件下的态势分析，就是将与研究对象密切相关的各种主要内部优势、劣势和外部的机会和威胁等，通过调查列举出来，并依照矩阵形式排列，然后用系统分析的思想，把各种因素相互匹配起来加以分析，从中得出一系列相应的结论，而结论通常带有一定的决策性。</p>
<p>运用这种方法，可以对研究对象所处的情景进行全面、系统、准确的研究，从而根据研究结果制定相应的发展战略、计划以及对策等。</p>
<h2 id="STAR"><a href="#STAR" class="headerlink" title="STAR"></a>STAR</h2><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h3><blockquote>
<p>STAR 法则最早用于面试，后来演变为 STARR，最后一个 R 是反思/Reflection</p>
<p>但 STARR 不仅适用于面试，也适用于工作小结，项目报告等各种场景</p>
</blockquote>
<p>所谓STAR原则，即Situation（情景）、Task（任务）、Action（行动）和Result（结果）四个英文单词的首字母组合，STARR则在STAR的基础上增加一个Reflection（反思）</p>
<h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><p>常见汇报场景使用。运用STAR法则进行工作的描述，可以让对方迅速了解你整个项目的前因后果，同时，也可以突出你在这个项目过程中的计划、组织、分析解决问题等方面的能力，这是一个十分优秀的汇报方式，需要在实际工作中好好理解运用。</p>
<p><strong>Situation</strong>：可以描述当时任务所处于的背景，任务类型是什么？为什么做这项任务？任务的紧迫程度怎么样？有多少人？项目排期多长等等，可以有效描述该任务的一些基本信息，使对方能够对项目有一个大致了解，方便继续进行沟通。</p>
<p><strong>Task：</strong>明确你在这个任务过程中所承担的职责，团队分工怎么样？你承担哪一块角色？可以使对方快速了解到你的工作内容。</p>
<p><strong>Action</strong>: 在具体的实施过程中，你采用了哪些手段，解决了哪些问题？可以使对方快速了解到你的业务能力以及工作难度等。</p>
<p><strong>Result：</strong>最终取得了什么样的结果。是你对该项任务的总结，这是一个可以量化的指标，用于度量工作成果。</p>
<h2 id="SMART"><a href="#SMART" class="headerlink" title="SMART"></a>SMART</h2><blockquote>
<p>目标管理</p>
</blockquote>
<h3 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h3><p>目标管理中需要遵循的原则，分别由Specific(具体的)、Measurable(可衡量)、Attainable（可达到）、Relevant（相关性）、Time－based（明确的截止期限）五个词组组成；</p>
<p>SMART通俗解读：把（什么对象），在（什么时间），通过（什么何种方法/手段），达到（什么状态）。</p>
<h3 id="具体介绍"><a href="#具体介绍" class="headerlink" title="具体介绍"></a>具体介绍</h3><ol>
<li>目标必须是具体的（Specific）stresses the need for a specific goal over and against a more general one. </li>
<li>目标必须是可以衡量的（Measurable）stresses the need for concrete criteria for measuring progress toward the attainment of the goal.</li>
<li>目标必须是可以达到的（Attainable）stresses the importance of goals that are realistic and attainable. </li>
<li>目标必须和总体目标具有相关性（Relevant）stresses the importance of choosing goals that matter. </li>
<li>目标必须具有明确的截止期限（Time-bound）stresses the importance of grounding goals within a time frame, giving them a target date.</li>
</ol>
<h3 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h3><p>SMART原则是一项制定合适目标的目标管理工具</p>
<p>人们在制定工作目标或者任务目标时，考虑一下目标与计划是不是SMART化的。只有具备SMART化的计划才是具有良好可实施性的，也才能指导保证计划得以实现</p>
<h2 id="PDCA"><a href="#PDCA" class="headerlink" title="PDCA"></a>PDCA</h2><blockquote>
<p>流程管理</p>
</blockquote>
<h3 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a>简介</h3><p><strong>PDCA（Plan-Do-Check-Adjust，中文为计划-执行-检核-调整）</strong>是一种循环式品质管理的过程，通过计划、执行、检核、调整四阶段来提高生产品质，改善生产过程，确保目标能够达成。这个概念是由美国现代产品品质控制的始祖爱德华兹·戴明（Edwards Deming）提出的，也被称为戴明环（Deming Wheel）。这个循环后续衍生了其他版本，如Plan-Do-Study-Act（PDSA）、Observation-Plan-Do-Study-Act（OPDCA）。</p>
<ul>
<li><strong>计划（Plan）：</strong>识别和理解当前的问题或机会，根据已有的信息和想法，建立一个明确的目标，并制定相关计划，确定必要的程序，进行组织分工，并确定好成功标准以及如何衡量执行结果与目标的差距。</li>
<li><strong>执行（Do）：</strong>先通过小规模试点进行安全测试，执行之前所制定的计划和程序，收集必要的信息来为下一步进行检验和调整提供依据。</li>
<li><strong>检核（Check）：</strong>研究上一步收集的信息，和预期的目标进行比较，通过列表或数据图显示出执行结果与预期结果的差距，并提出修改方案。</li>
<li><strong>调整（Adjust）：</strong>寻找适当的方法来缩减执行结果与计划目标之间的差距，有时会提出更详细的计划要求，来使得下一次重新执行循环时步骤更容易执行。</li>
</ul>
<h3 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h3><p>PDCA循环是一个持续改进模型，适用于日常工作和项目执行，生活中也适用</p>
<p>每一项工作，都是一个pdca循环，都需要计划、实施、检查结果，并进一步进行改进，同时进入下一个循环，只有在日积月累的渐进改善中，才可能会有质的飞跃，才可能取得完善每一项工作。</p>
<h2 id="SCQA"><a href="#SCQA" class="headerlink" title="SCQA"></a>SCQA</h2><blockquote>
<p>结构化表达</p>
</blockquote>
<h3 id="简介-6"><a href="#简介-6" class="headerlink" title="简介"></a>简介</h3><p>SCQA模型是一个“结构化表达”工具，是麦肯锡咨询顾问芭芭拉·明托在《金字塔原理》中提出的。</p>
<p><strong>S（Situation）情景</strong>——由大家都熟悉的情景、事实引入。<br><strong>C（Complication）冲突</strong>——实际情况往往和我们的要求有冲突。<br><strong>Q（Question）疑问</strong>——怎么办？<br><strong>A（Answer）回答</strong>——我们的解决方案是……</p>
<p>S情景陈述的通常是大家都熟悉的事，普遍认同的事，事情发生的背景。由此切入既不突兀又容易让大家产生共鸣，产生代入感，然后引出冲突C。Q是疑问，是根据前面的冲突从对方的角度提出他所关心的问题，最后A解答，是对Q的回答也是接下来我们要表达的中心思想。</p>
<p>整个结构其实是形成良好的沟通氛围，然后带出冲突和疑问，最后提供可行的解决方案。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li><p>常用于广告文案</p>
<p>得了灰指甲——陈述背景S<br>一个传染俩——在这个背景下发生了冲突C<br>问我怎么办？——站在对方的角度，提出疑惑Q<br>马上用亮甲！——给出解决方案A，这是文案要表达的重点</p>
<p>很多广告用的都是这个套路：用一个观众已经知道的“故事”来建立跟观众的链接（他们有这方面的背景经历和情感痛点），接着用冲突引起共鸣，最后用问题引出解决方案——快买我们的产品！</p>
</li>
<li><p>用于开场白、表达</p>
<table>
<thead>
<tr>
<th>用于开场白：</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>S：situation（情景）</td>
<td>从我行实行企业业务专营模式以来，业务实现了快速增长，</td>
</tr>
<tr>
<td>C：complication（冲突）</td>
<td>但小企业客户资金自身平衡问题成了制约业务进一步发展的瓶颈</td>
</tr>
<tr>
<td>Q：question（疑问）</td>
<td>如何实现我行企业业务的可持续发展？</td>
</tr>
<tr>
<td>A：answer（回答）</td>
<td>我部计划面向客户推介xxx方案，实现业务联动、多方共赢。</td>
</tr>
</tbody></table>
</li>
<li><p>用于自我反思</p>
<table>
<thead>
<tr>
<th>用于自我反思：</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>S：situation（情景）</td>
<td>我觉察到一天里只要我面对手机的时间偏长</td>
</tr>
<tr>
<td>C：complication（冲突）</td>
<td>就会出现效率底下，皮肤状态也不太好的情况。</td>
</tr>
<tr>
<td>Q：question（疑问）</td>
<td>手机就是一个黑洞，是一个浪费时间的坑，我该如何改变，避免掉入这样的坑呢？</td>
</tr>
<tr>
<td>A：answer（回答）</td>
<td>尽可能把零碎需要用手机的事情比如刷微博、逛淘宝、翻小红书、回微信、看闲鱼、查看手机短信……这类一打开手机就容易出现连锁反应不知不觉就浪费时间的APP都放在一个文件夹，然后集中在一个时间段查看，比如晚上泡脚的一小时里。其他时间有意识地觉察提醒自己不要翻看。</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="RACI"><a href="#RACI" class="headerlink" title="RACI"></a>RACI</h2><blockquote>
<p>事情管理</p>
</blockquote>
<h3 id="简介-7"><a href="#简介-7" class="headerlink" title="简介"></a>简介</h3><p>在快速发展的过程中，会不时的冒出一些之前没有明确界定的事情，往往产生一些看似大家都在负责，事实上无人负责的事情。RACI模型对快速发展的我们的最重要的启发是：每件事都要尽早确定谁负责，也就是确定R。</p>
<p>RACI的一个扩展，RASCI，是更加全面及适用我们的情况的。</p>
<p><strong>谁负责（R = Responsible）</strong>：负责执行任务的角色，具体负责操控项目、解决问题。</p>
<p><strong>谁批准（A = Accountable）</strong>：对任务负全责的角色，只有经其同意或签署之后，项目才能得以进行。</p>
<p><strong>谁支持（S = Support）</strong>：参与具体任务，协助R完成工作的角色。</p>
<p><strong>咨询谁（C = Consulted）</strong>：在任务实施前或中提供指定性意见的人员。</p>
<p><strong>告知谁（I = Informed）</strong>：及时被通知结果的人员，不必向其咨询、征求意见。</p>
<h2 id="房子图"><a href="#房子图" class="headerlink" title="房子图"></a>房子图</h2><blockquote>
<p>战略卡片</p>
</blockquote>
<h3 id="简介-8"><a href="#简介-8" class="headerlink" title="简介"></a>简介</h3><p>战略卡片的样式即老板们常用的”房子图“</p>
<p>所谓房子图：其实是一种思维工具，通过从上向下的拆解，以负责人的视角分析手中的业务，最终解决“如何做”的问题。</p>
<p>做好一件事最重要的原则是做正确的事，而做正确的事最有效的方法之一，是从负责人的视角，通过完整的信息梳理，想清楚这件事的规划——这便是房子图的作用。</p>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>战略卡片包含4层结构，遵循金字塔原理逐层展开</p>
<ul>
<li><p>第一层：使命与愿景</p>
<p>所谓使命，就是你为什么要做这件事，或者说为什么要做这个产品。</p>
<p>所谓愿景，就是你期望中这件事/这个产品的理想状态是什么。</p>
<p>使命能让我们在做规划的时候，知道手头这件事的价值。明白了价值，才能从源头上产生驱动力。愿景能让我们知道目的地在哪里，知道了目的地，才能规划出一个合理的路径。</p>
</li>
<li><p>第二层：价值</p>
<p>价值又分成3个子卡片：客户价值；我们的核心能力/成功要素；如何评估我们提供了这些价值。</p>
</li>
<li><p>第三层：同业竞争</p>
<p>对比企业外部市场环境和内部能力现状</p>
</li>
<li><p>第四层：战略规划</p>
<p>战略规划与3年目标：以更长远的角度，凝练我们接下来一段时间的努力方向及目标；</p>
<p>复盘及1年目标：复盘上一阶段的目标、结果、原因、经验，提出未来1年我们的短期目标是什么，兼顾定量和定性；兼顾自评与他评；兼顾效率与效果</p>
<p>关键策略：将实现未来1年的目标的策略和路径进行提炼和规划</p>
</li>
</ul>
<p><strong>HR房子图：</strong></p>
<p><img src="/images/image-20221121113913810.png" alt="image-20221121113913810"></p>
<h2 id="海恩法则"><a href="#海恩法则" class="headerlink" title="海恩法则"></a>海恩法则</h2><h3 id="简介-9"><a href="#简介-9" class="headerlink" title="简介"></a>简介</h3><p>海恩法则：<strong>任何不安全事故都是可以预防的</strong>。</p>
<p>海恩法则是德国飞机涡轮机的发明者德国人帕布斯•海恩提出的一个在航空界关于飞行安全的法则。海恩法则指出: 每一起严重事故的背后，必然有29次轻微事故和300起未遂先兆以及1000起事故隐患。</p>
<p>虽然这一分析会随着飞行器的安全系数增加和飞行器的总量变化而发生变化，但它确实说明了飞行安全与事故隐患之间的必然联系。当然，这种联系不仅仅表现在飞行领域，在其他领域也同样发生着潜在的作用。</p>
<p>按照海恩法则分析，当一起重大事故发生后，我们在处理事故本身的同时，还要及时对同类问题的“事故征兆”和“事故苗头”进行排查处理，以此防止类似问题的重复发生，及时解决再次发生重大事故的隐患，把问题解决在萌芽状态。</p>
<h3 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h3><p>海恩法则强调两点：</p>
<p>一是事故的发生是量的积累的结果</p>
<p>二是再好的技术，再完美的规章，在实际操作层面，也无法取代人自身的素质和责任心</p>
]]></content>
      <categories>
        <category>方法论</category>
      </categories>
      <tags>
        <tag>方法论</tag>
      </tags>
  </entry>
  <entry>
    <title>单元测试-Spock</title>
    <url>/2021/08/25/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-Spock/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>单元测试的重要性不言而喻，但在实际开发中单元测试往往都是缺失的，原因有很多，其中比较重要的一点是工期短、写单测耗时长</p>
<p>针对这种问题，为了提高写单测的效率，推荐 Spock 测试框架，改善单测体验、解放生产力~</p>
<h1 id="Spock是什么"><a href="#Spock是什么" class="headerlink" title="Spock是什么"></a>Spock是什么</h1><p>官网：<a href="https://spockframework.org/">https://spockframework.org/</a></p>
<h2 id="Spock简介"><a href="#Spock简介" class="headerlink" title="Spock简介"></a>Spock简介</h2><p>官方介绍：</p>
<blockquote>
<p>Spock is a testing and specification framework for Java and Groovy applications. What makes it stand out from the crowd is its beautiful and highly expressive specification language. Thanks to its JUnit runner, Spock is compatible with most IDEs, build tools, and continuous integration servers. Spock is inspired from JUnit, jMock, RSpec, Groovy, Scala, Vulcans, and other fascinating life forms.</p>
</blockquote>
<p>简单来说，<code>Spock</code> 是一个测试框架，有以下几个核心特点：</p>
<ul>
<li>可以应用于 <code>java</code> 或 <code>groovy</code> 应用的单元测试框架。</li>
<li>测试代码使用基于 <code>groovy</code> 语言扩展而成的规范说明语言（<code>specification language</code>）。</li>
<li>遵从 BDD（行为驱动开发）模式，有助于提升代码的质量。</li>
<li>通过 <code>junit runner</code> 调用测试，兼容绝大部分 <code>junit</code> 的运行场景（ide，构建工具，持续集成等）。</li>
<li>框架的设计思路参考了 <code>JUnit</code>，<code>jMock</code>，<code>RSpec</code>，<code>Groovy</code>，<code>Scala</code>，<code>Vulcans</code>……</li>
</ul>
<h2 id="与其他框架对比"><a href="#与其他框架对比" class="headerlink" title="与其他框架对比"></a>与其他框架对比</h2><p><img src="/images/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-Spock0.jpeg"></p>
<p><code>Spock</code> = 传统测试框架 + <code>Mock</code>+ <code>BDD</code> + 文档化</p>
<blockquote>
<p>代码规范化，结构层次清晰</p>
<p>简单易读、可维护性强</p>
<p>基于 <code>Groovy</code> 更快的写单侧</p>
<p>漂亮的参数化测试和异常测试<br><img src="/images/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-Spock1.png"></p>
</blockquote>
<p>缺点：</p>
<blockquote>
<p>偶尔有坑（版本不兼容等）</p>
<p>需要了解 <code>Groovy</code> 语言</p>
<p>与其它 java 测试框架风格相差比较大，需要适应</p>
</blockquote>
<p>而这些理由比起 <code>Spock</code> 提供的易于开发和维护的单元测试代码来说，是可以忽略的。。。</p>
<h1 id="Groovy"><a href="#Groovy" class="headerlink" title="Groovy"></a>Groovy</h1><p>使用 <code>Spock</code> 前先了解下 <code>Groovy</code></p>
<p>维基百科介绍：</p>
<blockquote>
<p>Groovy是Java平台上设计的面向对象编程语言。这门动态语言拥有类似Python、Ruby和Smalltalk中的一些特性，可以作为Java平台的脚本语言使用。</p>
</blockquote>
<p><code>Groovy</code> 的语法与 <code>Java</code> 非常相似，以至于多数的 <code>Java</code> 代码也是正确的 <code>Groovy</code> 代码。<code>Groovy</code> 代码动态的被编译器转换成 <code>Java</code> 字节码。由于其运行在JVM上的特性，<code>Groovy</code> 可以使用其他 <code>Java</code> 语言编写的库。</p>
<p>虽然需要了解 <code>Groovy</code>，但不用担心，<code>Groovy</code> 是一门比较轻量，学习门槛也比较低的语言，而且最重要的是 <code>Groovy</code> 支持 <code>Java</code> 语法，所以理论上使用纯 <code>Java</code> 写 <code>Groovy</code> 也是可以的~</p>
<p>而且熟悉使用 <code>Spock</code> 后，不仅提升了写单测的速度，还多学了一门脚本语言，两全其美~~</p>
<h2 id="Groovy-语法糖"><a href="#Groovy-语法糖" class="headerlink" title="Groovy 语法糖"></a>Groovy 语法糖</h2><p><img src="/images/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-Spock2.png"><br><img src="/images/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-Spock3.png"><br><img src="/images/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-Spock4.png"></p>
<blockquote>
<p>不用分号</p>
<p>可选择性使用 <code>return</code></p>
<p>默认采用 <code>public</code> 修饰符</p>
<p><code>==</code> 与 <code>equals</code></p>
</blockquote>
<p>更多语法参考推荐文档。。。</p>
<h2 id="Groovy-推荐文档"><a href="#Groovy-推荐文档" class="headerlink" title="Groovy 推荐文档"></a>Groovy 推荐文档</h2><p><a href="https://groovy-lang.org/documentation.html">https://groovy-lang.org/documentation.html</a></p>
<p><a href="https://sysgears.com/articles/groovy-differences-java/">https://sysgears.com/articles/groovy-differences-java/</a></p>
<p><a href="https://wiki.jikexueyuan.com/project/groovy-introduction/differences-with-java.html">https://wiki.jikexueyuan.com/project/groovy-introduction/differences-with-java.html</a></p>
<h1 id="使用Spock"><a href="#使用Spock" class="headerlink" title="使用Spock"></a>使用Spock</h1><blockquote>
<p>Spock Web Console</p>
<p><a href="https://meetspock.appspot.com/">https://meetspock.appspot.com/</a></p>
</blockquote>
<h2 id="使用姿势"><a href="#使用姿势" class="headerlink" title="使用姿势"></a>使用姿势</h2><ul>
<li><p>安装 IDE 插件</p>
<p><img src="/images/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-Spock5.png"></p>
</li>
<li><p>maven 引用</p>
<blockquote>
<p>建议使用 1.3-groovy-2.4 版本，其他版本可能与其他包有兼容问题</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.spockframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spock-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3-groovy-2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.spockframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spock-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3-groovy-2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>创建 Groovy 测试目录</p>
<p><img src="/images/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-Spock6.png"></p>
</li>
<li><p>编写测试代码</p>
<p><img src="/images/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-Spock7.png"></p>
</li>
</ul>
<p>创建测试类时可以这俩个，<code>Spock Specification</code> 会自动继承 <code>Specification</code>，<code>Groovy Class</code> 需要自己继承</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> spock.lang.Specification</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpockDemo</span> <span class="keyword">extends</span> <span class="title">Specification</span> </span>&#123; </span><br><span class="line">    def <span class="string">&quot;test&quot;</span>() &#123;</span><br><span class="line">        given: <span class="string">&quot;数据准备&quot;</span></span><br><span class="line">	      def list = []</span><br><span class="line">        </span><br><span class="line">        when: <span class="string">&quot;执行需要测试的代码&quot;</span></span><br><span class="line">        list.add(<span class="string">&quot;test&quot;</span>)</span><br><span class="line"></span><br><span class="line">        then: <span class="string">&quot;验证执行结果&quot;</span></span><br><span class="line">        !list.empty </span><br><span class="line">        stack.size() == <span class="number">1</span>   </span><br><span class="line">    &#125;   </span><br><span class="line">    </span><br><span class="line">    def <span class="string">&quot;测试&quot;</span>() &#123;</span><br><span class="line">        expect:</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="集成-Spring"><a href="#集成-Spring" class="headerlink" title="集成 Spring"></a>集成 Spring</h2><p>和 Junit 集成的方式一样</p>
<ul>
<li><p>Spring</p>
<p><code>@ContextConfiguration(locations = &quot;classpath:spring-context.xml&quot;)</code></p>
</li>
<li><p>SpringBoot</p>
<p><code>@SpringBootTest</code></p>
</li>
</ul>
<h2 id="Spock中的概念"><a href="#Spock中的概念" class="headerlink" title="Spock中的概念"></a>Spock中的概念</h2><ul>
<li><p>Specification</p>
<p>在 <code>Spock</code> 中，待测系统的行为是由规格(specification) 所定义的。在使用 <code>Spock</code> 框架编写测试时，测试类需要继承自 <code>Specification</code> 类。</p>
</li>
<li><p>模板方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def setup() &#123;&#125;          &#x2F;&#x2F; run before every feature method</span><br><span class="line">def cleanup() &#123;&#125;        &#x2F;&#x2F; run after every feature method</span><br><span class="line">def setupSpec() &#123;&#125;     &#x2F;&#x2F; run before the first feature method</span><br><span class="line">def cleanupSpec() &#123;&#125;   &#x2F;&#x2F; run after the last feature method</span><br></pre></td></tr></table></figure>

<p>和 Junit 对比：</p>
<table>
<thead>
<tr>
<th>Spock</th>
<th>Junit</th>
</tr>
</thead>
<tbody><tr>
<td>setup()</td>
<td>@Before</td>
</tr>
<tr>
<td>cleanup()</td>
<td>@After</td>
</tr>
<tr>
<td>setupSpec()</td>
<td>@BeforeClass</td>
</tr>
<tr>
<td>cleanupSpec()</td>
<td>@AfterClass</td>
</tr>
</tbody></table>
</li>
<li><p>Feature methods</p>
<p>就是测试类中的测试方法，方法名可以是中文</p>
</li>
<li><p>blocks</p>
<p>每个测试方法又被划分为不同的 <code>block</code>，不同的 <code>block</code> 处于测试执行的不同阶段，在测试运行时，各个 <code>block</code> 按照不同的顺序和规则被执行，如下图：</p>
<p><img src="/images/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-Spock8.png"></p>
<blockquote>
<p><code>Spock</code> 定义了多种标签，去描述代码“应该做什么”，“输入条件是什么”，“输出是否符合预期”，从语义层面规范了代码的编写</p>
</blockquote>
<p><strong>setup</strong>：也可以写成 <code>given</code>，在这个 <code>block</code> 中会放置与这个测试方法相关的初始化程序，可选</p>
<p><strong>given</strong>：输入条件（前置参数），一般会在这个 <code>block</code> 中定义局部变量，<code>mock</code> 等，可选</p>
<p><strong>when</strong>、<code>then</code>：<code>when</code> 与 <code>then</code> 需要搭配使用，一起出现，在 <code>when</code> 中执行待测试的函数，在 <code>then</code> 中判断是否符合预期</p>
<p><strong>expect</strong>：可以看做精简版的 when+then</p>
<p><strong>and</strong>：衔接上个标签，补充的作用</p>
<p><strong>cleanup</strong>：退出前做一些清理工作，如关闭资源等</p>
<p><strong>where</strong>：做测试时最复杂的事情之一就是准备测试数据，尤其是要测试边界条件、测试异常分支等，这些都需要在测试之前规划好数据。但是传统的测试框架很难轻松的制造数据，要么依赖反复调用，要么使用其他丑陋的方式；在 <code>Spock</code> 中 <code>where</code> 完美解决了这个问题，<code>where</code> 可以说是 <code>Spock</code> 的核心，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* where 有两种写法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpockDemo</span> <span class="keyword">extends</span> <span class="title">Specification</span> </span>&#123;</span><br><span class="line">    def <span class="string">&quot;max&quot;</span>() &#123;</span><br><span class="line">        expect:</span><br><span class="line">        Math.max(a, b) == c</span><br><span class="line"></span><br><span class="line">        where: <span class="string">&quot;多个列使用 | 单竖线隔开，|| 双竖线区分输入和输出变量，即左边是输入值，右边是输出值&quot;</span></span><br><span class="line">        a | b || c</span><br><span class="line">        <span class="number">3</span> | <span class="number">5</span> || <span class="number">5</span></span><br><span class="line">        <span class="number">7</span> | <span class="number">0</span> || <span class="number">7</span></span><br><span class="line">        <span class="number">0</span> | <span class="number">0</span> || <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpockDemo</span> <span class="keyword">extends</span> <span class="title">Specification</span> </span>&#123;</span><br><span class="line">    def <span class="string">&quot;max&quot;</span>() &#123;</span><br><span class="line">        expect:</span><br><span class="line">        Math.max(a, b) == c</span><br><span class="line"></span><br><span class="line">        where:</span><br><span class="line">        a &lt;&lt; [<span class="number">3</span>, <span class="number">7</span>, <span class="number">0</span>]</span><br><span class="line">        b &lt;&lt; [<span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">        c &lt;&lt; [<span class="number">5</span>, <span class="number">7</span>, <span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><p>在 <code>then</code> 或 <code>expect</code> 中会默认 <code>assert</code> 所有返回值是 <code>boolean</code> 型的语句，所以在 <code>then</code> 和 <code>expect</code> 语句块中不需要写 <code>assert</code></p>
<p>如果要在其它地方增加断言，需要显式增加 <code>assert</code> 关键字，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  stack = <span class="keyword">new</span> Stack()</span><br><span class="line">  <span class="keyword">assert</span> stack.empty</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="with"><a href="#with" class="headerlink" title="with"></a>with</h3><p><code>with</code> 语句可以验证对象内部的多个属性是否符合预期值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">expect:</span><br><span class="line">with(response) &#123;</span><br><span class="line">  code == <span class="number">0</span></span><br><span class="line">  message == <span class="string">&quot;成功&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="异常断言"><a href="#异常断言" class="headerlink" title="异常断言"></a>异常断言</h3><p>验证有没有抛出异常，可以用 <code>thrown()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">def <span class="string">&quot;test&quot;</span>() &#123;</span><br><span class="line">  given:</span><br><span class="line">  def str = <span class="keyword">null</span></span><br><span class="line"></span><br><span class="line">  when:</span><br><span class="line">  str.add(<span class="string">&quot;test&quot;</span>)</span><br><span class="line"></span><br><span class="line">  then:</span><br><span class="line">  thrown(NullPointerException)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>要验证没有抛出某种异常，可以用 <code>notThrown()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">def <span class="string">&quot;test&quot;</span>() &#123;</span><br><span class="line">  given:</span><br><span class="line">  def str = []</span><br><span class="line"></span><br><span class="line">  when:</span><br><span class="line">  str.add(<span class="string">&quot;test&quot;</span>)</span><br><span class="line"></span><br><span class="line">  then:</span><br><span class="line">  notThrown(NullPointerException)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Annotation"><a href="#Annotation" class="headerlink" title="Annotation"></a>Annotation</h2><table>
<thead>
<tr>
<th>注解</th>
<th>用途</th>
<th>样例</th>
</tr>
</thead>
<tbody><tr>
<td>Shared</td>
<td>在多个测试间共享变量</td>
<td>@Shared def h2 = new H2Database()</td>
</tr>
<tr>
<td>AutoCleanUp</td>
<td>测试结束后回收资源，不管是否发生异常等</td>
<td>@AutoCleanup(“shutdown”) def executor = new Executor()</td>
</tr>
<tr>
<td>Ignore</td>
<td>忽略这个测试</td>
<td></td>
</tr>
<tr>
<td>IgnoreIf</td>
<td>忽略满足条件的测试</td>
<td>@IgnoreIf(os.isWindows())</td>
</tr>
<tr>
<td>IgnoreRest</td>
<td>只运行这个测试</td>
<td></td>
</tr>
<tr>
<td>Requries</td>
<td>满足设定的条件才运行这个测试</td>
<td>@Requires({env.containsKey(“HASH_KEY_TO_AUTHENTICATE”)})</td>
</tr>
<tr>
<td>Unroll</td>
<td>配合数据表的时候，每行运行一个测试</td>
<td></td>
</tr>
<tr>
<td>FailsWith</td>
<td>运行测试必然抛出某个异常</td>
<td></td>
</tr>
<tr>
<td>Issue</td>
<td>指明这个测试对应某个issue</td>
<td>@Issue(“<a href="http://redmine.example.com/issues/2554&quot;">http://redmine.example.com/issues/2554&quot;</a>)</td>
</tr>
<tr>
<td>Timeout</td>
<td>如果运行时间超过某个阈值，则判定为失败</td>
<td>@Timeout(value = 5000, unit = TimeUnit.MILLISECONDS)</td>
</tr>
<tr>
<td>Title</td>
<td>设定一个更容易理解的标题名</td>
<td>@Title(”测试在》繁忙情况下》发红包”)</td>
</tr>
</tbody></table>
<h1 id="Mock"><a href="#Mock" class="headerlink" title="Mock"></a>Mock</h1><blockquote>
<p><code>Spock</code> 自带 <code>Mock</code> 功能，使用简单方便，同时也支持扩展第三方 <code>Mock</code> 框架，比如 <code>PowerMock</code></p>
</blockquote>
<h2 id="SpockMock"><a href="#SpockMock" class="headerlink" title="SpockMock"></a>SpockMock</h2><h3 id="Mock-1"><a href="#Mock-1" class="headerlink" title="Mock"></a>Mock</h3><p>创建一个假对象，验证是否执行了某些操作(在 <code>then</code> 或 <code>expect</code> 语句块中)</p>
<ul>
<li><p>创建一个 <code>Mock</code> 对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PublisherSpec</span> <span class="keyword">extends</span> <span class="title">Specification</span> </span>&#123;</span><br><span class="line">    Publisher publisher = <span class="keyword">new</span> Publisher()</span><br><span class="line">    <span class="comment">// def subscriber = Mock(Subscriber)</span></span><br><span class="line">    Subscriber subscriber = Mock()</span><br><span class="line">    <span class="comment">// def subscriber2 = Mock(Subscriber)</span></span><br><span class="line">    Subscriber subscriber2 = Mock()</span><br><span class="line"></span><br><span class="line">    <span class="function">def <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        publisher.subscribers.add(subscriber)</span><br><span class="line">        publisher.subscribers.add(subscriber2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>交互验证</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">def <span class="string">&quot;should send messages to all subscribers&quot;</span>() &#123;</span><br><span class="line">    when:</span><br><span class="line">    publisher.send(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"></span><br><span class="line">    then:</span><br><span class="line">    <span class="number">1</span> * subscriber.receive(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">    <span class="number">1</span> * subscriber2.receive(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 publisher 调用 send 时，两个 subscriber 都应该被调用一次 receive(“hello”)</p>
</li>
<li><p>示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> * subscriber.receive(<span class="string">&quot;hello&quot;</span>)      <span class="comment">// exactly one call</span></span><br><span class="line"><span class="number">0</span> * subscriber.receive(<span class="string">&quot;hello&quot;</span>)      <span class="comment">// zero calls</span></span><br><span class="line">(<span class="number">1.</span><span class="number">.3</span>) * subscriber.receive(<span class="string">&quot;hello&quot;</span>) <span class="comment">// between one and three calls (inclusive)</span></span><br><span class="line">(<span class="number">1.</span>._) * subscriber.receive(<span class="string">&quot;hello&quot;</span>) <span class="comment">// at least one call</span></span><br><span class="line">(_.<span class="number">.3</span>) * subscriber.receive(<span class="string">&quot;hello&quot;</span>) <span class="comment">// at most three calls</span></span><br><span class="line">_ * subscriber.receive(<span class="string">&quot;hello&quot;</span>)      <span class="comment">// any number of calls, including zero</span></span><br><span class="line"><span class="number">1</span> * subscriber.receive(<span class="string">&quot;hello&quot;</span>)     <span class="comment">// an argument that is equal to the String &quot;hello&quot;</span></span><br><span class="line"><span class="number">1</span> * subscriber.receive(!<span class="string">&quot;hello&quot;</span>)    <span class="comment">// an argument that is unequal to the String &quot;hello&quot;</span></span><br><span class="line"><span class="number">1</span> * subscriber.receive()            <span class="comment">// the empty argument list (would never match in our example)</span></span><br><span class="line"><span class="number">1</span> * subscriber.receive(_)           <span class="comment">// any single argument (including null)</span></span><br><span class="line"><span class="number">1</span> * subscriber.receive(*_)          <span class="comment">// any argument list (including the empty argument list)</span></span><br><span class="line"><span class="number">1</span> * subscriber.receive(!<span class="keyword">null</span>)       <span class="comment">// any non-null argument</span></span><br><span class="line"><span class="number">1</span> * subscriber.receive(_ as String) <span class="comment">// any non-null argument that is-a String</span></span><br><span class="line"><span class="number">1</span> * subscriber.receive(&#123; it.size() &gt; <span class="number">3</span> &#125;) <span class="comment">// an argument that satisfies the given predicate</span></span><br><span class="line">                                          <span class="comment">// (here: message length is greater than 3)</span></span><br><span class="line"><span class="number">1</span> * subscriber._(*_)     <span class="comment">// any method on subscriber, with any argument list</span></span><br><span class="line"><span class="number">1</span> * subscriber._         <span class="comment">// shortcut for and preferred over the above</span></span><br><span class="line"><span class="number">1</span> * _._                  <span class="comment">// any method call on any mock object</span></span><br><span class="line"><span class="number">1</span> * _                    <span class="comment">// shortcut for and preferred over the above</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Stubbing"><a href="#Stubbing" class="headerlink" title="Stubbing"></a>Stubbing</h3><p>调用 <code>Mock</code> 对象的某个方法时返回特定的值</p>
<ul>
<li><p>调用返回指定值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">subscriber.receive(_) &gt;&gt; <span class="string">&quot;ok&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p>调用多次返回不同的值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">subscriber.receive(_) &gt;&gt;&gt; [<span class="string">&quot;ok&quot;</span>, <span class="string">&quot;error&quot;</span>, <span class="string">&quot;error&quot;</span>, <span class="string">&quot;ok&quot;</span>]</span><br><span class="line">subscriber.receive(_) &gt;&gt; <span class="string">&quot;ok&quot;</span> &gt;&gt; <span class="string">&quot;error&quot;</span> &gt;&gt; <span class="string">&quot;error&quot;</span> &gt;&gt; <span class="string">&quot;ok&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p>希望抛出异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">subscriber.receive(_) &gt;&gt; &#123; <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">&quot;ouch&quot;</span>) &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Mock、Stubbing结合"><a href="#Mock、Stubbing结合" class="headerlink" title="Mock、Stubbing结合"></a>Mock、Stubbing结合</h3><p>如果既要判断某个 <code>mock</code> 对象的交互，又希望它返回值的话，可以结合 <code>mock</code> 和 <code>stub</code>，可以这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">then:</span><br><span class="line"><span class="number">1</span> * subscriber.receive(<span class="string">&quot;message1&quot;</span>) &gt;&gt; <span class="string">&quot;ok&quot;</span></span><br><span class="line"><span class="number">1</span> * subscriber.receive(<span class="string">&quot;message2&quot;</span>) &gt;&gt; <span class="string">&quot;fail&quot;</span></span><br></pre></td></tr></table></figure>

<p>一般使用 <code>Spock</code> 自带的 <code>Mock</code> 就够了，但是 <code>Spock</code> 的 <code>Mock</code> 也有着常见缺陷，既不能 <code>Mock</code> 私有方法和静态方法</p>
<p>针对这种情况，业界之前常见的是使用 <code>PowerMock</code> 来 <code>Mock</code>，但是 <code>PowerMock</code> 上手难度较高、且使用复杂</p>
<p>相比 <code>Spock</code> + <code>PowerMock</code>，推荐 <code>Spock</code> + <code>TestableMock</code> 来 <code>Mock</code>，快速上手、使用简单</p>
<h2 id="TestableMock"><a href="#TestableMock" class="headerlink" title="TestableMock"></a>TestableMock</h2><p><code>TestableMock</code>，阿里新一代测试工具，一款特立独行的轻量Mock工具。</p>
<p>官网：<a href="https://alibaba.github.io/testable-mock/#/">https://alibaba.github.io/testable-mock/#/</a></p>
<p>常见 Mock 工具对比：</p>
<table>
<thead>
<tr>
<th>工具</th>
<th>原理</th>
<th>最小Mock单元</th>
<th>对被Mock方法的限制</th>
<th>上手难度</th>
<th>IDE支持</th>
</tr>
</thead>
<tbody><tr>
<td>Mockito</td>
<td>动态代理</td>
<td>类</td>
<td>不能Mock私有/静态和构造方法</td>
<td>较容易</td>
<td>很好</td>
</tr>
<tr>
<td>Spock</td>
<td>动态代理</td>
<td>类</td>
<td>不能Mock私有/静态和构造方法</td>
<td>较复杂</td>
<td>一般</td>
</tr>
<tr>
<td>PowerMock</td>
<td>自定义类加载器</td>
<td>类</td>
<td>任何方法皆可</td>
<td>较复杂</td>
<td>较好</td>
</tr>
<tr>
<td>JMockit</td>
<td>运行时字节码修改</td>
<td>类</td>
<td>不能Mock构造方法(new操作符)</td>
<td>较复杂</td>
<td>一般</td>
</tr>
<tr>
<td>TestableMock</td>
<td>运行时字节码修改</td>
<td>方法</td>
<td>任何方法皆可</td>
<td>很容易</td>
<td>一般</td>
</tr>
</tbody></table>
<p>TestableMock 功能：</p>
<ul>
<li><a href="https://alibaba.github.io/testable-mock/#/zh-cn/doc/use-mock">快速Mock任意调用</a>：使被测类的任意方法调用快速替换为Mock方法，实现”指哪换哪”，解决传统Mock工具使用繁琐的问题</li>
<li><a href="https://alibaba.github.io/testable-mock/#/zh-cn/doc/private-accessor">访问被测类私有成员</a>：使单元测试能直接调用和访问被测类的私有成员，解决私有成员初始化和私有方法测试的问题</li>
<li><a href="https://alibaba.github.io/testable-mock/#/zh-cn/doc/omni-constructor">快速构造参数对象</a>：生成任意复杂嵌套的对象实例，并简化其内部成员赋值方式，解决被测方法参数初始化代码冗长的问题</li>
<li><a href="https://alibaba.github.io/testable-mock/#/zh-cn/doc/test-void-method">辅助测试void方法</a>：利用Mock校验器对方法的内部逻辑进行检查，解决无返回值方法难以实施单元测试的问题</li>
</ul>
<p>不足：</p>
<p>当前 <code>TestableMock</code> 的主要不足在于，编写 <code>Mock</code> 方法时 IDE 无法即时提示方法参数是否正确匹配。若发现匹配效果不符合预期，需要通过<a href="https://alibaba.github.io/testable-mock/#/zh-cn/doc/troubleshooting">自助问题排查</a>文档提供的方法在运行期进行校验</p>
<h1 id="推荐文档"><a href="#推荐文档" class="headerlink" title="推荐文档"></a>推荐文档</h1><ul>
<li><p>官方文档<br><a href="https://spockframework.org/spock/docs/2.0/all_in_one.html">https://spockframework.org/spock/docs/2.0/all_in_one.html</a></p>
</li>
<li><p>美团技术博客<br><a href="https://tech.meituan.com/2021/08/06/spock-practice-in-meituan.html">https://tech.meituan.com/2021/08/06/spock-practice-in-meituan.html</a></p>
</li>
<li><p>其他技术博客<br><a href="https://javakk.com/category/spock">https://javakk.com/category/spock</a></p>
</li>
<li><p>Java Testing with Spock<br><a href="https://github.com/kkapelon/java-testing-with-spock">https://github.com/kkapelon/java-testing-with-spock</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-Agent</title>
    <url>/2022/11/12/Java-Agent/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote>
<p>Java Agent 直译过来叫做 Java 代理，但更多称叫做 Java 探针</p>
</blockquote>
<p>Java Agent是一种特殊的Java程序（Jar文件），与普通Java程序通过main方法启动不同，agent并不是一个可以单独启动的程序，而必须依附在一个Java应用程序（JVM）上，与它运行在同一个进程中，通过<code>Instrumentation API</code>与虚拟机交互</p>
<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="Instrumentation"><a href="#Instrumentation" class="headerlink" title="Instrumentation"></a>Instrumentation</h3><p><code>Instrumentation</code>是Java提供的一个来自JVM的接口，该接口提供了一系列查看和操作Java类定义的方法，例如修改类的字节码、向<code>classLoader</code>的<code>classpath</code>下加入jar文件等。使得开发者可以通过Java语言来操作和监控JVM内部的一些状态，进而实现Java程序的监控分析，甚至实现一些特殊功能（如AOP、热部署）</p>
<p>主流的JVM都提供了<code>Instrumentation</code>的实现，但是鉴于<code>Instrumentation</code>的特殊功能，并不适合直接提供在JDK的runtime里，而更适合出现在Java程序的外层，以上帝视角在合适的时机出现。因此如果想使用<code>Instrumentation</code>功能，<strong>「拿到Instrumentation实例，我们必须通过Java agent」</strong>，<code>Instrumentation</code>常用方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Instrumentation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//增加一个Class 文件的转换器，转换器用于改变 Class 二进制流的数据，参数 canRetransform 设置是否允许重新转换。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addTransformer</span><span class="params">(ClassFileTransformer transformer, <span class="keyword">boolean</span> canRetransform)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在类加载之前，重新定义 Class 文件，ClassDefinition 表示对一个类新的定义，</span></span><br><span class="line">    <span class="comment">//如果在类加载之后，需要使用 retransformClasses 方法重新定义。addTransformer方法配置之后，后续的类加载都会被Transformer拦截。</span></span><br><span class="line">    <span class="comment">//对于已经加载过的类，可以执行retransformClasses来重新触发这个Transformer的拦截。类加载的字节码被修改后，除非再次被retransform，否则不会恢复。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addTransformer</span><span class="params">(ClassFileTransformer transformer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除一个类转换器</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">removeTransformer</span><span class="params">(ClassFileTransformer transformer)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//是否允许对class retransform</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isRetransformClassesSupported</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在类加载之后，重新定义 Class。这个很重要，该方法是1.6 之后加入的，事实上，该方法是 update 了一个类。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">retransformClasses</span><span class="params">(Class&lt;?&gt;... classes)</span> <span class="keyword">throws</span> UnmodifiableClassException</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//是否允许对class重新定义</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isRedefineClassesSupported</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//此方法用于替换类的定义，而不引用现有的类文件字节，就像从源代码重新编译以进行修复和继续调试时所做的那样。</span></span><br><span class="line">    <span class="comment">//在要转换现有类文件字节的地方（例如在字节码插装中），应该使用retransformClasses。</span></span><br><span class="line">    <span class="comment">//该方法可以修改方法体、常量池和属性值，但不能新增、删除、重命名属性或方法，也不能修改方法的签名</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">redefineClasses</span><span class="params">(ClassDefinition... definitions)</span> <span class="keyword">throws</span>  ClassNotFoundException, UnmodifiableClassException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取已经被JVM加载的class，有className可能重复（可能存在多个classloader）</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span></span><br><span class="line">    Class[] getAllLoadedClasses();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中最常用的方法就是<code>addTransformer(ClassFileTransformer transformer)</code>了，这个方法可以在类加载时做拦截，对输入的类的字节码进行修改，其参数是一个<code>ClassFileTransformer</code>接口，定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 传入参数表示一个即将被加载的类，包括了classloader，classname和字节码byte[]</span></span><br><span class="line"><span class="comment"> * 返回值为需要被修改后的字节码byte[]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">byte</span>[] transform( ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, <span class="keyword">byte</span>[] classfileBuffer) <span class="keyword">throws</span> IllegalClassFormatException;</span><br></pre></td></tr></table></figure>

<p><code>addTransformer</code>方法配置之后，后续的类加载都会被<code>Transformer</code>拦截。对于已经加载过的类，可以执行<code>retransformClasses</code>来重新触发这个<code>Transformer</code>的拦截。类加载的字节码被修改后，除非再次被<code>retransform</code>，否则不会恢复</p>
<h3 id="Attach"><a href="#Attach" class="headerlink" title="Attach"></a>Attach</h3><p><code>Attach API</code>其实是跨JVM进程通讯的工具，能够将某种指令从一个JVM进程发送给另一个JVM进程</p>
<p><code>Attach</code>机制可以对目标进程收集很多信息，如内存<code>dump</code>，线程<code>dump</code>，类信息统计(比如加载的类及大小以及实例个数等)，动态加载agent，动态设置vm flag，打印vm flag，获取系统属性等等</p>
<h2 id="Java-Agent结构"><a href="#Java-Agent结构" class="headerlink" title="Java Agent结构"></a>Java Agent结构</h2><p>Java Agent 最终以 jar 包的形式存在。主要包含两个部分，一部分是实现代码，一部分是配置文件。配置文件放在 META-INF 目录下，文件名为 <code>MANIFEST.MF</code> </p>
<p>代码入口是<code>premain</code>或<code>agentmain</code>方法，具体选用哪个方法以及其中的内容根据应用场景决定</p>
<p>配置文件参数说明：</p>
<ul>
<li>Manifest-Version: 版本号</li>
<li>Created-By: 创作者</li>
<li>Agent-Class: agentmain方法所在类</li>
<li>Can-Redefine-Classes: 是否可以实现类的重定义</li>
<li>Can-Retransform-Classes: 是否可以实现字节码替换</li>
<li>Premain-Class: premain 方法所在类</li>
</ul>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>   Java Agent 技术有以下主要功能：</p>
<ul>
<li>在加载Java文件前拦截字节码并做修改</li>
<li>在运行期间变更已加载的类的字节码</li>
<li> 获取所有已经被加载过的类</li>
<li>获取所有已经被初始化过了的类</li>
<li>获取某个对象的大小</li>
</ul>
<p>基于这些功能，衍生出了很多常见工具，Java调式、热部署、线上诊断等工具都有依赖Java Agent：</p>
<ul>
<li><p>各个 Java IDE 的调试功能，例如 eclipse、IntelliJ </p>
</li>
<li><p>热部署功能，例如 JRebel、XRebel、spring-loaded</p>
</li>
<li><p>各种线上诊断工具，例如 Btrace、Greys，还有阿里的 Arthas</p>
</li>
<li><p>各种性能分析工具，例如 Visual VM、JConsole 等</p>
</li>
</ul>
<h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><p>Java Agent分为两种：静态<code>Agent</code>与动态<code>Agent</code></p>
<p><img src="/images/image-20221008202408373.png" alt="image-20221008202408373"></p>
<h2 id="静态Agent"><a href="#静态Agent" class="headerlink" title="静态Agent"></a>静态Agent</h2><p> 这种方式是使用<code>premain</code>作为<code>Agent</code>的入口方法，以JVM启动参数<code>-javaagent:xxx.jar</code>方式载入，在Java程序的<code>main</code>方法执行之前执行</p>
<ol>
<li><p>编写<code>premain</code>方法，应该包含以下两个方法中的一个：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String args, Instrumentation inst)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String args)</span></span>;</span><br></pre></td></tr></table></figure>

<p>JVM 会优先加载带<code>Instrumentation</code>签名的方法1，加载成功忽略方法2，如果没有<code>Instrumentation</code>签名的方法，则加载方法2</p>
</li>
<li><p>定义一个<code>MANIFEST.MF</code>文件，其中必须包含Premain-Class选项</p>
</li>
<li><p>将包含<code>premain</code>的类与<code>MANIFEST.MF</code>配置文件打包成一个 jar 包</p>
</li>
<li><p>在JVM启动参数中添加<code>-javaagent:[path]</code>，其中的<code>path</code>为对应的<code>Agent</code>的jar包路径。这样则将<code>Agent</code>挂载成功，Java程序再执行<code>main</code>方法前执行</p>
</li>
</ol>
<h2 id="动态Agent"><a href="#动态Agent" class="headerlink" title="动态Agent"></a>动态Agent</h2><p> 与静态方式不同，动态<code>Agent</code>允许代理的目标程序的JVM先启动，再通过<code>attach</code>机制载入</p>
<ol>
<li><p>同样需要实现<code>agentmain</code>方法，加载优先级与<code>premain</code>相同，带<code>Instrumentation</code>签名的方法优先</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">agentmain</span><span class="params">(String args, Instrumentation inst)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">agentmain</span><span class="params">(String args)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>定义一个<code>MANIFEST.MF</code>文件，与静态<code>Agent</code>不同的是，此时必须包含Agent-Class选项</p>
</li>
<li><p>同样将包含<code>agentmain</code>的类与<code>MANIFEST.MF</code>配置文件打包成一个 jar 包</p>
</li>
<li><p>和<code>premain</code>模式不同，不再通过添加启动参数的方式来连接<code>agent</code>和主程序了，而使用<code>attach</code>方式来挂载。<code>attach</code>方式使用了<code>com.sun.tools.attach</code>包下的<code>VirtualMachine</code>工具类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取所有VM实例</span></span><br><span class="line">List&lt;VirtualMachineDescriptor&gt; list = VirtualMachine.list();</span><br><span class="line"><span class="comment">// attach对应VM</span></span><br><span class="line">VirtualMachine attach = VirtualMachine.attach(descriptor);</span><br><span class="line"><span class="comment">// 加载目标Agent</span></span><br><span class="line">attach.loadAgent(<span class="string">&quot;Java-Agent路径&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><p>最常用<code>Instrumentation</code>的<code>addTransformer</code>方法对类加载做拦截，对输入的类的字节码进行修改、增强。依赖字节码修改，字节码修改技术主要有 Javassist、ASM，Javassist使用更简单，这里使用Javassist来进行字节码修改，引入相关maven包</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javassist<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javassist<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.12.1.GA<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>Javassist</code> 使用可以参考下面文档：</p>
<p><a href="https://www.cnblogs.com/chiangchou/p/javassist.html">基于 Javassist 和 Javaagent 实现动态切面</a></p>
<p><a href="https://github.com/jboss-javassist/javassist/wiki">Javassist API</a></p>
<h2 id="实现极简的watch命令"><a href="#实现极简的watch命令" class="headerlink" title="实现极简的watch命令"></a>实现极简的watch命令</h2><blockquote>
<p>模拟Arthas的watch命令，来统计方法执行耗时</p>
</blockquote>
<h3 id="开发Agent"><a href="#开发Agent" class="headerlink" title="开发Agent"></a>开发Agent</h3><p><a href="https://github.com/ShadowTwj/sandbox/tree/master/agent/src/main/java/cn/tianwenjie/watch">https://github.com/ShadowTwj/sandbox/tree/master/agent/src/main/java/cn/tianwenjie/watch</a></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ol>
<li>Agent入口方法，包括<code>premain</code>和<code>agentmain</code>两个方法，后面会分别测试两个场景</li>
</ol>
<img src="/images/image-20221010202535725.png" alt="image-20221010202535725" style="zoom: 33%;" />

<ol start="2">
<li><p>实现类转换器，来对指定类和方法增强</p>
<img src="/images/image-20221010202839064.png" alt="image-20221010202839064" style="zoom:33%;" /></li>
</ol>
<h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><p>配置<code>MANIFEST.MF</code>文件，指定<code>Premain-Class</code>和<code>Agent-Class</code>等属性，将配置文件与代码一同打包生成jar包</p>
<p>也可以使用maven的<code>maven-assembly-plugin</code>插件，来进行打包，参数可直接配置在pom文件中，打包的时候就会自动将配置信息生成 <code>MANIFEST.MF</code> 配置文件打进包里</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-assembly-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">archive</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">addClasspath</span>&gt;</span>true<span class="tag">&lt;/<span class="name">addClasspath</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">manifestEntries</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Built-By</span>&gt;</span>neo<span class="tag">&lt;/<span class="name">Built-By</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Premain-Class</span>&gt;</span>cn.tianwenjie.watch.WatchDemo<span class="tag">&lt;/<span class="name">Premain-Class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Agent-Class</span>&gt;</span>cn.tianwenjie.watch.WatchDemo<span class="tag">&lt;/<span class="name">Agent-Class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Main-Class</span>&gt;</span>cn.tianwenjie.watch.WatchDemo<span class="tag">&lt;/<span class="name">Main-Class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Can-Redefine-Classes</span>&gt;</span>true<span class="tag">&lt;/<span class="name">Can-Redefine-Classes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Can-Retransform-Classes</span>&gt;</span>true<span class="tag">&lt;/<span class="name">Can-Retransform-Classes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Can-Set-Native-Method-Prefix</span>&gt;</span>true<span class="tag">&lt;/<span class="name">Can-Set-Native-Method-Prefix</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">manifestEntries</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">descriptorRef</span>&gt;</span>jar-with-dependencies<span class="tag">&lt;/<span class="name">descriptorRef</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><blockquote>
<p>分别测试Agent的两种方式</p>
</blockquote>
<p><a href="https://github.com/ShadowTwj/sandbox/tree/master/agent-run/src/main/java/cn/tianwenjie/watch">https://github.com/ShadowTwj/sandbox/tree/master/agent-run/src/main/java/cn/tianwenjie/watch</a></p>
<h4 id="静态Agent测试"><a href="#静态Agent测试" class="headerlink" title="静态Agent测试"></a>静态Agent测试</h4><ul>
<li>打印控制台输入，统计打印方法耗时</li>
</ul>
<img src="/images/image-20221011110030840.png" alt="image-20221011110030840" style="zoom: 33%;" />

<ul>
<li>添加<code>VM options</code>，指定<code>Agent</code> Jar包路径</li>
</ul>
<img src="/images/image-20221011110416104.png" alt="image-20221011110416104" style="zoom:33%;" />

<ul>
<li><p>执行<code>main</code>方法，观察<code>print</code>方法耗时</p>
<img src="/images/image-20221011110730915.png" alt="image-20221011110730915" style="zoom:33%;" /></li>
</ul>
<h4 id="动态Agent测试"><a href="#动态Agent测试" class="headerlink" title="动态Agent测试"></a>动态Agent测试</h4><ul>
<li><p>测试方法如上，打印控制台输入，统计打印方法耗时</p>
</li>
<li><p>不需要添加<code>VM options</code>，直接执行<code>main</code>方法，观察未挂载<code>Agent</code>前控制台只打印了输入参数，没有打印方法耗时，该方法不要结束，等待下面<code>Attach</code></p>
<img src="/images/image-20221011111320354.png" alt="image-20221011111320354" style="zoom:33%;" /></li>
<li><p><code>Attach</code> VM，挂载<code>Agent</code> Jar包</p>
<img src="/images/image-20221011111737935.png" alt="image-20221011111737935" style="zoom:33%;" /></li>
<li><p><code>Attach</code>成功后，再执行测试类，观察到方法增强成功，打印控制台输入的同时打印方法耗时</p>
<img src="/images/image-20221011112040162.png" alt="image-20221011112040162" style="zoom:33%;" /></li>
</ul>
<h2 id="模拟热加载"><a href="#模拟热加载" class="headerlink" title="模拟热加载"></a>模拟热加载</h2><blockquote>
<p>模拟热加载，重新加载修改的类</p>
<p>与watch命令最大的区别是没有使用字节码修改技术，而是自定义编译器，将新的代码编译为字节码</p>
</blockquote>
<h3 id="开发Agent-1"><a href="#开发Agent-1" class="headerlink" title="开发Agent"></a>开发Agent</h3><p><a href="https://github.com/ShadowTwj/sandbox/tree/master/agent/src/main/java/cn/tianwenjie/hotdeploy">https://github.com/ShadowTwj/sandbox/tree/master/agent/src/main/java/cn/tianwenjie/hotdeploy</a></p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><ol>
<li><p>Agent入口方法，静态Agent对热加载无用，这里只实现动态Agent的<code>agentmain</code>方法</p>
<p>使用<code>retransform</code>和<code>redefineClasses</code>方法效果一样，这里使用<code>redefineClasses</code>方法，不在实现类转换器</p>
<img src="/images/image-20221112180722715.png" alt="image-20221112180722715" style="zoom:50%;" /></li>
<li><p>自定义编译器，因为热加载改动代码大多都不可预测，使用字节码修改技术并不方便，这里自定义编译器，来编译成字节码</p>
<p>具体代码：</p>
<p><a href="https://github.com/ShadowTwj/sandbox/blob/master/agent/src/main/java/cn/tianwenjie/hotdeploy/common/DynamicCompiler.java">https://github.com/ShadowTwj/sandbox/blob/master/agent/src/main/java/cn/tianwenjie/hotdeploy/common/DynamicCompiler.java</a></p>
</li>
</ol>
<h4 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h4><p>修改<code>maven-assembly-plugin</code>插件配置，打包生成配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-assembly-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">archive</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">addClasspath</span>&gt;</span>true<span class="tag">&lt;/<span class="name">addClasspath</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">manifestEntries</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Built-By</span>&gt;</span>neo<span class="tag">&lt;/<span class="name">Built-By</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Premain-Class</span>&gt;</span>cn.tianwenjie.hotdeploy.HotLoadingDemo<span class="tag">&lt;/<span class="name">Premain-Class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Agent-Class</span>&gt;</span>cn.tianwenjie.hotdeploy.HotLoadingDemo<span class="tag">&lt;/<span class="name">Agent-Class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Main-Class</span>&gt;</span>cn.tianwenjie.hotdeploy.HotLoadingDemo<span class="tag">&lt;/<span class="name">Main-Class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Can-Redefine-Classes</span>&gt;</span>true<span class="tag">&lt;/<span class="name">Can-Redefine-Classes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Can-Retransform-Classes</span>&gt;</span>true<span class="tag">&lt;/<span class="name">Can-Retransform-Classes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Can-Set-Native-Method-Prefix</span>&gt;</span>true<span class="tag">&lt;/<span class="name">Can-Set-Native-Method-Prefix</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">manifestEntries</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">descriptorRef</span>&gt;</span>jar-with-dependencies<span class="tag">&lt;/<span class="name">descriptorRef</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><p><a href="https://github.com/ShadowTwj/sandbox/tree/master/agent-run/src/main/java/cn/tianwenjie/hotdeploy">https://github.com/ShadowTwj/sandbox/tree/master/agent-run/src/main/java/cn/tianwenjie/hotdeploy</a></p>
<ul>
<li><p>测试方法同上watch命令，打印控制台输入</p>
<img src="/images/image-20221112182332843.png" alt="image-20221112182332843" style="zoom:50%;" /></li>
<li><p><code>Attach</code> VM，挂载<code>Agent</code> Jar包，热加载新类。如下图，继续打印控制台输入，可以看到热加载成功</p>
<img src="/images/image-20221112182533197.png" alt="image-20221112182533197" style="zoom:50%;" /></li>
</ul>
<h1 id="Java-Agent原理"><a href="#Java-Agent原理" class="headerlink" title="Java-Agent原理"></a>Java-Agent原理</h1><h2 id="静态Agent-1"><a href="#静态Agent-1" class="headerlink" title="静态Agent"></a>静态Agent</h2><h3 id="启动时加载过程"><a href="#启动时加载过程" class="headerlink" title="启动时加载过程"></a>启动时加载过程</h3><blockquote>
<p>JPLISAgent：作用是初始化所有通过Java Instrumentation API编写的Agent，并且也承担着通过JVMTI实现Java Instrumentation中暴露API的责任</p>
</blockquote>
<ol>
<li>创建并初始化 JPLISAgent；</li>
<li>监听 VMInit 事件，在 JVM 初始化完成之后做下面的事情：<ol>
<li>创建 InstrumentationImpl 对象 ；</li>
<li>监听 ClassFileLoadHook 事件 ；</li>
<li>调用 InstrumentationImpl 的loadClassAndCallPremain方法，在这个方法里会去调用 javaagent 中 MANIFEST.MF 里指定的Premain-Class 类的 premain 方法 ；</li>
</ol>
</li>
<li>解析 javaagent 中 MANIFEST.MF 文件的参数，并根据这些参数来设置 JPLISAgent 里的一些内容。</li>
</ol>
<img src="/images/1071038-20210112143707325-1984756789.png" />

<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><ol>
<li><p>参数解析</p>
<p>JVM启动时解析对应参数，观察<code>hotspot/src/share/vm/runtime/arguments.cpp</code>中的<code>Arguments::parse_each_vm_init_arg</code>函数片段</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -agentlib and -agentpath</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">match_option</span>(option, <span class="string">&quot;-agentlib:&quot;</span>, &amp;tail) ||</span><br><span class="line">          (is_absolute_path = <span class="built_in">match_option</span>(option, <span class="string">&quot;-agentpath:&quot;</span>, &amp;tail))) &#123;</span><br><span class="line">      <span class="keyword">if</span>(tail != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* pos = <span class="built_in">strchr</span>(tail, <span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">        <span class="keyword">char</span>* name;</span><br><span class="line">        <span class="keyword">if</span> (pos == <span class="literal">NULL</span>) &#123;</span><br><span class="line">          name = os::<span class="built_in">strdup_check_oom</span>(tail, mtArguments);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">size_t</span> len = pos - tail;</span><br><span class="line">          name = <span class="built_in">NEW_C_HEAP_ARRAY</span>(<span class="keyword">char</span>, len + <span class="number">1</span>, mtArguments);</span><br><span class="line">          <span class="built_in">memcpy</span>(name, tail, len);</span><br><span class="line">          name[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> *options = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(pos != <span class="literal">NULL</span>) &#123;</span><br><span class="line">          options = os::<span class="built_in">strdup_check_oom</span>(pos + <span class="number">1</span>, mtArguments);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !INCLUDE_JVMTI</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">valid_jdwp_agent</span>(name, is_absolute_path)) &#123;</span><br><span class="line">          <span class="built_in">jio_fprintf</span>(defaultStream::<span class="built_in">error_stream</span>(),</span><br><span class="line">            <span class="string">&quot;Debugging agents are not supported in this VM\n&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span> JNI_ERR;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// !INCLUDE_JVMTI</span></span></span><br><span class="line">        <span class="comment">// 存储Agent解析结果</span></span><br><span class="line">        <span class="comment">// name:&quot;instrument&quot;，动态链接库</span></span><br><span class="line">        <span class="built_in">add_init_agent</span>(name, options, is_absolute_path);</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">// -javaagent</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">match_option</span>(option, <span class="string">&quot;-javaagent:&quot;</span>, &amp;tail)) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !INCLUDE_JVMTI</span></span><br><span class="line">      <span class="built_in">jio_fprintf</span>(defaultStream::<span class="built_in">error_stream</span>(),</span><br><span class="line">        <span class="string">&quot;Instrumentation agents are not supported in this VM\n&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> JNI_ERR;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">      <span class="keyword">if</span> (tail != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">size_t</span> length = <span class="built_in">strlen</span>(tail) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> *options = <span class="built_in">NEW_C_HEAP_ARRAY</span>(<span class="keyword">char</span>, length, mtArguments);</span><br><span class="line">        <span class="built_in">jio_snprintf</span>(options, length, <span class="string">&quot;%s&quot;</span>, tail);</span><br><span class="line">        <span class="built_in">add_instrument_agent</span>(<span class="string">&quot;instrument&quot;</span>, options, <span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// java agents need module java.instrument</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">create_numbered_module_property</span>(<span class="string">&quot;jdk.module.addmods&quot;</span>, <span class="string">&quot;java.instrument&quot;</span>, addmods_count++)) &#123;</span><br><span class="line">          <span class="keyword">return</span> JNI_ENOMEM;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// !INCLUDE_JVMTI</span></span></span><br></pre></td></tr></table></figure>

<p>这段逻辑用来解析需要加载的Agent路径，然后调用<code>add_init_agent</code>存储解析结果到<code>_agentList</code>中，<code>AgentLibraryList</code>是一个链表</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -agentlib and -agentpath arguments</span></span><br><span class="line"><span class="keyword">static</span> AgentLibraryList _agentList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Arguments::add_init_agent</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">char</span>* options, <span class="keyword">bool</span> absolute_path)</span> </span>&#123;</span><br><span class="line">  _agentList.<span class="built_in">add</span>(<span class="keyword">new</span> <span class="built_in">AgentLibrary</span>(name, options, absolute_path, <span class="literal">NULL</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>加载Agent</p>
<p>观察<code>hotspot/src/share/vm/runtime/threads.cpp</code>中的<code>Threads::create_vm</code>函数，JVM在解析完参数后，判断<code>_agentList</code>是否为空，不为空加载<code>Agent</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Launch -agentlib/-agentpath and converted -Xrun agents</span></span><br><span class="line"><span class="comment">// 判断agent链表是否为空，不为空加载Agent</span></span><br><span class="line"><span class="keyword">if</span> (Arguments::<span class="built_in">init_agents_at_startup</span>()) &#123;</span><br><span class="line">  <span class="built_in">create_vm_init_agents</span>();</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">init_agents_at_startup</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> !_agentList.<span class="built_in">is_empty</span>(); &#125;</span><br></pre></td></tr></table></figure>

<p>分析<code>create_vm_init_agents</code>函数，遍历<code>Agent</code>逐个加载，解析对应的<code>Agent_Onload</code>函数，最终调用<code>premain</code>方法，执行<code>Agent_Onload</code>函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (agent = Arguments::<span class="built_in">agents</span>(); agent != <span class="literal">NULL</span>; agent = agent-&gt;<span class="built_in">next</span>()) &#123;</span><br><span class="line">  <span class="comment">// CDS dumping does not support native JVMTI agent.</span></span><br><span class="line">  <span class="comment">// CDS dumping supports Java agent if the AllowArchivingWithJavaAgent diagnostic option is specified.</span></span><br><span class="line">  <span class="keyword">if</span> (Arguments::<span class="built_in">is_dumping_archive</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!agent-&gt;<span class="built_in">is_instrument_lib</span>()) &#123;</span><br><span class="line">      <span class="built_in">vm_exit_during_cds_dumping</span>(<span class="string">&quot;CDS dumping does not support native JVMTI agent, name&quot;</span>, agent-&gt;<span class="built_in">name</span>());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!AllowArchivingWithJavaAgent) &#123;</span><br><span class="line">      <span class="built_in">vm_exit_during_cds_dumping</span>(</span><br><span class="line">        <span class="string">&quot;Must enable AllowArchivingWithJavaAgent in order to run Java agent during CDS dumping&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解析Agent_OnLoad函数，最终调用premain方法</span></span><br><span class="line">  OnLoadEntry_t  on_load_entry = <span class="built_in">lookup_agent_on_load</span>(agent);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (on_load_entry != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">// Invoke the Agent_OnLoad function</span></span><br><span class="line">    <span class="comment">// 执行Agent_OnLoad函数</span></span><br><span class="line">    jint err = (*on_load_entry)(&amp;main_vm, agent-&gt;<span class="built_in">options</span>(), <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (err != JNI_OK) &#123;</span><br><span class="line">      <span class="built_in">vm_exit_during_initialization</span>(<span class="string">&quot;agent library failed to init&quot;</span>, agent-&gt;<span class="built_in">name</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">vm_exit_during_initialization</span>(<span class="string">&quot;Could not find Agent_OnLoad function in the agent library&quot;</span>, agent-&gt;<span class="built_in">name</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Agent_OnLoad函数</p>
<blockquote>
<p>动态链接库<code>libinstrument</code>，用来支持使用Java Instrumentation API来编写Agent，在libinstrument中有一个非常重要的类称为：JPLISAgent（Java Programming Language Instrumentation Services Agent），它的作用是初始化所有通过Java Instrumentation API编写的Agent，并且也承担着通过JVMTI实现Java Instrumentation中暴露API的责任</p>
</blockquote>
<p>在动态链接库<code>libinstrument</code>中找到<code>Agent_OnLoad</code>函数，在<code>java.instrument/share/native/libinstrument/InvocationAdapter.c</code>中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">JNIEXPORT jint JNICALL</span><br><span class="line">DEF_Agent_OnLoad(JavaVM *vm, <span class="keyword">char</span> *tail, <span class="keyword">void</span> * reserved) &#123;</span><br><span class="line">    JPLISInitializationError initerror  = JPLIS_INIT_ERROR_NONE;</span><br><span class="line">    jint                     result     = JNI_OK;</span><br><span class="line">    JPLISAgent *             agent      = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 创建并初始化JPLISAgent</span></span><br><span class="line">    initerror = createNewJPLISAgent(vm, &amp;agent);</span><br><span class="line">   	<span class="keyword">if</span> ( initerror == JPLIS_INIT_ERROR_NONE ) &#123;</span><br><span class="line">        <span class="keyword">int</span>             oldLen, newLen;</span><br><span class="line">        <span class="keyword">char</span> *          jarfile;</span><br><span class="line">        <span class="keyword">char</span> *          options;</span><br><span class="line">        jarAttribute*   attributes;</span><br><span class="line">        <span class="keyword">char</span> *          premainClass;</span><br><span class="line">        <span class="keyword">char</span> *          bootClassPath;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Parse &lt;jarfile&gt;[=options] into jarfile and options</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (parseArgumentTail(tail, &amp;jarfile, &amp;options) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;-javaagent: memory allocation failure.\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> JNI_ERR;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        attributes = readAttributes(jarfile);</span><br><span class="line">        </span><br><span class="line">      	<span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">        premainClass = getAttribute(attributes, <span class="string">&quot;Premain-Class&quot;</span>);</span><br><span class="line">        </span><br><span class="line">      	<span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Save the jarfile name */</span></span><br><span class="line">        agent-&gt;mJarfile = jarfile;</span><br><span class="line">				</span><br><span class="line">      	<span class="comment">//...</span></span><br><span class="line">      </span><br><span class="line">        bootClassPath = getAttribute(attributes, <span class="string">&quot;Boot-Class-Path&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Convert JAR attributes into agent capabilities</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        convertCapabilityAttributes(attributes, agent);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Track (record) the agent class name and options data</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        initerror = recordCommandLineData(agent, premainClass, options);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Clean-up</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (options != <span class="literal">NULL</span>) <span class="built_in">free</span>(options);</span><br><span class="line">        freeAttributes(attributes);</span><br><span class="line">        <span class="built_in">free</span>(premainClass);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到函数中调用<code>createNewJPLISAgent</code>方法，创建JPLISAgent，在<code>createNewJPLISAgent</code>函数中又调用<code>initializeJPLISAgent</code>函数进行初始化，<code>initializeJPLISAgent</code>函数中有设置VMInit时间回调函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2.触发VMInit事件回调</span></span><br><span class="line">callbacks.VMInit = &amp;eventHandlerVMInit;</span><br></pre></td></tr></table></figure>

<p>看下<code>eventHandlerVMInit</code>函数实现，<code>eventHandlerVMInit</code> -&gt; <code>processJavaStart</code> -&gt; <code>startJavaAgent</code> -&gt; <code>invokeJavaAgentMainMethod</code>，最终<code>invokeJavaAgentMainMethod</code>函数则是调用<code>premain</code>方法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> JNICALL</span><br><span class="line">eventHandlerVMInit( jvmtiEnv *      jvmtienv,</span><br><span class="line">                    JNIEnv *        jnienv,</span><br><span class="line">                    jthread         thread) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  success = processJavaStart( environment-&gt;mAgent, jnienv);</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jboolean</span><br><span class="line">processJavaStart(   JPLISAgent *    agent,</span><br><span class="line">                    JNIEnv *        jnienv) &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *  Now make the InstrumentationImpl instance.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ( result ) &#123;</span><br><span class="line">        result = createInstrumentationImpl(jnienv, agent);</span><br><span class="line">        jplis_assert_msg(result, <span class="string">&quot;instrumentation instance creation failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *  Load the Java agent, and call the premain.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ( result ) &#123;</span><br><span class="line">        result = startJavaAgent(agent, jnienv,</span><br><span class="line">                                agent-&gt;mAgentClassName, agent-&gt;mOptionsString,</span><br><span class="line">                                agent-&gt;mPremainCaller);</span><br><span class="line">        jplis_assert_msg(result, <span class="string">&quot;agent load/premain call failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jboolean</span><br><span class="line">startJavaAgent( JPLISAgent *    agent,</span><br><span class="line">                JNIEnv *        jnienv,</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">char</span> *    classname,</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">char</span> *    optionsString,</span><br><span class="line">                jmethodID       agentMainMethod) &#123;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">  </span><br><span class="line">	  <span class="comment">// 3.执行premain方法</span></span><br><span class="line">  	success = invokeJavaAgentMainMethod(   jnienv,</span><br><span class="line">    	                                  agent-&gt;mInstrumentationImpl,</span><br><span class="line">      	                                agentMainMethod,</span><br><span class="line">        	                              classNameObject,</span><br><span class="line">          	                            optionsStringObject);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="动态Agent-1"><a href="#动态Agent-1" class="headerlink" title="动态Agent"></a>动态Agent</h2><h3 id="运行时加载过程"><a href="#运行时加载过程" class="headerlink" title="运行时加载过程"></a>运行时加载过程</h3><p>通过 JVM 的attach机制来请求目标 JVM 加载对应的agent，过程大致如下：</p>
<ol>
<li>创建并初始化JPLISAgent；</li>
<li>解析 javaagent 里 MANIFEST.MF 里的参数；</li>
<li>创建 InstrumentationImpl 对象；</li>
<li>监听 ClassFileLoadHook 事件；</li>
<li>调用 InstrumentationImpl 的loadClassAndCallAgentmain方法，在这个方法里会去调用javaagent里 MANIFEST.MF 里指定的Agent-Class类的agentmain方法。</li>
</ol>
<img src="/images/1071038-20210112143615738-1489695442.png"/>

<h3 id="Attach-1"><a href="#Attach-1" class="headerlink" title="Attach"></a>Attach</h3><blockquote>
<p>动态Agent是通过Attach机制来加载，下面分析下Attach原理</p>
</blockquote>
<ol>
<li><p>AttachListener</p>
<p><code>Attach</code>机制通过<code>Attach Listener</code>线程来进行相关事务的处理，<code>AttachListener</code>初始化如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AttachListener::init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  EXCEPTION_MARK;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* name = <span class="string">&quot;Attach Listener&quot;</span>;</span><br><span class="line">  Handle thread_oop = JavaThread::<span class="built_in">create_system_thread_object</span>(name, <span class="literal">true</span> <span class="comment">/* visible */</span>, THREAD);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">has_init_error</span>(THREAD)) &#123;</span><br><span class="line">    <span class="built_in">set_state</span>(AL_NOT_INITIALIZED);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  JavaThread* thread = <span class="keyword">new</span> <span class="built_in">JavaThread</span>(&amp;attach_listener_thread_entry);</span><br><span class="line">  JavaThread::<span class="built_in">vm_exit_on_osthread_failure</span>(thread);</span><br><span class="line"></span><br><span class="line">  JavaThread::<span class="built_in">start_internal_daemon</span>(THREAD, thread, thread_oop, NoPriority);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>attach_listener_thread_entry</code>函数是线程入口，代码片段如下：</p>
<p>首先获取到<code>Attach</code>任务，然后查询匹配命令对应的函数，最后执行对应函数，funcs是命令对应的函数，其中”load”命令对应<code>load_agent</code>函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">attach_listener_thread_entry</span><span class="params">(JavaThread* thread, TRAPS)</span> </span>&#123;</span><br><span class="line">  AttachListener::<span class="built_in">set_initialized</span>();</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">	    <span class="comment">// 1.获取Attach任务</span></span><br><span class="line">      AttachOperation* op = AttachListener::<span class="built_in">dequeue</span>();</span><br><span class="line">    </span><br><span class="line">      <span class="comment">// find the function to dispatch too</span></span><br><span class="line">	    <span class="comment">// 2.查询匹配命令对应的函数，funcs是命令对应的函数，其中&quot;load&quot;命令对应load_agent函数</span></span><br><span class="line">      AttachOperationFunctionInfo* info = <span class="literal">NULL</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; funcs[i].name != <span class="literal">NULL</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* name = funcs[i].name;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(op-&gt;<span class="built_in">name</span>(), name) == <span class="number">0</span>) &#123;</span><br><span class="line">          info = &amp;(funcs[i]); <span class="keyword">break</span>;</span><br><span class="line">        &#125;&#125;</span><br><span class="line">    </span><br><span class="line">       <span class="comment">// dispatch to the function that implements this operation</span></span><br><span class="line">	    <span class="comment">// 3.执行命令对应的函数</span></span><br><span class="line">        res = (info-&gt;func)(op, &amp;st);</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看<code>dequeue</code>函数，是如何获取任务的，<code>dequeue</code>函数不系统实现不同，windows系统是<code>Win32AttachListener::dequeue()</code>，Mac系统是<code>BsdAttachListener::dequeue()</code>，Linux系统是<code>LinuxAttachListener::dequeue()</code>。下面是Linux系统实现，等待客户端连接，通过<code>accept</code>来接收，然后将请求读出来，包装成<code>AttachOperation</code>对象，返回进行处理</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LinuxAttachOperation* <span class="title">LinuxAttachListener::dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">// wait for client to connect</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> <span class="title">addr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> len = <span class="built_in"><span class="keyword">sizeof</span></span>(addr);</span><br><span class="line">    <span class="comment">// 等待连接，通过accept来接收</span></span><br><span class="line">    <span class="built_in">RESTARTABLE</span>(::<span class="built_in">accept</span>(<span class="built_in">listener</span>(), &amp;addr, &amp;len), s);</span><br><span class="line">    <span class="comment">// get the credentials of the peer and check the effective uid/guid</span></span><br><span class="line">    <span class="comment">// - check with jeff on this.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ucred</span> <span class="title">cred_info</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> optlen = <span class="built_in"><span class="keyword">sizeof</span></span>(cred_info);</span><br><span class="line">    <span class="keyword">if</span> (::<span class="built_in">getsockopt</span>(s, SOL_SOCKET, SO_PEERCRED, (<span class="keyword">void</span>*)&amp;cred_info, &amp;optlen) == <span class="number">-1</span>) &#123;</span><br><span class="line">      ::<span class="built_in">close</span>(s);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// peer credential look okay so we read the request</span></span><br><span class="line">    <span class="comment">// 将请求读出来</span></span><br><span class="line">    LinuxAttachOperation* op = <span class="built_in">read_request</span>(s);</span><br><span class="line">    <span class="keyword">return</span> op;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>VirtualMachine.attach</code>方法</p>
<p>通过<code>com.sun.tools.attach.VirtualMachine#attach</code>方法来连接指定pid的JVM进程，查看源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> VirtualMachine <span class="title">attach</span><span class="params">(String var0)</span> <span class="keyword">throws</span> AttachNotSupportedException, IOException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (var0 == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;id cannot be null&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    List var1 = AttachProvider.providers();</span><br><span class="line">    <span class="keyword">if</span> (var1.size() == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> AttachNotSupportedException(<span class="string">&quot;no providers installed&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      AttachNotSupportedException var2 = <span class="keyword">null</span>;</span><br><span class="line">      Iterator var3 = var1.iterator();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span>(var3.hasNext()) &#123;</span><br><span class="line">        AttachProvider var4 = (AttachProvider)var3.next();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> var4.attachVirtualMachine(var0);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AttachNotSupportedException var6) &#123;</span><br><span class="line">          var2 = var6;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">throw</span> var2;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出最终调用<code>AttachProvider</code>的<code>attachVirtualMachine</code>方法，<code>AttachProvider</code>是抽象类，不同系统不同实现，在MacOS中实现类是<code>BsdAttachProvider</code>，其中<code>attachVirtualMachine</code>实现是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> VirtualMachine <span class="title">attachVirtualMachine</span><span class="params">(String var1)</span> <span class="keyword">throws</span> AttachNotSupportedException, IOException </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.checkAttachPermission();</span><br><span class="line">  <span class="keyword">this</span>.testAttachable(var1);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> BsdVirtualMachine(<span class="keyword">this</span>, var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看其构造方法，通过<code>findSocketFile</code>方法用来查询目标JVM上是否已经启动了<code>Attach Listener</code>，因为<code>Attach Listener</code>是懒加载，所以JVM启动也不一定加载。检查<code>/tmp/.java_pid&#123;pid&#125;</code>文件是否存在，如果存在，则说明目标JVM Attach机制已准备就绪，可以直接通过<code>connect</code>方法来连接到目标JVM，发送命令；如果不存在，则说明目标JVM的<code>Attach Listener</code>还没有初始化，这时通过<code>sendQuitTo</code>方法向目标JVM发送信号，让其初始化<code>Attach Listener</code>，并且循环等待<code>/tmp/.java_pid&#123;pid&#125;</code>文件的创建，之后再通过<code>connect</code>方法来连接到目标JVM，发送命令</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BsdVirtualMachine(AttachProvider var1, String var2) <span class="keyword">throws</span> AttachNotSupportedException, IOException &#123;</span><br><span class="line">  <span class="keyword">super</span>(var1, var2);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> var3;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    var3 = Integer.parseInt(var2);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (NumberFormatException var22) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> AttachNotSupportedException(<span class="string">&quot;Invalid process identifier&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// var3为pid，检查/tmp/.java_pid&#123;pid&#125;是否存在</span></span><br><span class="line">  <span class="keyword">this</span>.path = <span class="keyword">this</span>.findSocketFile(var3);</span><br><span class="line">  <span class="comment">// 如果存在，则说明目标JVM Attach机制已准备就绪，可以直接通过connect方法来连接到目标JVM，发送命令</span></span><br><span class="line">  <span class="comment">// 如果不存在，则说明目标JVM的Attach Listener还没有初始化</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.path == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 创建/tmp/.java_pid&#123;pid&#125;文件</span></span><br><span class="line">    File var4 = <span class="keyword">new</span> File(tmpdir, <span class="string">&quot;.attach_pid&quot;</span> + var3);</span><br><span class="line">    createAttachFile(var4.getPath());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 向目标JVM发送信号，让其初始化Attach Listener</span></span><br><span class="line">      sendQuitTo(var3);</span><br><span class="line">      <span class="keyword">int</span> var5 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">long</span> var6 = <span class="number">200L</span>;</span><br><span class="line">      <span class="keyword">int</span> var8 = (<span class="keyword">int</span>)(<span class="keyword">this</span>.attachTimeout() / var6);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 循环等待/tmp/.java_pid&#123;pid&#125;文件的创建，之后再通过connect方法来连接到目标JVM，发送命令</span></span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          Thread.sleep(var6);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException var21) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.path = <span class="keyword">this</span>.findSocketFile(var3);</span><br><span class="line">        ++var5;</span><br><span class="line">      &#125; <span class="keyword">while</span>(var5 &lt;= var8 &amp;&amp; <span class="keyword">this</span>.path == <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.path == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AttachNotSupportedException(<span class="string">&quot;Unable to open socket file: target process not responding or HotSpot VM not loaded&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      var4.delete();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  checkPermissions(<span class="keyword">this</span>.path);</span><br><span class="line">  <span class="keyword">int</span> var24 = socket();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    connect(var24, <span class="keyword">this</span>.path);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    close(var24);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>loadAgent方法</code></p>
<p>通过<code>attach</code>方法，连接上目标JVM后，通过<code>loadAgent</code>方法来加载<code>Agent</code>，其本质是向目标JVM发送<code>load</code>命令，这里不再展开</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadAgentLibrary</span><span class="params">(String var1, <span class="keyword">boolean</span> var2, String var3)</span> <span class="keyword">throws</span> AgentLoadException, AgentInitializationException, IOException </span>&#123;</span><br><span class="line">  InputStream var4 = <span class="keyword">this</span>.execute(<span class="string">&quot;load&quot;</span>, var1, var2 ? <span class="string">&quot;true&quot;</span> : <span class="string">&quot;false&quot;</span>, var3);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> var5 = <span class="keyword">this</span>.readInt(var4);</span><br><span class="line">    <span class="keyword">if</span> (var5 != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> AgentInitializationException(<span class="string">&quot;Agent_OnAttach failed&quot;</span>, var5);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    var4.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看下JVM中<code>load</code>命令的实现，上面<code>Agtach Listener</code>的<code>attach_listener_thread_entry</code>函数中，会查询匹配命令对应的函数，然后执行对应的函数，<code>funcs</code>则是一个命令函数表，查看<code>load</code>命令对应的函数，发现是<code>load_agent</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// names must be of length &lt;= AttachOperation::name_length_max</span></span><br><span class="line"><span class="keyword">static</span> AttachOperationFunctionInfo funcs[] = &#123;</span><br><span class="line">  &#123; <span class="string">&quot;agentProperties&quot;</span>,  get_agent_properties &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;datadump&quot;</span>,         data_dump &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;dumpheap&quot;</span>,         dump_heap &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;load&quot;</span>,             load_agent &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;properties&quot;</span>,       get_system_properties &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;threaddump&quot;</span>,       thread_dump &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;inspectheap&quot;</span>,      heap_inspection &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;setflag&quot;</span>,          set_flag &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;printflag&quot;</span>,        print_flag &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;jcmd&quot;</span>,             jcmd &#125;,</span><br><span class="line">  &#123; <span class="literal">NULL</span>,               <span class="literal">NULL</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>再查看<code>load_agent</code>函数实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Implementation of &quot;load&quot; command.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> jint <span class="title">load_agent</span><span class="params">(AttachOperation* op, outputStream* out)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// get agent name and options</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* agent = op-&gt;<span class="built_in">arg</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* absParam = op-&gt;<span class="built_in">arg</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* options = op-&gt;<span class="built_in">arg</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If loading a java agent then need to ensure that the java.instrument module is loaded</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strcmp</span>(agent, <span class="string">&quot;instrument&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">    JavaThread* THREAD = JavaThread::<span class="built_in">current</span>(); <span class="comment">// For exception macros.</span></span><br><span class="line">    <span class="function">ResourceMark <span class="title">rm</span><span class="params">(THREAD)</span></span>;</span><br><span class="line">    <span class="function">HandleMark <span class="title">hm</span><span class="params">(THREAD)</span></span>;</span><br><span class="line">    <span class="function">JavaValue <span class="title">result</span><span class="params">(T_OBJECT)</span></span>;</span><br><span class="line">    Handle h_module_name = java_lang_String::<span class="built_in">create_from_str</span>(<span class="string">&quot;java.instrument&quot;</span>, THREAD);</span><br><span class="line">    JavaCalls::<span class="built_in">call_static</span>(&amp;result,</span><br><span class="line">                           vmClasses::<span class="built_in">module_Modules_klass</span>(),</span><br><span class="line">                           vmSymbols::<span class="built_in">loadModule_name</span>(),</span><br><span class="line">                           vmSymbols::<span class="built_in">loadModule_signature</span>(),</span><br><span class="line">                           h_module_name,</span><br><span class="line">                           THREAD);</span><br><span class="line">    <span class="keyword">if</span> (HAS_PENDING_EXCEPTION) &#123;</span><br><span class="line">      java_lang_Throwable::<span class="built_in">print</span>(PENDING_EXCEPTION, out);</span><br><span class="line">      CLEAR_PENDING_EXCEPTION;</span><br><span class="line">      <span class="keyword">return</span> JNI_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> JvmtiExport::<span class="built_in">load_agent_library</span>(agent, absParam, options, out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要作用是加载<code>Agent</code>动态链接库，如果是通过<code>Java instrument API</code>实现的Agent，则加载的是<code>libinstrument</code>动态链接库。然后通过动态链接库中的<code>Agent_OnAttach</code>函数来创建<code>JPLISAgent</code>，从而调用<code>agentmain</code>方法。这一部分内容和<code>libinstrument</code>中的<code>Agent_OnLoad</code>函数来创建<code>JPLISAgent</code>，调用<code>premain</code>方法的逻辑相似</p>
</li>
</ol>
<h1 id="相关开源项目"><a href="#相关开源项目" class="headerlink" title="相关开源项目"></a>相关开源项目</h1><p>很多开源项目都用到了<code>Java-Agent</code>，下面列举两个项目，有兴趣可以阅读一下</p>
<h2 id="Arthas"><a href="#Arthas" class="headerlink" title="Arthas"></a>Arthas</h2><p>Arthas用到非常重要的技术就是Java-Agent，以及相关的字节码增强等技术，从启动方式就能看出来使用的是动态Agent的方式</p>
<p>代码地址：<a href="https://github.com/alibaba/arthas">https://github.com/alibaba/arthas</a></p>
<h2 id="ja-netfilter"><a href="#ja-netfilter" class="headerlink" title="ja-netfilter"></a>ja-netfilter</h2><p>一个Java Instrumentation框架，也是通过Java-Agent实现的，支持插件化。使用的是静态Agent方式</p>
<p>相关文章：<a href="https://zhile.io/2021/11/29/ja-netfilter-javaagent-lib.html">https://zhile.io/2021/11/29/ja-netfilter-javaagent-lib.html</a></p>
<p>代码地址：<a href="https://gitee.com/ja-netfilter/ja-netfilter">https://gitee.com/ja-netfilter/ja-netfilter</a></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.51cto.com/alex4dream/3247542">https://blog.51cto.com/alex4dream/3247542</a></p>
<p><a href="https://tech.meituan.com/2019/11/07/java-dynamic-debugging-technology.html">https://tech.meituan.com/2019/11/07/java-dynamic-debugging-technology.html</a></p>
<p><a href="https://tech.meituan.com/2022/03/17/java-hotswap-sonic.html">https://tech.meituan.com/2022/03/17/java-hotswap-sonic.html</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzkyMjIzOTQ3NA==&amp;mid=2247484609&amp;idx=1&amp;sn=8bd852871d656f5a5dcb216f810a273f&amp;source=41#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MzkyMjIzOTQ3NA==&amp;mid=2247484609&amp;idx=1&amp;sn=8bd852871d656f5a5dcb216f810a273f&amp;source=41#wechat_redirect</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
</search>
