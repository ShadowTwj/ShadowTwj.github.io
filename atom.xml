<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tianwj&#39;s blog</title>
  
  
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-11-06T05:32:56.327Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>tianwj</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>金字塔原理</title>
    <link href="http://yoursite.com/2021/09/24/%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2021/09/24/%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%86/</id>
    <published>2021-09-24T08:22:37.000Z</published>
    <updated>2021-11-06T05:32:56.327Z</updated>
    
    <content type="html"><![CDATA[<h2 id="结构思考力三层次模型"><a href="#结构思考力三层次模型" class="headerlink" title="结构思考力三层次模型"></a>结构思考力三层次模型</h2><h3 id="三层模型"><a href="#三层模型" class="headerlink" title="三层模型"></a>三层模型</h3><p>理解 -&gt; 重构 -&gt; 呈现</p><p><img src="/images/%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%860.png"></p><h3 id="模型目标"><a href="#模型目标" class="headerlink" title="模型目标"></a>模型目标</h3><p>隐形思维显性化 -&gt; 显性思维结构化 -&gt; 结构思维形象化</p><ul><li>隐形思维显性化：要提高自己的思考，首先要看到它</li><li>显性思维结构化：看到之后发现不清晰，需要结构化</li><li>结构思维形象化：结构化之后还需要把它传递出去，需要形象化的表达</li></ul><h3 id="金字塔结构"><a href="#金字塔结构" class="headerlink" title="金字塔结构"></a>金字塔结构</h3><p><img src="/images/%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%861.png"></p><blockquote><p>结构化思维是一种“从无序到有序”的思考过程</p><p>需要建立一个“先总后分”的思维方式。先找到解决问题的关键要点，然后再深入分析</p></blockquote><h2 id="理解：隐形思维显性化"><a href="#理解：隐形思维显性化" class="headerlink" title="理解：隐形思维显性化"></a>理解：隐形思维显性化</h2><h3 id="概况全文的“万能公式”"><a href="#概况全文的“万能公式”" class="headerlink" title="概况全文的“万能公式”"></a>概况全文的“万能公式”</h3><blockquote><p><code>在___的基础上，</code></p><p><code>从__，__，__N个方面，</code></p><p><code>说明了_____________。</code></p></blockquote><h3 id="结构思考力识别概况技术"><a href="#结构思考力识别概况技术" class="headerlink" title="结构思考力识别概况技术"></a>结构思考力识别概况技术</h3><blockquote><p>识别 -&gt; 判断 -&gt; 概况</p></blockquote><p><img src="/images/%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%862.png"></p><h3 id="隐形思维显性化前提"><a href="#隐形思维显性化前提" class="headerlink" title="隐形思维显性化前提"></a>隐形思维显性化前提</h3><p>隐形思维显性化的前提———有审视问题的坐标系</p><p><img src="/images/%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%863.png"></p><ul><li>审视问题的坐标系：<blockquote><p>这个事情有没有证据和理由支撑？</p><p>这个理由/逻辑是否能够推出结论？</p><p>其中的证据/事实是否能有效支撑理由？</p><p>是否存在隐藏或模糊不利的证据/事实？</p></blockquote></li></ul><h2 id="重构：显性思维结构化"><a href="#重构：显性思维结构化" class="headerlink" title="重构：显性思维结构化"></a>重构：显性思维结构化</h2><h3 id="重构四原则"><a href="#重构四原则" class="headerlink" title="重构四原则"></a>重构四原则</h3><ul><li><p>论-结论先行</p><blockquote><p>一段表达有一个核心观点，最好放在开头</p></blockquote></li><li><p>证-以上统下</p><blockquote><p>任何一层的论点，是下一层思想的概括</p></blockquote></li><li><p>类-归类分组</p><blockquote><p>每一组思想属于同一个范畴</p></blockquote></li><li><p>比-逻辑递进</p><blockquote><p>每一组思想按照一定的逻辑顺序排列</p></blockquote></li></ul><h3 id="论-结论先行"><a href="#论-结论先行" class="headerlink" title="论-结论先行"></a>论-结论先行</h3><p>结论先行可以提升我们的表达效率，让人快速理解你的核心意思。结论先行的难点不是先行，而是如何得出结论，需要反复联系</p><p><img src="/images/%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%864.png"></p><h3 id="证-以上统下"><a href="#证-以上统下" class="headerlink" title="证-以上统下"></a>证-以上统下</h3><p>上有结论，下有理由，结论概括理由，理由支撑结论，上下对应</p><p><img src="/images/%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%865.png"></p><h3 id="类-归类分组"><a href="#类-归类分组" class="headerlink" title="类-归类分组"></a>类-归类分组</h3><blockquote><p>人类大脑一次性接收的信息量是有范围的，这个范围有两个说法：5+-2 和 7+-2，不管是哪个说法，7都是一个临界值，当超过7时都会对记忆造成负担，所以在写方案时最好不要超过7条</p></blockquote><blockquote><p>而很多领导讲话都喜欢讲3点，理由有</p><ol><li>好记</li><li>对方更容易倾听</li><li>具有说服力；同时在物理结构中，3是稳定结构</li></ol><p>但是3点要能把事情说轻，说全，而这依赖 归类分组</p></blockquote><h4 id="MECE原则"><a href="#MECE原则" class="headerlink" title="MECE原则"></a>MECE原则</h4><blockquote><p>归类分组标准采用 MECE原则</p></blockquote><p>相互独立、完全穷尽</p><p>分类时不能有交叉、更不能有遗漏，不重不漏</p><p><img src="/images/%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%866.png"></p><h3 id="比-逻辑递进"><a href="#比-逻辑递进" class="headerlink" title="比-逻辑递进"></a>比-逻辑递进</h3><p>三种顺序</p><ul><li>时间顺序</li><li>结构顺序</li><li>重要性顺序</li></ul><p><strong>在同一个层级、同一个分支，必须使用同一种逻辑顺序</strong></p><p><img src="/images/%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%867.png"></p><h2 id="呈现：结构思维形象化"><a href="#呈现：结构思维形象化" class="headerlink" title="呈现：结构思维形象化"></a>呈现：结构思维形象化</h2><blockquote><p>形象化表达是结构化思考最有力的输出方式，结构化思考是形象化表达的基础</p></blockquote><h3 id="结构罗盘"><a href="#结构罗盘" class="headerlink" title="结构罗盘"></a>结构罗盘</h3><blockquote><p>形象化表达工具——结构罗盘</p></blockquote><blockquote><p>“配”关系 -&gt; “得”图示 -&gt; “上”包装</p></blockquote><p><img src="/images/%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%868.png"></p><ul><li>配关系：确定关系结构图下的一个分支的要素之间是什么关系</li><li>得图示：根据关系选择不同图示</li><li>上包装：对观点进行高度浓缩提炼，变得更加简洁、明了、容易记忆，及所谓“卖点包装”</li></ul><h3 id="配关系"><a href="#配关系" class="headerlink" title="配关系"></a>配关系</h3><p>四种模式，十六种关系</p><p>根据关系分支下的要素判断属于哪一种模式中的哪一种关系</p><p><img src="/images/%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%869.png"></p><h3 id="得图示"><a href="#得图示" class="headerlink" title="得图示"></a>得图示</h3><h3 id="上包装"><a href="#上包装" class="headerlink" title="上包装"></a>上包装</h3><p>可以把观点凝练成一句口诀，既好记，又有高度，这种方法为“卖点包装”</p><p>可以根据四种包装方法来进行包装</p><ul><li>简化</li><li>类比</li><li>整合</li><li>引用</li></ul><p><img src="/images/%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%8610.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;结构思考力三层次模型&quot;&gt;&lt;a href=&quot;#结构思考力三层次模型&quot; class=&quot;headerlink&quot; title=&quot;结构思考力三层次模型&quot;&gt;&lt;/a&gt;结构思考力三层次模型&lt;/h2&gt;&lt;h3 id=&quot;三层模型&quot;&gt;&lt;a href=&quot;#三层模型&quot; class=&quot;head</summary>
      
    
    
    
    <category term="通用能力" scheme="http://yoursite.com/categories/%E9%80%9A%E7%94%A8%E8%83%BD%E5%8A%9B/"/>
    
    
    <category term="通用能力" scheme="http://yoursite.com/tags/%E9%80%9A%E7%94%A8%E8%83%BD%E5%8A%9B/"/>
    
  </entry>
  
  <entry>
    <title>单元测试-Spock</title>
    <link href="http://yoursite.com/2021/08/25/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-Spock/"/>
    <id>http://yoursite.com/2021/08/25/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-Spock/</id>
    <published>2021-08-25T03:22:37.000Z</published>
    <updated>2021-11-06T06:04:57.001Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>单元测试的重要性不言而喻，但在实际开发中单元测试往往都是缺失的，原因有很多，其中比较重要的一点是工期短、写单测耗时长</p><p>针对这种问题，为了提高写单测的效率，推荐 Spock 测试框架，改善单测体验、解放生产力~</p><h1 id="Spock是什么"><a href="#Spock是什么" class="headerlink" title="Spock是什么"></a>Spock是什么</h1><p>官网：<a href="https://spockframework.org/">https://spockframework.org/</a></p><h2 id="Spock简介"><a href="#Spock简介" class="headerlink" title="Spock简介"></a>Spock简介</h2><p>官方介绍：</p><blockquote><p>Spock is a testing and specification framework for Java and Groovy applications. What makes it stand out from the crowd is its beautiful and highly expressive specification language. Thanks to its JUnit runner, Spock is compatible with most IDEs, build tools, and continuous integration servers. Spock is inspired from JUnit, jMock, RSpec, Groovy, Scala, Vulcans, and other fascinating life forms.</p></blockquote><p>简单来说，<code>Spock</code> 是一个测试框架，有以下几个核心特点：</p><ul><li>可以应用于 <code>java</code> 或 <code>groovy</code> 应用的单元测试框架。</li><li>测试代码使用基于 <code>groovy</code> 语言扩展而成的规范说明语言（<code>specification language</code>）。</li><li>遵从 BDD（行为驱动开发）模式，有助于提升代码的质量。</li><li>通过 <code>junit runner</code> 调用测试，兼容绝大部分 <code>junit</code> 的运行场景（ide，构建工具，持续集成等）。</li><li>框架的设计思路参考了 <code>JUnit</code>，<code>jMock</code>，<code>RSpec</code>，<code>Groovy</code>，<code>Scala</code>，<code>Vulcans</code>……</li></ul><h2 id="与其他框架对比"><a href="#与其他框架对比" class="headerlink" title="与其他框架对比"></a>与其他框架对比</h2><p><img src="/images/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-Spock0.jpeg"></p><p><code>Spock</code> = 传统测试框架 + <code>Mock</code>+ <code>BDD</code> + 文档化</p><blockquote><p>代码规范化，结构层次清晰</p><p>简单易读、可维护性强</p><p>基于 <code>Groovy</code> 更快的写单侧</p><p>漂亮的参数化测试和异常测试<br><img src="/images/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-Spock1.png"></p></blockquote><p>缺点：</p><blockquote><p>偶尔有坑（版本不兼容等）</p><p>需要了解 <code>Groovy</code> 语言</p><p>与其它 java 测试框架风格相差比较大，需要适应</p></blockquote><p>而这些理由比起 <code>Spock</code> 提供的易于开发和维护的单元测试代码来说，是可以忽略的。。。</p><h1 id="Groovy"><a href="#Groovy" class="headerlink" title="Groovy"></a>Groovy</h1><p>使用 <code>Spock</code> 前先了解下 <code>Groovy</code></p><p>维基百科介绍：</p><blockquote><p>Groovy是Java平台上设计的面向对象编程语言。这门动态语言拥有类似Python、Ruby和Smalltalk中的一些特性，可以作为Java平台的脚本语言使用。</p></blockquote><p><code>Groovy</code> 的语法与 <code>Java</code> 非常相似，以至于多数的 <code>Java</code> 代码也是正确的 <code>Groovy</code> 代码。<code>Groovy</code> 代码动态的被编译器转换成 <code>Java</code> 字节码。由于其运行在JVM上的特性，<code>Groovy</code> 可以使用其他 <code>Java</code> 语言编写的库。</p><p>虽然需要了解 <code>Groovy</code>，但不用担心，<code>Groovy</code> 是一门比较轻量，学习门槛也比较低的语言，而且最重要的是 <code>Groovy</code> 支持 <code>Java</code> 语法，所以理论上使用纯 <code>Java</code> 写 <code>Groovy</code> 也是可以的~</p><p>而且熟悉使用 <code>Spock</code> 后，不仅提升了写单测的速度，还多学了一门脚本语言，两全其美~~</p><h2 id="Groovy-语法糖"><a href="#Groovy-语法糖" class="headerlink" title="Groovy 语法糖"></a>Groovy 语法糖</h2><p><img src="/images/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-Spock2.png"><br><img src="/images/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-Spock3.png"><br><img src="/images/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-Spock4.png"></p><blockquote><p>不用分号</p><p>可选择性使用 <code>return</code></p><p>默认采用 <code>public</code> 修饰符</p><p><code>==</code> 与 <code>equals</code></p></blockquote><p>更多语法参考推荐文档。。。</p><h2 id="Groovy-推荐文档"><a href="#Groovy-推荐文档" class="headerlink" title="Groovy 推荐文档"></a>Groovy 推荐文档</h2><p><a href="https://groovy-lang.org/documentation.html">https://groovy-lang.org/documentation.html</a></p><p><a href="https://sysgears.com/articles/groovy-differences-java/">https://sysgears.com/articles/groovy-differences-java/</a></p><p><a href="https://wiki.jikexueyuan.com/project/groovy-introduction/differences-with-java.html">https://wiki.jikexueyuan.com/project/groovy-introduction/differences-with-java.html</a></p><h1 id="使用Spock"><a href="#使用Spock" class="headerlink" title="使用Spock"></a>使用Spock</h1><blockquote><p>Spock Web Console</p><p><a href="https://meetspock.appspot.com/">https://meetspock.appspot.com/</a></p></blockquote><h2 id="使用姿势"><a href="#使用姿势" class="headerlink" title="使用姿势"></a>使用姿势</h2><ul><li><p>安装 IDE 插件</p><p><img src="/images/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-Spock5.png"></p></li><li><p>maven 引用</p><blockquote><p>建议使用 1.3-groovy-2.4 版本，其他版本可能与其他包有兼容问题</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.spockframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spock-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3-groovy-2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.spockframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spock-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3-groovy-2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建 Groovy 测试目录</p><p><img src="/images/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-Spock6.png"></p></li><li><p>编写测试代码</p><p><img src="/images/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-Spock7.png"></p></li></ul><p>创建测试类时可以这俩个，<code>Spock Specification</code> 会自动继承 <code>Specification</code>，<code>Groovy Class</code> 需要自己继承</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> spock.lang.Specification</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpockDemo</span> <span class="keyword">extends</span> <span class="title">Specification</span> </span>&#123; </span><br><span class="line">    def <span class="string">&quot;test&quot;</span>() &#123;</span><br><span class="line">        given: <span class="string">&quot;数据准备&quot;</span></span><br><span class="line">      def list = []</span><br><span class="line">        </span><br><span class="line">        when: <span class="string">&quot;执行需要测试的代码&quot;</span></span><br><span class="line">        list.add(<span class="string">&quot;test&quot;</span>)</span><br><span class="line"></span><br><span class="line">        then: <span class="string">&quot;验证执行结果&quot;</span></span><br><span class="line">        !list.empty </span><br><span class="line">        stack.size() == <span class="number">1</span>   </span><br><span class="line">    &#125;   </span><br><span class="line">    </span><br><span class="line">    def <span class="string">&quot;测试&quot;</span>() &#123;</span><br><span class="line">        expect:</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="集成-Spring"><a href="#集成-Spring" class="headerlink" title="集成 Spring"></a>集成 Spring</h2><p>和 Junit 集成的方式一样</p><ul><li><p>Spring</p><p><code>@ContextConfiguration(locations = &quot;classpath:spring-context.xml&quot;)</code></p></li><li><p>SpringBoot</p><p><code>@SpringBootTest</code></p></li></ul><h2 id="Spock中的概念"><a href="#Spock中的概念" class="headerlink" title="Spock中的概念"></a>Spock中的概念</h2><ul><li><p>Specification</p><p>在 <code>Spock</code> 中，待测系统的行为是由规格(specification) 所定义的。在使用 <code>Spock</code> 框架编写测试时，测试类需要继承自 <code>Specification</code> 类。</p></li><li><p>模板方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def setup() &#123;&#125;          &#x2F;&#x2F; run before every feature method</span><br><span class="line">def cleanup() &#123;&#125;        &#x2F;&#x2F; run after every feature method</span><br><span class="line">def setupSpec() &#123;&#125;     &#x2F;&#x2F; run before the first feature method</span><br><span class="line">def cleanupSpec() &#123;&#125;   &#x2F;&#x2F; run after the last feature method</span><br></pre></td></tr></table></figure><p>和 Junit 对比：</p><table><thead><tr><th>Spock</th><th>Junit</th></tr></thead><tbody><tr><td>setup()</td><td>@Before</td></tr><tr><td>cleanup()</td><td>@After</td></tr><tr><td>setupSpec()</td><td>@BeforeClass</td></tr><tr><td>cleanupSpec()</td><td>@AfterClass</td></tr></tbody></table></li><li><p>Feature methods</p><p>就是测试类中的测试方法，方法名可以是中文</p></li><li><p>blocks</p><p>每个测试方法又被划分为不同的 <code>block</code>，不同的 <code>block</code> 处于测试执行的不同阶段，在测试运行时，各个 <code>block</code> 按照不同的顺序和规则被执行，如下图：</p><p><img src="/images/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-Spock8.png"></p><blockquote><p><code>Spock</code> 定义了多种标签，去描述代码“应该做什么”，“输入条件是什么”，“输出是否符合预期”，从语义层面规范了代码的编写</p></blockquote><p><strong>setup</strong>：也可以写成 <code>given</code>，在这个 <code>block</code> 中会放置与这个测试方法相关的初始化程序，可选</p><p><strong>given</strong>：输入条件（前置参数），一般会在这个 <code>block</code> 中定义局部变量，<code>mock</code> 等，可选</p><p><strong>when</strong>、<code>then</code>：<code>when</code> 与 <code>then</code> 需要搭配使用，一起出现，在 <code>when</code> 中执行待测试的函数，在 <code>then</code> 中判断是否符合预期</p><p><strong>expect</strong>：可以看做精简版的 when+then</p><p><strong>and</strong>：衔接上个标签，补充的作用</p><p><strong>cleanup</strong>：退出前做一些清理工作，如关闭资源等</p><p><strong>where</strong>：做测试时最复杂的事情之一就是准备测试数据，尤其是要测试边界条件、测试异常分支等，这些都需要在测试之前规划好数据。但是传统的测试框架很难轻松的制造数据，要么依赖反复调用，要么使用其他丑陋的方式；在 <code>Spock</code> 中 <code>where</code> 完美解决了这个问题，<code>where</code> 可以说是 <code>Spock</code> 的核心，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* where 有两种写法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpockDemo</span> <span class="keyword">extends</span> <span class="title">Specification</span> </span>&#123;</span><br><span class="line">    def <span class="string">&quot;max&quot;</span>() &#123;</span><br><span class="line">        expect:</span><br><span class="line">        Math.max(a, b) == c</span><br><span class="line"></span><br><span class="line">        where: <span class="string">&quot;多个列使用 | 单竖线隔开，|| 双竖线区分输入和输出变量，即左边是输入值，右边是输出值&quot;</span></span><br><span class="line">        a | b || c</span><br><span class="line">        <span class="number">3</span> | <span class="number">5</span> || <span class="number">5</span></span><br><span class="line">        <span class="number">7</span> | <span class="number">0</span> || <span class="number">7</span></span><br><span class="line">        <span class="number">0</span> | <span class="number">0</span> || <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpockDemo</span> <span class="keyword">extends</span> <span class="title">Specification</span> </span>&#123;</span><br><span class="line">    def <span class="string">&quot;max&quot;</span>() &#123;</span><br><span class="line">        expect:</span><br><span class="line">        Math.max(a, b) == c</span><br><span class="line"></span><br><span class="line">        where:</span><br><span class="line">        a &lt;&lt; [<span class="number">3</span>, <span class="number">7</span>, <span class="number">0</span>]</span><br><span class="line">        b &lt;&lt; [<span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">        c &lt;&lt; [<span class="number">5</span>, <span class="number">7</span>, <span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><p>在 <code>then</code> 或 <code>expect</code> 中会默认 <code>assert</code> 所有返回值是 <code>boolean</code> 型的语句，所以在 <code>then</code> 和 <code>expect</code> 语句块中不需要写 <code>assert</code></p><p>如果要在其它地方增加断言，需要显式增加 <code>assert</code> 关键字，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  stack = <span class="keyword">new</span> Stack()</span><br><span class="line">  <span class="keyword">assert</span> stack.empty</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="with"><a href="#with" class="headerlink" title="with"></a>with</h3><p><code>with</code> 语句可以验证对象内部的多个属性是否符合预期值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">expect:</span><br><span class="line">with(response) &#123;</span><br><span class="line">  code == <span class="number">0</span></span><br><span class="line">  message == <span class="string">&quot;成功&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异常断言"><a href="#异常断言" class="headerlink" title="异常断言"></a>异常断言</h3><p>验证有没有抛出异常，可以用 <code>thrown()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def <span class="string">&quot;test&quot;</span>() &#123;</span><br><span class="line">  given:</span><br><span class="line">  def str = <span class="keyword">null</span></span><br><span class="line"></span><br><span class="line">  when:</span><br><span class="line">  str.add(<span class="string">&quot;test&quot;</span>)</span><br><span class="line"></span><br><span class="line">  then:</span><br><span class="line">  thrown(NullPointerException)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>要验证没有抛出某种异常，可以用 <code>notThrown()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def <span class="string">&quot;test&quot;</span>() &#123;</span><br><span class="line">  given:</span><br><span class="line">  def str = []</span><br><span class="line"></span><br><span class="line">  when:</span><br><span class="line">  str.add(<span class="string">&quot;test&quot;</span>)</span><br><span class="line"></span><br><span class="line">  then:</span><br><span class="line">  notThrown(NullPointerException)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Annotation"><a href="#Annotation" class="headerlink" title="Annotation"></a>Annotation</h2><table><thead><tr><th>注解</th><th>用途</th><th>样例</th></tr></thead><tbody><tr><td>Shared</td><td>在多个测试间共享变量</td><td>@Shared def h2 = new H2Database()</td></tr><tr><td>AutoCleanUp</td><td>测试结束后回收资源，不管是否发生异常等</td><td>@AutoCleanup(“shutdown”) def executor = new Executor()</td></tr><tr><td>Ignore</td><td>忽略这个测试</td><td></td></tr><tr><td>IgnoreIf</td><td>忽略满足条件的测试</td><td>@IgnoreIf(os.isWindows())</td></tr><tr><td>IgnoreRest</td><td>只运行这个测试</td><td></td></tr><tr><td>Requries</td><td>满足设定的条件才运行这个测试</td><td>@Requires({env.containsKey(“HASH_KEY_TO_AUTHENTICATE”)})</td></tr><tr><td>Unroll</td><td>配合数据表的时候，每行运行一个测试</td><td></td></tr><tr><td>FailsWith</td><td>运行测试必然抛出某个异常</td><td></td></tr><tr><td>Issue</td><td>指明这个测试对应某个issue</td><td>@Issue(“<a href="http://redmine.example.com/issues/2554&quot;">http://redmine.example.com/issues/2554&quot;</a>)</td></tr><tr><td>Timeout</td><td>如果运行时间超过某个阈值，则判定为失败</td><td>@Timeout(value = 5000, unit = TimeUnit.MILLISECONDS)</td></tr><tr><td>Title</td><td>设定一个更容易理解的标题名</td><td>@Title(”测试在》繁忙情况下》发红包”)</td></tr></tbody></table><h1 id="Mock"><a href="#Mock" class="headerlink" title="Mock"></a>Mock</h1><blockquote><p><code>Spock</code> 自带 <code>Mock</code> 功能，使用简单方便，同时也支持扩展第三方 <code>Mock</code> 框架，比如 <code>PowerMock</code></p></blockquote><h2 id="SpockMock"><a href="#SpockMock" class="headerlink" title="SpockMock"></a>SpockMock</h2><h3 id="Mock-1"><a href="#Mock-1" class="headerlink" title="Mock"></a>Mock</h3><p>创建一个假对象，验证是否执行了某些操作(在 <code>then</code> 或 <code>expect</code> 语句块中)</p><ul><li><p>创建一个 <code>Mock</code> 对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PublisherSpec</span> <span class="keyword">extends</span> <span class="title">Specification</span> </span>&#123;</span><br><span class="line">    Publisher publisher = <span class="keyword">new</span> Publisher()</span><br><span class="line">    <span class="comment">// def subscriber = Mock(Subscriber)</span></span><br><span class="line">    Subscriber subscriber = Mock()</span><br><span class="line">    <span class="comment">// def subscriber2 = Mock(Subscriber)</span></span><br><span class="line">    Subscriber subscriber2 = Mock()</span><br><span class="line"></span><br><span class="line">    <span class="function">def <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        publisher.subscribers.add(subscriber)</span><br><span class="line">        publisher.subscribers.add(subscriber2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>交互验证</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def <span class="string">&quot;should send messages to all subscribers&quot;</span>() &#123;</span><br><span class="line">    when:</span><br><span class="line">    publisher.send(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"></span><br><span class="line">    then:</span><br><span class="line">    <span class="number">1</span> * subscriber.receive(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">    <span class="number">1</span> * subscriber2.receive(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 publisher 调用 send 时，两个 subscriber 都应该被调用一次 receive(“hello”)</p></li><li><p>示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> * subscriber.receive(<span class="string">&quot;hello&quot;</span>)      <span class="comment">// exactly one call</span></span><br><span class="line"><span class="number">0</span> * subscriber.receive(<span class="string">&quot;hello&quot;</span>)      <span class="comment">// zero calls</span></span><br><span class="line">(<span class="number">1.</span><span class="number">.3</span>) * subscriber.receive(<span class="string">&quot;hello&quot;</span>) <span class="comment">// between one and three calls (inclusive)</span></span><br><span class="line">(<span class="number">1.</span>._) * subscriber.receive(<span class="string">&quot;hello&quot;</span>) <span class="comment">// at least one call</span></span><br><span class="line">(_.<span class="number">.3</span>) * subscriber.receive(<span class="string">&quot;hello&quot;</span>) <span class="comment">// at most three calls</span></span><br><span class="line">_ * subscriber.receive(<span class="string">&quot;hello&quot;</span>)      <span class="comment">// any number of calls, including zero</span></span><br><span class="line"><span class="number">1</span> * subscriber.receive(<span class="string">&quot;hello&quot;</span>)     <span class="comment">// an argument that is equal to the String &quot;hello&quot;</span></span><br><span class="line"><span class="number">1</span> * subscriber.receive(!<span class="string">&quot;hello&quot;</span>)    <span class="comment">// an argument that is unequal to the String &quot;hello&quot;</span></span><br><span class="line"><span class="number">1</span> * subscriber.receive()            <span class="comment">// the empty argument list (would never match in our example)</span></span><br><span class="line"><span class="number">1</span> * subscriber.receive(_)           <span class="comment">// any single argument (including null)</span></span><br><span class="line"><span class="number">1</span> * subscriber.receive(*_)          <span class="comment">// any argument list (including the empty argument list)</span></span><br><span class="line"><span class="number">1</span> * subscriber.receive(!<span class="keyword">null</span>)       <span class="comment">// any non-null argument</span></span><br><span class="line"><span class="number">1</span> * subscriber.receive(_ as String) <span class="comment">// any non-null argument that is-a String</span></span><br><span class="line"><span class="number">1</span> * subscriber.receive(&#123; it.size() &gt; <span class="number">3</span> &#125;) <span class="comment">// an argument that satisfies the given predicate</span></span><br><span class="line">                                          <span class="comment">// (here: message length is greater than 3)</span></span><br><span class="line"><span class="number">1</span> * subscriber._(*_)     <span class="comment">// any method on subscriber, with any argument list</span></span><br><span class="line"><span class="number">1</span> * subscriber._         <span class="comment">// shortcut for and preferred over the above</span></span><br><span class="line"><span class="number">1</span> * _._                  <span class="comment">// any method call on any mock object</span></span><br><span class="line"><span class="number">1</span> * _                    <span class="comment">// shortcut for and preferred over the above</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Stubbing"><a href="#Stubbing" class="headerlink" title="Stubbing"></a>Stubbing</h3><p>调用 <code>Mock</code> 对象的某个方法时返回特定的值</p><ul><li><p>调用返回指定值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subscriber.receive(_) &gt;&gt; <span class="string">&quot;ok&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>调用多次返回不同的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">subscriber.receive(_) &gt;&gt;&gt; [<span class="string">&quot;ok&quot;</span>, <span class="string">&quot;error&quot;</span>, <span class="string">&quot;error&quot;</span>, <span class="string">&quot;ok&quot;</span>]</span><br><span class="line">subscriber.receive(_) &gt;&gt; <span class="string">&quot;ok&quot;</span> &gt;&gt; <span class="string">&quot;error&quot;</span> &gt;&gt; <span class="string">&quot;error&quot;</span> &gt;&gt; <span class="string">&quot;ok&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>希望抛出异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subscriber.receive(_) &gt;&gt; &#123; <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">&quot;ouch&quot;</span>) &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Mock、Stubbing结合"><a href="#Mock、Stubbing结合" class="headerlink" title="Mock、Stubbing结合"></a>Mock、Stubbing结合</h3><p>如果既要判断某个 <code>mock</code> 对象的交互，又希望它返回值的话，可以结合 <code>mock</code> 和 <code>stub</code>，可以这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">then:</span><br><span class="line"><span class="number">1</span> * subscriber.receive(<span class="string">&quot;message1&quot;</span>) &gt;&gt; <span class="string">&quot;ok&quot;</span></span><br><span class="line"><span class="number">1</span> * subscriber.receive(<span class="string">&quot;message2&quot;</span>) &gt;&gt; <span class="string">&quot;fail&quot;</span></span><br></pre></td></tr></table></figure><p>一般使用 <code>Spock</code> 自带的 <code>Mock</code> 就够了，但是 <code>Spock</code> 的 <code>Mock</code> 也有着常见缺陷，既不能 <code>Mock</code> 私有方法和静态方法</p><p>针对这种情况，业界之前常见的是使用 <code>PowerMock</code> 来 <code>Mock</code>，但是 <code>PowerMock</code> 上手难度较高、且使用复杂</p><p>相比 <code>Spock</code> + <code>PowerMock</code>，推荐 <code>Spock</code> + <code>TestableMock</code> 来 <code>Mock</code>，快速上手、使用简单</p><h2 id="TestableMock"><a href="#TestableMock" class="headerlink" title="TestableMock"></a>TestableMock</h2><p><code>TestableMock</code>，阿里新一代测试工具，一款特立独行的轻量Mock工具。</p><p>官网：<a href="https://alibaba.github.io/testable-mock/#/">https://alibaba.github.io/testable-mock/#/</a></p><p>常见 Mock 工具对比：</p><table><thead><tr><th>工具</th><th>原理</th><th>最小Mock单元</th><th>对被Mock方法的限制</th><th>上手难度</th><th>IDE支持</th></tr></thead><tbody><tr><td>Mockito</td><td>动态代理</td><td>类</td><td>不能Mock私有/静态和构造方法</td><td>较容易</td><td>很好</td></tr><tr><td>Spock</td><td>动态代理</td><td>类</td><td>不能Mock私有/静态和构造方法</td><td>较复杂</td><td>一般</td></tr><tr><td>PowerMock</td><td>自定义类加载器</td><td>类</td><td>任何方法皆可</td><td>较复杂</td><td>较好</td></tr><tr><td>JMockit</td><td>运行时字节码修改</td><td>类</td><td>不能Mock构造方法(new操作符)</td><td>较复杂</td><td>一般</td></tr><tr><td>TestableMock</td><td>运行时字节码修改</td><td>方法</td><td>任何方法皆可</td><td>很容易</td><td>一般</td></tr></tbody></table><p>TestableMock 功能：</p><ul><li><a href="https://alibaba.github.io/testable-mock/#/zh-cn/doc/use-mock">快速Mock任意调用</a>：使被测类的任意方法调用快速替换为Mock方法，实现”指哪换哪”，解决传统Mock工具使用繁琐的问题</li><li><a href="https://alibaba.github.io/testable-mock/#/zh-cn/doc/private-accessor">访问被测类私有成员</a>：使单元测试能直接调用和访问被测类的私有成员，解决私有成员初始化和私有方法测试的问题</li><li><a href="https://alibaba.github.io/testable-mock/#/zh-cn/doc/omni-constructor">快速构造参数对象</a>：生成任意复杂嵌套的对象实例，并简化其内部成员赋值方式，解决被测方法参数初始化代码冗长的问题</li><li><a href="https://alibaba.github.io/testable-mock/#/zh-cn/doc/test-void-method">辅助测试void方法</a>：利用Mock校验器对方法的内部逻辑进行检查，解决无返回值方法难以实施单元测试的问题</li></ul><p>不足：</p><p>当前 <code>TestableMock</code> 的主要不足在于，编写 <code>Mock</code> 方法时 IDE 无法即时提示方法参数是否正确匹配。若发现匹配效果不符合预期，需要通过<a href="https://alibaba.github.io/testable-mock/#/zh-cn/doc/troubleshooting">自助问题排查</a>文档提供的方法在运行期进行校验</p><h1 id="推荐文档"><a href="#推荐文档" class="headerlink" title="推荐文档"></a>推荐文档</h1><ul><li><p>官方文档<br><a href="https://spockframework.org/spock/docs/2.0/all_in_one.html">https://spockframework.org/spock/docs/2.0/all_in_one.html</a></p></li><li><p>美团技术博客<br><a href="https://tech.meituan.com/2021/08/06/spock-practice-in-meituan.html">https://tech.meituan.com/2021/08/06/spock-practice-in-meituan.html</a></p></li><li><p>其他技术博客<br><a href="https://javakk.com/category/spock">https://javakk.com/category/spock</a></p></li><li><p>Java Testing with Spock<br><a href="https://github.com/kkapelon/java-testing-with-spock">https://github.com/kkapelon/java-testing-with-spock</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;单元测试的重要性不言而喻，但在实际开发中单元测试往往都是缺失的，原因有很多，其中比较重要的一点是工期短、写单测耗时长&lt;/p&gt;
&lt;p&gt;针对这种</summary>
      
    
    
    
    <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Code Review</title>
    <link href="http://yoursite.com/2021/06/19/Code%20Review/"/>
    <id>http://yoursite.com/2021/06/19/Code%20Review/</id>
    <published>2021-06-19T03:22:37.000Z</published>
    <updated>2021-11-06T06:03:09.657Z</updated>
    
    <content type="html"><![CDATA[<h2 id="认识-Code-Review"><a href="#认识-Code-Review" class="headerlink" title="认识 Code Review"></a>认识 Code Review</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>Code Review是一种用来确认方案设计和代码实现的质量保证机制，通过这个机制对代码、测试过程和注释进行检查，确保整体代码运行状况随着时间的推移而得到改善。</p><h3 id="目的和意义"><a href="#目的和意义" class="headerlink" title="目的和意义"></a>目的和意义</h3><ul><li>目的：代码质量、知识共享、团队规范</li><li>意义：<ul><li>查找系统和代码的缺陷，把控风险</li><li>保证代码整体健康度不会随时间的推移而降低</li><li>提高开发者自身水平</li></ul></li></ul><h3 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h3><p>常见的 Code Review 有下面几种方式</p><blockquote><p>结对编程(瞬时评审)</p></blockquote><ul><li>一对一的共同编程</li><li>场景：复杂的业务问题、或紧急问题的修复</li></ul><blockquote><p>即时代码评审(同步评审)</p></blockquote><ul><li>提交人给审核人讲解任务详情、改动等</li><li>场景：不清楚任务目标、或高级指导低级</li></ul><blockquote><p>工具支持的代码评审(异步评审)</p></blockquote><ul><li>和开发流集成，只有 Review 通过才能合并</li><li>默认的方式，也是最常用的</li></ul><blockquote><p>基于会议的代码评审(偶尔评审)</p></blockquote><ul><li>组织会议，团队多人共同评审</li><li>场景：大型、比较复杂的项目；有一定风险的项目；为了提高整体水平</li></ul><h3 id="不做-Code-Review-的典型场景"><a href="#不做-Code-Review-的典型场景" class="headerlink" title="不做 Code Review 的典型场景"></a>不做 Code Review 的典型场景</h3><ul><li>不认同，团队整体意识不到位</li><li>需求多，时间紧，疲于应付需求</li><li>技术水平不足，无法给出有效意见</li></ul><h3 id="Code-Review-常见问题"><a href="#Code-Review-常见问题" class="headerlink" title="Code Review 常见问题"></a>Code Review 常见问题</h3><blockquote><p>提交人</p></blockquote><ul><li>提交大量代码评审</li><li>发起评审前没有进行自测</li><li>不进行评审，直接上线</li><li>没有给评审人留够充裕的时间</li></ul><blockquote><p>评审人</p></blockquote><ul><li>Review 不仔细，产生低级的问题</li><li>对业务不熟悉，无法判断影响面</li><li>反馈时机长，不及时处理提交人提交的 Code Review</li></ul><blockquote><p>全体</p></blockquote><ul><li>没有规范的 Code Review 机制和自测机制</li></ul><h2 id="如何做好-Code-Review"><a href="#如何做好-Code-Review" class="headerlink" title="如何做好 Code Review"></a>如何做好 Code Review</h2><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>要避免 Code Review 流于形式，而避免流于形式的关键点则是 <strong>大家都有主观意愿，并且客观条件允许</strong></p><p>要有代码规范、Check list、总结优化、激励机制</p><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+-------+      +---------+      +---------+      +---------+      +-----+      +------------+</span><br><span class="line">| 定标准 | +--&gt; | 全员学习 | +--&gt; | 需求梳理  | +--&gt; | 代码评审 | +--&gt; | 讨论 | +--&gt; | 评审结果落地 |</span><br><span class="line">+-------+      +---------+      +---------+      +---------+      +-----+      +------------+ </span><br></pre></td></tr></table></figure><ol><li>定标准<ul><li>目的：有法可依、团队一致</li><li>内容：<ul><li>共识标准：权利责任标准、冲突处理标准、特例紧急case处理标准、检查单标准</li><li>提交人标准：发起时机标准、选择评审人标准、Commit 标准、代码标准、合并分支标准、处理评论标准</li><li>评审人标准：检查内容标准、可通过标准、评论标准、反馈周期标准</li></ul></li></ul></li><li>全员学习<ul><li>目的：统一思想、确认标准可落地</li></ul></li><li>需求梳理<ul><li>统一对需求理解，设计评审有理可依</li><li>内容：<ul><li>提交人要有基于需求的代码改动设计方案</li><li>评审人要有基于需求理解之下的代码改造意见</li></ul></li></ul></li><li>代码评审<ul><li>目的：实现正确的业务需求，代码长期的可维护性</li><li>内容：参照检查单（功能拆解；架构设计；代码逻辑；库表设计；编码风格；性能；等等）</li><li>工具：<a href="http://www.sonar.org.cn/">Sonar</a>、<a href="https://www.gerritcodereview.com/">Gerrit</a> 等工具</li></ul></li><li>讨论<ul><li>目的：达成共识，求同存异</li></ul></li><li>评审结果落地<ul><li>总结归纳，持续优化标准</li></ul></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Code Review 是提高代码质量、把控项目风险的一剂良药，同时也是提高个人水平的一个重要渠道。而长期维持良好的 Code Review 并不容易，但是良好的 Code Review 是个人和团队成功不可或缺的一环。</p><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><p>GoogleCR机制（原文）：<a href="https://google.github.io/eng-practices/review/reviewer/">https://google.github.io/eng-practices/review/reviewer/</a></p><p>GoogleCR机制（翻译版）：<a href="https://cloud.tencent.com/developer/article/1514271">https://cloud.tencent.com/developer/article/1514271</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;认识-Code-Review&quot;&gt;&lt;a href=&quot;#认识-Code-Review&quot; class=&quot;headerlink&quot; title=&quot;认识 Code Review&quot;&gt;&lt;/a&gt;认识 Code Review&lt;/h2&gt;&lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot;</summary>
      
    
    
    
    <category term="规范" scheme="http://yoursite.com/categories/%E8%A7%84%E8%8C%83/"/>
    
    
    <category term="规范" scheme="http://yoursite.com/tags/%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>Netty-BetyBuf</title>
    <link href="http://yoursite.com/2021/06/11/Netty-BetyBuf/"/>
    <id>http://yoursite.com/2021/06/11/Netty-BetyBuf/</id>
    <published>2021-06-11T07:55:37.000Z</published>
    <updated>2021-06-21T02:17:02.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>ByteBuf 是 Netty 中的数据交互单位，本质是一个 Byte 数组的缓冲区，有不同实现机制，首先看 ByteBuf 的数据结构</p></blockquote><h3 id="ByteBuf结构"><a href="#ByteBuf结构" class="headerlink" title="ByteBuf结构"></a>ByteBuf结构</h3><pre><code>+-------------------+------------------+------------------+| discardable bytes |  readable bytes  |  writable bytes  ||                   |     (CONTENT)    |                  |+-------------------+------------------+------------------+|                   |                  |                  |0      &lt;=      readerIndex   &lt;=   writerIndex    &lt;=    capacity</code></pre><p>ByteBuf 包括三部分，丢弃字节、可读字节、可写字节</p><p>通过两个指针，读指针（readerIndex）和写指针（writerIndex）来分成三部分，当 readerIndex = writerIndex 时不可读，当 writerIndex = capacity 时不可写。还有个参数 maxCapacity，当写入数据容量不足时会自动扩容，扩容的最大容量为 maxCapacity 值</p><h3 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h3><h4 id="容量API"><a href="#容量API" class="headerlink" title="容量API"></a>容量API</h4><ul><li><p><code>capacity()</code></p><p>表示 ByteBuf 的占用字节内存，包括丢弃字节、可读字节、可写字节，不同的底层实现机制有不同的计算方式</p></li><li><p><code>maxCapacity()</code>  </p><p>表示 ByteBuf 最大能够占用多少字节的内存</p></li><li><p><code>readableBytes()</code></p><p>ByteBuf 当前可读的字节数，它的值等于 writerIndex-readerIndex</p></li><li><p><code>isReadable()</code></p><p>返回是否可读，writerIndex = readerIndex 则不可读，返回 <code>false</code></p></li><li><p><code>writableBytes()</code></p><p>ByteBuf 当前可写的字节数，它的值等于 capacity-writerIndex</p></li><li><p><code>isWritable()</code></p><p>返回是否可写，capacity = writerIndex 则不可写</p></li><li><p><code>maxWritableBytes()</code></p><p>ByteBuf 可写的最大字节数，它的值等于 maxCapacity-writerIndex</p></li></ul><h4 id="指针相关API"><a href="#指针相关API" class="headerlink" title="指针相关API"></a>指针相关API</h4><ul><li><p><code>readerIndex()</code></p><p>返回当前读指针的 readerIndex</p></li><li><p><code>readerIndex(int)</code></p><p>设置读指针</p></li><li><p><code>writeIndex()</code></p><p>返回当前写指针的 writerIndex</p></li><li><p><code>writeIndex(int)</code></p><p>设置读指针</p></li><li><p><code>markReaderIndex()</code>、<code>markWriterIndex()</code></p><p>把当前的读、写指针保存起来</p></li><li><p><code>resetReaderIndex()</code>、<code>resetWriterIndex()</code></p><p>把当前的读、写指针恢复到之前保存的值</p></li></ul><h4 id="读写API"><a href="#读写API" class="headerlink" title="读写API"></a>读写API</h4><ul><li><p><code>writeBytes(byte[] src)</code></p><p>把字节数组 src 里面的数据全部写到 ByteBuf，src 字节数组大小的长度通常小于等于 <code>writableBytes()</code></p></li><li><p><code>readBytes(byte[] dst)</code></p><p>把 ByteBuf 里面的数据全部读取到 dst，这里 dst 字节数组的大小通常等于 <code>readableBytes()</code></p></li><li><p><code>writeByte(byte b)</code></p><p>表示往 ByteBuf 中写一个字节，类似还有 <code>writeBoolean()</code>、<code>writeChar()</code>、<code>writeShort()</code>、<code>writeInt()</code>、<code>writeLong()</code>、<code>writeFloat()</code>、<code>writeDouble()</code> </p></li><li><p><code>readByte()</code></p><p>表示从 ByteBuf 中读取一个字节，类似还有  <code>readBoolean()</code>、<code>readChar()</code>、<code>readShort()</code>、<code>readInt()</code>、<code>readLong()</code>、<code>readFloat()</code>、<code>readDouble()</code></p></li><li><p><code>setBytes()</code>、<code>setByte()</code></p><p>和 <code>writeBytes()</code> 等方法类似，但是 set 不会改变读写指针，而 write 会改变写指针</p></li><li><p><code>getBytes</code>、<code>getByte()</code></p><p>和 <code>readBytes()</code> 等方法类似，同样 get 不会改变读写指针，而 read 会改变读指针</p></li><li><p><code>retain()</code></p><p>将 BetyBuf 的引用计数加一</p></li><li><p><code>release()</code></p><p>将 ByteBuf 的引用计数减一，减完之后如果发现引用计数为0，则直接回收 ByteBuf 底层的内存</p></li></ul><blockquote><p>由于 Netty 使用了堆外内存，而堆外内存是不被 jvm 直接管理的，也就是说申请到的内存无法被垃圾回收器直接回收，所以需要我们手动回收。有点类似于c语言里面，申请到的内存必须手工释放，否则会造成内存泄漏。</p><p>Netty 的 ByteBuf 是通过引用计数的方式管理的，如果一个 ByteBuf 没有地方被引用到，需要回收底层内存。默认情况下，当创建完一个 ByteBuf，它的引用为1</p></blockquote><ul><li><p><code>slice()</code></p><p>从原始 ByteBuf 中截取一段，这段数据是从 readerIndex 到 writeIndex，同时，返回的新的 ByteBuf 的最大容量 maxCapacity 为原始 ByteBuf 的 <code>readableBytes()</code>；底层内存以及引用计数与原始的 ByteBuf 共享</p></li><li><p><code>duplicate()</code></p><p>把整个 ByteBuf 都截取出来，包括所有的指针信息。底层内存以及引用计数与原始的 ByteBuf 共享</p></li><li><p><code>copy()</code></p><p>从原始的 ByteBuf 中拷贝所有的信息，包括读写指针以及底层对应的数据，底层内存以及引用计数都独立，操作 ByteBuf 中的数据不会影响到原始的 ByteBuf </p></li></ul><blockquote><p>三个方法都会返回新的 ByteBuf 对象</p><p><code>slice()</code> 与 <code>duplicate()</code> 的相同点是：<strong>底层内存以及引用计数与原始的 ByteBuf 共享</strong>，也就是说经过 <code>slice()</code> 或者 <code>duplicate()</code> 返回的 ByteBuf 调用 write 系列方法都会影响到原始的 ByteBuf，但是它们都维持着与原始 ByteBuf 相同的内存引用计数和不同的读写指针 </p><p><code>slice()</code> 与 <code>duplicate()</code> 的不同点是：<code>slice()</code> 只截取从 readerIndex 到 writerIndex 之间的数据，它返回的 ByteBuf 的最大容量被限制到 原始 ByteBuf 的 <code>readableBytes()</code>, 而 <code>duplicate()</code> 是把整个 ByteBuf 都与原始的 ByteBuf 共享 </p><p><code>slice()</code> 和 <code>duplicate()</code> 不会改变 ByteBuf 的引用计数，所以原始的 ByteBuf 调用 <code>release()</code> 之后发现引用计数为零，就开始释放内存，调用这两个方法返回的 ByteBuf 也会被释放，这个时候如果再对它们进行读写，就会报错。因此，我们可以通过调用一次 <code>retain()</code> 方法 来增加引用，表示它们对应的底层的内存多了一次引用，引用计数为2，在释放内存的时候，需要调用两次 <code>release()</code> 方法，将引用计数降到零，才会释放内存</p><p><code>slice()</code> 、<code>duplicate()</code>、<code>copy()</code> 三个方法均维护着自己的读写指针，与原始的 ByteBuf 的读写指针无关，相互之间不受影响</p></blockquote><ul><li><p><code>retainedSlice()</code></p><p>截取内存片段的同时，增加内存的引用计数，等价于 <code>slice().retain()</code></p></li><li><p><code>retainedDuplicate()</code></p><p>也是截取内存片段的同时，增加内存的引用计数，等价于 <code>duplicate().retain()</code></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;ByteBuf 是 Netty 中的数据交互单位，本质是一个 Byte 数组的缓冲区，有不同实现机制，首先看 ByteBuf 的数据结构&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;ByteBuf结构&quot;&gt;&lt;a href=&quot;#ByteBuf结</summary>
      
    
    
    
    <category term="Netty" scheme="http://yoursite.com/categories/Netty/"/>
    
    
    <category term="Netty" scheme="http://yoursite.com/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot自动配置</title>
    <link href="http://yoursite.com/2021/06/04/SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2021/06/04/SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/</id>
    <published>2021-06-04T07:20:28.000Z</published>
    <updated>2021-06-06T11:38:59.292Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>SpringBoot的一个很重要的特性就是自动配置，使用注解，让服务不再需要xml等各种配置文件<br>然后使用main方法一键启动</p></blockquote><h2 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h2><p><code>@SpringBootApplication</code> 注解是 SpringBoot 的源头，一切都要从该注解开始说起</p><p>标注在类上时，表示该类是 SpringBoot 的主配置类，并从该类中的 <code>main</code> 方法来启动 SpringBoot 应用</p><p>注解源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(excludeFilters = &#123;</span></span><br><span class="line"><span class="meta">@Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span></span><br><span class="line"><span class="meta">@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br></pre></td></tr></table></figure><p>可以看出主要包含了三个注解：</p><ul><li><code>@SpringBootConfiguration</code></li><li><code>@ComponentScan</code></li><li><code>@EnableAutoConfiguration</code></li></ul><h3 id="SpringBootConfiguration"><a href="#SpringBootConfiguration" class="headerlink" title="@SpringBootConfiguration"></a>@SpringBootConfiguration</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootConfiguration &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看 <code>@SpringBootConfiguration</code> 的源码发现其实就是一个 <code>@Configuration</code> 注解，表示这是一个 SpringBoot 的配置类</p><h3 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h3><p><code>@ComponentScan</code> 表示开启组件扫描</p><p>默认是扫描<strong>当前类</strong>下的package。将 <code>@Controller/@Service/@Component/@Repository</code> 等注解加载到IOC容器中</p><h3 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h3><p><code>@EnableAutoConfiguration</code> 表示开启自动配置，SpringBoot 自动配置的原理都在这个注解中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(AutoConfigurationImportSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br></pre></td></tr></table></figure><p><code>@EnableAutoConfiguration</code> 又主要包含 <code>@Import</code>、<code>@AutoConfigurationPackage</code> 俩个注解，先看下重点 <code>@Import</code> 这个注解</p><h4 id="Import"><a href="#Import" class="headerlink" title="@Import"></a>@Import</h4><p><code>@Import</code> 注解是用来导入配置类或者一些需要前置加载的类，可以将多个配置类融合成一个配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Import &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Configuration&#125;, &#123;<span class="doctag">@link</span> ImportSelector&#125;, &#123;<span class="doctag">@link</span> ImportBeanDefinitionRegistrar&#125;</span></span><br><span class="line"><span class="comment"> * or regular component classes to import.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Class&lt;?&gt;[] value();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看代码可以看出，有三种使用方式：</p><ul><li>导入普通 Java 类，导入的类会被加载为 Bean</li><li>导入 <code>ImportSelector</code> 接口实现</li><li>导入 <code>ImportBeanDefinitionRegistrar</code> 接口实现</li></ul><ol><li><p>ImportSelector</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Select and return the names of which class(es) should be imported based on</span></span><br><span class="line"><span class="comment">* the &#123;<span class="doctag">@link</span> AnnotationMetadata&#125; of the importing @&#123;<span class="doctag">@link</span> Configuration&#125; class.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">String[] selectImports(AnnotationMetadata importingClassMetadata);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 接口中只有一个 <code>selectImports</code> 方法，用于返回全类名数组，会把返回数组中的类全部导入</p></li><li><p>ImportBeanDefinitionRegistrar</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Register bean definitions as necessary based on the given annotation metadata of</span></span><br><span class="line"><span class="comment">* the importing &#123;<span class="doctag">@code</span> <span class="doctag">@Configuration</span>&#125; class.</span></span><br><span class="line"><span class="comment">* &lt;p&gt;Note that &#123;<span class="doctag">@link</span> BeanDefinitionRegistryPostProcessor&#125; types may &lt;em&gt;not&lt;/em&gt; be</span></span><br><span class="line"><span class="comment">* registered here, due to lifecycle constraints related to &#123;<span class="doctag">@code</span> <span class="doctag">@Configuration</span>&#125;</span></span><br><span class="line"><span class="comment">* class processing.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> importingClassMetadata annotation metadata of the importing class</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> registry current bean definition registry</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>registerBeanDefinitions</code> 它可以手动注册bean到容器中</p></li></ol><h4 id="AutoConfigurationImportSelector-class"><a href="#AutoConfigurationImportSelector-class" class="headerlink" title="AutoConfigurationImportSelector.class"></a>AutoConfigurationImportSelector.class</h4><p><code>AutoConfigurationImportSelector.class</code> 类实现了 <code>ImportSelector</code> 接口，其中的核心方法是 <code>selectImports</code>，来返回需要导入的组件的全类名数组</p><ul><li><p><code>selectImports</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line"><span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line"><span class="keyword">return</span> NO_IMPORTS;</span><br><span class="line">&#125;</span><br><span class="line">AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader</span><br><span class="line">.loadMetadata(<span class="keyword">this</span>.beanClassLoader);</span><br><span class="line">AnnotationAttributes attributes = getAttributes(annotationMetadata);</span><br><span class="line"><span class="comment">//获取全类名数组</span></span><br><span class="line">List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata,</span><br><span class="line">attributes);</span><br><span class="line">configurations = removeDuplicates(configurations);</span><br><span class="line">Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);</span><br><span class="line">checkExcludedClasses(configurations, exclusions);</span><br><span class="line">configurations.removeAll(exclusions);</span><br><span class="line">configurations = filter(configurations, autoConfigurationMetadata);</span><br><span class="line">fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line"><span class="keyword">return</span> StringUtils.toStringArray(configurations);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>getCandidateConfigurations</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata,</span></span></span><br><span class="line"><span class="function"><span class="params">AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line"><span class="comment">//获取EnableAutoConfiguration.class对应的全类名数组</span></span><br><span class="line">List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(</span><br><span class="line">getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader());</span><br><span class="line">Assert.notEmpty(configurations,</span><br><span class="line"><span class="string">&quot;No auto configuration classes found in META-INF/spring.factories. If you &quot;</span></span><br><span class="line">+ <span class="string">&quot;are using a custom packaging, make sure that file is correct.&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> configurations;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; getSpringFactoriesLoaderFactoryClass() &#123;</span><br><span class="line"><span class="keyword">return</span> EnableAutoConfiguration.class;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>loadFactoryNames</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">loadFactoryNames</span><span class="params">(Class&lt;?&gt; factoryClass, <span class="meta">@Nullable</span> ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">String factoryClassName = factoryClass.getName();</span><br><span class="line"><span class="comment">//返回 META-INF/spring.factories 文件下 EnableAutoConfiguration.class 对应的所有值</span></span><br><span class="line"><span class="keyword">return</span> loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>loadSpringFactories</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从当前项目的类路径中获取所有 META-INF/spring.factories 这个文件下的信息。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(<span class="meta">@Nullable</span> ClassLoader classLoader) &#123;</span><br><span class="line">MultiValueMap&lt;String, String&gt; result = cache.get(classLoader);</span><br><span class="line"><span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//FACTORIES_RESOURCE_LOCATION:META-INF/spring.factories</span></span><br><span class="line">Enumeration&lt;URL&gt; urls = (classLoader != <span class="keyword">null</span> ?</span><br><span class="line">classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :</span><br><span class="line">ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));</span><br><span class="line">result = <span class="keyword">new</span> LinkedMultiValueMap&lt;&gt;();</span><br><span class="line"><span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">URL url = urls.nextElement();</span><br><span class="line">UrlResource resource = <span class="keyword">new</span> UrlResource(url);</span><br><span class="line">Properties properties = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">String factoryClassName = ((String) entry.getKey()).trim();</span><br><span class="line"><span class="keyword">for</span> (String factoryName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) &#123;</span><br><span class="line">result.add(factoryClassName, factoryName.trim());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cache.put(classLoader, result);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Unable to load factories from location [&quot;</span> +</span><br><span class="line">FACTORIES_RESOURCE_LOCATION + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="META-INF-spring-factories"><a href="#META-INF-spring-factories" class="headerlink" title="META-INF/spring.factories"></a>META-INF/spring.factories</h4><p><code>META-INF/spring.factories</code> 在很多第三方依赖中都会有这个文件，第三方依赖通过这个文件并配置 <code>EnableAutoConfiguration</code> 参数，然后自动配置会把这个参数下面的所有类都配置到 Spring 容器中，如图</p><p><img src="/images/SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE0.jpg" alt="image"></p><h4 id="AutoConfigurationPackage"><a href="#AutoConfigurationPackage" class="headerlink" title="@AutoConfigurationPackage"></a>@AutoConfigurationPackage</h4><p><code>@EnableAutoConfiguration</code> 注解中的另一个注解 <code>@AutoConfigurationPackage</code>，是用来自动配置包的，将主配置类 <code>@SpringBootConfiguration</code> 标注的类，所在包及下面所有子包里面的所有组件扫描到 Spring 容器中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Import(AutoConfigurationPackages.Registrar.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AutoConfigurationPackage &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>AutoConfigurationPackage</code> 注解依然使用了 <code>import</code> 注解，不过使用的是 <code>ImportBeanDefinitionRegistrar</code> 接口实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Registrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span>, <span class="title">DeterminableImports</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="comment">//把所在包及其子包里边的组件扫描注册到Spring容器中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata,</span></span></span><br><span class="line"><span class="function"><span class="params">BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">register(registry, <span class="keyword">new</span> PackageImport(metadata).getPackageName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;Object&gt; <span class="title">determineImports</span><span class="params">(AnnotationMetadata metadata)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> Collections.singleton(<span class="keyword">new</span> PackageImport(metadata));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p> SpringBoot的自动装配是由 <code>@EnableAutoConfiguration</code> 注解来实现的，而 <code>@EnableAutoConfiguration</code> 注解又是通过 <code>@AutoConfigurationPackage</code> 和 <code>@Import(AutoConfigurationImportSelector.class)</code> 来实现服务自身的自动配置和第三方依赖的自动配置</p><p>注解关系如图：</p><p> <img src="/images/SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE1.png" alt="image"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;SpringBoot的一个很重要的特性就是自动配置，使用注解，让服务不再需要xml等各种配置文件&lt;br&gt;然后使用main方法一键启动&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;SpringBootApplication&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
    <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Web fragments</title>
    <link href="http://yoursite.com/2021/02/19/Web%20fragments/"/>
    <id>http://yoursite.com/2021/02/19/Web%20fragments/</id>
    <published>2021-02-19T10:23:07.000Z</published>
    <updated>2021-02-19T11:28:12.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p><code>Web fragments</code>是<code>servlet 3.0</code>开始支持的一个特性(可插性支持)，通过插件的方式很方便的扩充已有<code>Web</code>应用的功能，而不需要修改原有的应用</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><blockquote><p>Servlet 3.0 的部署描述文件 web.xml 的顶层标签 有一个 metadata-complete 属性，该属性指定当前的部署描述文件是否是完全的。如果设置为 true，则容器在部署时将只依赖部署描述文件，忽略所有的注解（同时也会跳过 web-fragment.xml 的扫描，亦即禁用可插性支持，具体请看后文关于 <a href="https://www.ibm.com/developerworks/cn/java/j-lo-servlet30/#major4">可插性支持</a> 的讲解）；如果不配置该属性，或者将其设置为 false，则表示启用注解支持（和可插性支持）。</p></blockquote><h3 id="Web-fragments语法和规则"><a href="#Web-fragments语法和规则" class="headerlink" title="Web fragments语法和规则"></a>Web fragments语法和规则</h3><ol><li><code>Web fragments</code> 需要有 <code>web-fragment.xml</code> 的部署描述文件，该文件必须存放在 <code>JAR</code> 文件的 <code>META-INF</code> 目录下，该部署描述文件可以包含一切可以在 <code>web.xml</code> 中定义的内容(过滤器、监听器与<code>Servlet</code>)</li><li>包含 <code>web-fragment.xml</code> 的 <code>JAR</code> 应该部署到 <code>Web</code> 应用程序的 <code>WEBINF/lib</code> 目录中</li><li><code>web-fragment.xml</code> 的根元素是 <code>&lt;web-fragment&gt;</code>，它可以包含 <code>DD(web.xml)</code> 中 <code>&lt;web-app&gt;</code> 元素的任何子元素。</li><li>每个 <code>web-fragment.xml</code> 都可以包含一个 <code>name</code> 元素。<code>name</code> 元素在所有 <code>Web</code> 片段中应该是唯一的，并且不应有任何循环引用或循环，否则容器将因有意义的错误中止应用程序部署。该名称将用于 <code>Web</code> 片段的任何排序。</li><li>可以使用元素 <code>&lt;absolute-ordering&gt;</code> 从 <code>web.xml</code> 中指定 <code>Web</code> 片段的顺序。也可以使用元素 <code>&lt;ordering&gt;</code> 从 <code>Web</code> 片段本身内部指定 <code>Web</code> 片段的顺序。在 <code>web.xml</code> 或 <code>Web</code> 片段中，元素按照声明的顺序加载。</li><li>并且如果 <code>web-fragment.xml</code> 和 <code>web.xml</code> 之间存在冲突，则 <code>web.xml</code> 将具有优先权。但是，如果两个片段之间存在冲突，则会引发错误。</li></ol><h3 id="配置内容"><a href="#配置内容" class="headerlink" title="配置内容"></a>配置内容</h3><blockquote><p>servlet、filter、listener三个可以定义任何一个，也可以全部定义</p></blockquote><ul><li><p>web-fragment.xml:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-fragment</span> <span class="attr">id</span>=<span class="string">&quot;WebFragment_ID&quot;</span> <span class="attr">version</span>=<span class="string">&quot;3.1&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-fragment_3_1.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Test<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- servlet --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>servletTest<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.xxx.xxx.servlets.ServletTest<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>servletTest<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- filter --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filterTest<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.xxx.xxx.FilterTest<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">async-supported</span>&gt;</span>true<span class="tag">&lt;/<span class="name">async-supported</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filterTest<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- listener --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>com.xxx.xxx.ListenerTest<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ordering</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 表示在项目所有之前进行初始化 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">before</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">others</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">before</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 表示在项目所有之后进行初始化 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">after</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">others</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">after</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ordering</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">web-fragment</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>Servlet:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletTest</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.service(req, resp);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.destroy();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Filter:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.Filter;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.FilterChain;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.FilterConfig;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterTest</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Listener:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.ServletRequestEvent;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletRequestListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListenerTest</span> <span class="keyword">implements</span> <span class="title">ServletRequestListener</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestDestroyed</span><span class="params">(ServletRequestEvent servletRequestEvent)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestInitialized</span><span class="params">(ServletRequestEvent servletRequestEvent)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Web fragments&lt;/code&gt;是&lt;code&gt;servlet 3.0&lt;/code&gt;开始支持的一个特性(可插性支持)，通过</summary>
      
    
    
    
    <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>服务缓存优化</title>
    <link href="http://yoursite.com/2021/02/03/%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2021/02/03/%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%96/</id>
    <published>2021-02-03T08:36:35.000Z</published>
    <updated>2021-03-04T09:22:10.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="服务介绍"><a href="#服务介绍" class="headerlink" title="服务介绍"></a>服务介绍</h3><p><code>bizconf</code>服务是公司所有业务的通用配置服务，用来保存所有企业、以及用户的业务配置。分为三个级别的配置，系统级、租户级和用户级。</p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>之前就有发现<code>bizconf</code>调用量比较大，需要优化缓存来降低调用，而最初现状是只在<code>server</code>端有<code>Redis</code>缓存</p><p>问题爆发点：元旦前最后几天，数据库负载高，导致<code>bizconf</code>服务调用耗时从几毫米升高到 20~30 毫秒，这时客户反馈系统库卡顿、反应慢，经过排查发现调用耗时长的请求和<code>bizconf</code>耗时曲线一致，各个业务都用调用<code>bizconf</code>，还有的业务调用多次，<code>bizconf</code>耗时上涨导致整个系统卡顿</p><h3 id="优化目标"><a href="#优化目标" class="headerlink" title="优化目标"></a>优化目标</h3><p>在<code>client</code>添加<code>jvm cahce</code>来降低调用，从而做到服务降级，前后共经过俩次优化，第一次优化因为缓存穿透的原因效果不明显，第二次优化后效果显著</p><p>优化前调用量：<br><img src="/images/%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%960.png"></p><h3 id="第一次优化"><a href="#第一次优化" class="headerlink" title="第一次优化"></a>第一次优化</h3><p>优化范围：在<code>server</code>和<code>client</code>中添加<code>jvm cache</code></p><p>使用缓存：使用<code>caffeine cache</code>，分级缓存，在<code>server</code>和<code>client</code>中分别添加两个<code>cache</code>，企业级和用户级的<code>cache</code></p><p>缓存设置：</p><ul><li>size：<code>server</code>中<code>cache size</code>为50000，<code>client</code>中<code>cache size</code>为5000，</li><li>过期时间：一个小时</li><li>过期策略：<code>expireAfterAccess(long, TimeUnit)</code>按最后访问时间计时</li><li>基于引用：<code>softValues()</code>设置为软引用</li></ul><p>优化后观察：<br>观察发现虽然添加了<code>jvm cache</code>，但是调用量降低的效果不明显，甚至可以说无效果</p><p>又观察<code>Redis</code>调用量和<code>db</code>调用量，发现<code>db</code>调用量和<code>Redis</code>调用量差不多，少的很有限，这时觉得这种情况不对，怀疑发生了缓存穿透，缓存没有生效</p><p><code>Redis</code>和<code>db</code>调用量：<br><img src="/images/%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%961.png"></p><p>经过排查发现一些数据多次的访问数据库，询问对应业务，是在判断企业的某些状态，如果返回<code>false</code>或不存在则认为没有，至此问题定位，缓存穿透导致大量访问数据库，从而解释了为什么优化的效果不明显</p><p>针对缓存穿透有了下面的第二次的优化</p><h3 id="第二次优化"><a href="#第二次优化" class="headerlink" title="第二次优化"></a>第二次优化</h3><p>针对缓存穿透一般有两种处理方式：使用布隆过滤器和缓存空值</p><h4 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h4><p>布隆过滤器具体可以参考<a href="https://blog.csdn.net/yuanlong122716/article/details/104402602">https://blog.csdn.net/yuanlong122716/article/details/104402602</a></p><p>布隆过滤器有两个非常重要的缺点：</p><ol><li>存在误算率，虽然不会错判但是会误判，什么意思呢，返回不存在则一定不存在，返回存在但是并不能判断一定存在</li><li>不可以删除</li></ol><p>如果使用布隆过滤器则有两个场景，保存白名单和黑名单：</p><ul><li>白名单：如果保存白名单，需要把数据库中所有的数据(表示存在的逻辑true)都保存起来，并且新增时需要同步的维护布隆过滤器数据，但因为是分布式服务需要保证所有服务都同步的维护布隆过滤器，难度比较大；同时布隆过滤器不支持删除，所以不考虑使用白名单</li><li>黑名单：如果保存黑名单，把不存在的数据保存起来，但因为会有误判，可能会把存在的数据认为不存在从而返回了空，从而使数据错误，所以不可取</li></ul><p>分析考虑，不采用布隆过滤器，采用缓存空值的方法更为有效和简单</p><h4 id="缓存空值"><a href="#缓存空值" class="headerlink" title="缓存空值"></a>缓存空值</h4><p>优化目标：<br><img src="/images/fs-paas-bizconf%E9%87%8D%E6%9E%84.png"></p><p>优化范围：在<code>client</code>中添加<code>jvm cache</code>，在<code>server</code>中只使用<code>Redis cache</code></p><p>使用缓存：第一次优化时<code>client</code>端缓存的数据有限，这次决定使用<code>ehcache</code>，可以缓存更大的数据量，同样也是分级缓存</p><p>缓存设置：</p><ul><li>size：每个<code>cache</code>堆内存5000条、堆外内存1MB、磁盘50MB</li><li>过期时间：<code>client</code>的<code>jvm cache</code>5小时；<code>server</code>的<code>redis</code>存在的数据24小时，不存在的空值半小时(防止大量不存在的数据把<code>Redis</code>搞崩，还可以更短一些)</li><li>过期策略：<code>ExpiryPolicyBuilder.timeToLiveExpiration(Duration timeToLive)</code> 按创建时间计时</li></ul><p>优化后观察：<br>这次优化后效果显著，调用量就下降了90%，预计所有业务方改完后调用量还会进一步下降</p><p>优化前后对比：<br><img src="/images/%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%962.png"></p><h3 id="审计日志优化"><a href="#审计日志优化" class="headerlink" title="审计日志优化"></a>审计日志优化</h3><p>优化缓存的同时，增加了审计日志，可以用来分析业务方的不合理调用</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;服务介绍&quot;&gt;&lt;a href=&quot;#服务介绍&quot; class=&quot;headerlink&quot; title=&quot;服务介绍&quot;&gt;&lt;/a&gt;服务介绍&lt;/h3&gt;&lt;p&gt;&lt;code&gt;bizconf&lt;/code&gt;服务是公司所有业务的通用配置服务，用来保存所有企业、以及用户的业务配置。分为三个级别</summary>
      
    
    
    
    <category term="优化" scheme="http://yoursite.com/categories/%E4%BC%98%E5%8C%96/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
    <category term="Cache" scheme="http://yoursite.com/tags/Cache/"/>
    
    <category term="优化" scheme="http://yoursite.com/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>服务日志优化</title>
    <link href="http://yoursite.com/2021/01/04/%E6%9C%8D%E5%8A%A1%E6%97%A5%E5%BF%97%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2021/01/04/%E6%9C%8D%E5%8A%A1%E6%97%A5%E5%BF%97%E4%BC%98%E5%8C%96/</id>
    <published>2021-01-04T09:20:59.000Z</published>
    <updated>2021-03-04T10:10:56.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><blockquote><p>功能权限服务之前经手的人比较多，不同人日志打印比较乱，并且服务日志打印量很大，但当需要排查问题时，大日志量 <code>grep</code> 困难、关键信息打印不全或没有打印等问题很痛苦，决定对日志方面进行统一的优化</p></blockquote><h3 id="优化目标"><a href="#优化目标" class="headerlink" title="优化目标"></a>优化目标</h3><ol><li>对服务日志量大、关键信息不全、代码中侵入式打印日志乱等问题进行优化</li><li>人员角色模块，经常有用户、业务不知道什么时候人员角色发生了变化，针对这个模块增加审计日志，便于观察分析调用、排查问题，给出证据</li><li>日志上报日志中心，使得服务发布后日志不丢失</li></ol><h3 id="优化记录"><a href="#优化记录" class="headerlink" title="优化记录"></a>优化记录</h3><h4 id="服务日志优化"><a href="#服务日志优化" class="headerlink" title="服务日志优化"></a>服务日志优化</h4><ul><li><p>日志级别<br><img src="/images/%E6%9C%8D%E5%8A%A1%E6%97%A5%E5%BF%97%E4%BC%98%E5%8C%960.png"></p></li><li><p>日志内容<br><code>traceId</code>，方法名，方法调用链路，每个方法耗时，入参，出参，异常堆栈</p></li><li><p>相关类<br>使用 <code>Spring AOP</code>、<code>ThreadLocal</code>、<code>Spring StopWatch</code>、<code>Annotation</code> 注解<br>支持两种日志打印方式，<code>AOP</code> 打印和手动调用<br><img src="/images/%E6%9C%8D%E5%8A%A1%E6%97%A5%E5%BF%97%E4%BC%98%E5%8C%961.png"></p></li><li><p>使用方式  </p></li></ul><ol><li>新建切面类，继承 <code>TraceLogAop</code> 抽象类</li><li>编写切点，使用环绕通知，切在需要打印日志的地方</li><li>通知中调用父类的 <code>around</code> 方法，传入 <code>ProceedingJoinPoint</code> 和打印耗时日志阈值</li><li>如需要特殊处理异常，则重写 <code>exceptionHandler</code> 方法<br><img src="/images/%E6%9C%8D%E5%8A%A1%E6%97%A5%E5%BF%97%E4%BC%98%E5%8C%962.png"></li><li>在需要打印 <code>info</code> 日志的方法上添加 <code>@InOutLog(&quot;info&quot;)</code> 注解，<code>debug</code> 级别不用添加，默认就是 <code>debug</code> 级别<br><img src="/images/%E6%9C%8D%E5%8A%A1%E6%97%A5%E5%BF%97%E4%BC%98%E5%8C%963.png"></li><li>也可以修改 <code>logback.xml</code> 文件，添加一个 <code>logger</code> 把日志打印到独立的文件中<br><img src="/images/%E6%9C%8D%E5%8A%A1%E6%97%A5%E5%BF%97%E4%BC%98%E5%8C%964.png"></li></ol><ul><li>优化效果<br>入参、出参效果<br><img src="/images/%E6%9C%8D%E5%8A%A1%E6%97%A5%E5%BF%97%E4%BC%98%E5%8C%965.jpg"><br>方法调用链路、耗时效果<br><img src="/images/%E6%9C%8D%E5%8A%A1%E6%97%A5%E5%BF%97%E4%BC%98%E5%8C%966.jpg"><br>根据详细的入参、出参可以快速、准确的排查问题；根据调用链路和耗时可以来分析耗时长的接口，以及耗时的占比，找到最耗时的方法，从而进行优化</li></ul><h4 id="添加审计日志"><a href="#添加审计日志" class="headerlink" title="添加审计日志"></a>添加审计日志</h4><blockquote><p>人员角色模块增加审计日志，上报ES，使用 kibana 展示，便于观察分析调用、排查问题，给出证据</p></blockquote><p><img src="/images/%E6%9C%8D%E5%8A%A1%E6%97%A5%E5%BF%97%E4%BC%98%E5%8C%967.jpg"></p><h4 id="上报日志中心"><a href="#上报日志中心" class="headerlink" title="上报日志中心"></a>上报日志中心</h4><p>有时查问题前一天晚上有过发版，日志信息丢失，导致查询问题困难，针对这种情况把日志上报到日志中心的 Grafana Explore中</p><hr><p>把日志整体优化后，再也没有了以前的苦恼，有什么问题一目了然(<em>^▽^</em>)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;功能权限服务之前经手的人比较多，不同人日志打印比较乱，并且服务日志打印量很大，但当需要排查问题时，大日志量 &lt;co</summary>
      
    
    
    
    <category term="优化" scheme="http://yoursite.com/categories/%E4%BC%98%E5%8C%96/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
    <category term="优化" scheme="http://yoursite.com/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Spring-AOP</title>
    <link href="http://yoursite.com/2020/12/02/Spring-AOP/"/>
    <id>http://yoursite.com/2020/12/02/Spring-AOP/</id>
    <published>2020-12-02T03:22:37.000Z</published>
    <updated>2020-12-07T11:48:02.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>面向切面编程(AOP)可以实现横切关注点与它们所影响对象之间的解耦，对业务逻辑没有任何侵入<br>使用场景有很多，如：日志、异常、声明式事物、安全、缓存等，包括但不限于这些场景<br>常见的AOP实现有<code>Spring-AOP</code>和<code>AspectJ</code>，<code>Spring-AOP</code>基于动态代理实现，主要总结一下<code>Spring-AOP</code></p></blockquote><p><img src="/images/Spring-AOP0.png"></p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="切面-Aspect"><a href="#切面-Aspect" class="headerlink" title="切面(Aspect)"></a>切面(Aspect)</h4><p>切面是通知和切点的结合，通知和切点共同定义了切面的全面内容————是什么，在何时和何处完成其功能</p><h5 id="通知-Advice"><a href="#通知-Advice" class="headerlink" title="通知(Advice)"></a>通知(Advice)</h5><p>切面的具体功能被称为通知，同时通知不仅定义了切面功能，还定义了切面何时使用，而根据使用时机可以分为5种类型的通知：</p><ul><li>前置通知(Before)：在目标方法被调用之前调用通知功能</li><li>后置通知(After)：在目标方法完成之后调用通知，此时不会关心方法的输出是什么</li><li>返回通知(After-returning)：在目标方法成功执行之后调用通知</li><li>异常通知(After-throwing)：在目标方法抛出异常后调用通知</li><li>环绕通知(Around)：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。环绕通知是最强大的通知类型</li></ul><blockquote><p>在 <code>Spring-AOP</code> 中的环绕通知必须有 <code>ProceedingJoinPoint</code> 这个对象参数，通过它的 <code>proceed()</code> 方法来调用被通知的方法</p></blockquote><h5 id="切点-Poincut"><a href="#切点-Poincut" class="headerlink" title="切点(Poincut)"></a>切点(Poincut)</h5><p>通知定义了切面的 “什么” 和 “何时” ，切点则是定义了切面的 ”何处“</p><p>切点定义了通知被应用的具体位置(在哪些连接点)</p><h4 id="连接点-Join-point"><a href="#连接点-Join-point" class="headerlink" title="连接点(Join point)"></a>连接点(Join point)</h4><p>连接点是在应用执行过程中能够应用通知的 ”所有点“</p><p>连接点可以是调用方法时、抛出异常时、甚至修改一个字段时，但因为<code>Spring-AOP</code>基于动态代理，所以<code>Spring</code>只支持方法的连接点，而<code>AspectJ</code>和<code>JBoss</code>的AOP框架还提供了字段和构造器接入点。</p><p>但是方法拦截则满足了大部分的需求，如果需要方法拦截之外的连接点可以利用<code>AspectJ</code>来补充<code>Spring-AOP</code>的功能</p><h4 id="引入-Introduction"><a href="#引入-Introduction" class="headerlink" title="引入(Introduction)"></a>引入(Introduction)</h4><p>添加方法或字段到被通知的类</p><h4 id="织入-Weaving"><a href="#织入-Weaving" class="headerlink" title="织入(Weaving)"></a>织入(Weaving)</h4><p>织入是把切面应用到目标对象并创建新的代理对象的过程</p><p>织入可以在对象生命周期的多个点织入：</p><ul><li>编译期：切面在目标类编译期被织入。这种需要特殊的编译器。<code>AspectJ</code>的织入编译器就是以这种方式织入</li><li>类加载期：切面在目标类加载到JVM时被织入。这种方式需要特殊的类加载器，可以在目标类被引入应用之前增强该目标类的字节码。<code>AspectJ 5</code>的加载时织入就支持这种方式织入</li><li>运行期：切面在应用运行的某个时刻被织入。在织入时，AOP容器会为目标对象动态地创建一个代理对象。**<code>Spring-AOP</code>就是以这种方式织入切面的**</li></ul><h3 id="定义切点"><a href="#定义切点" class="headerlink" title="定义切点"></a>定义切点</h3><blockquote><p>切点用来定位使用通知的地方，在<code>Spring-AOP</code>中使用的是<code>AspectJ</code>的切点表达式语言来定义切点，但是<code>Spring</code>仅支持<code>AspectJ</code>切点指示器的一个子集</p></blockquote><h4 id="切点表达式"><a href="#切点表达式" class="headerlink" title="切点表达式"></a>切点表达式</h4><h5 id="切点指示器"><a href="#切点指示器" class="headerlink" title="切点指示器"></a>切点指示器</h5><p><code>Spring-AOP</code>所支持的<code>AspectJ</code>的切点指示器</p><table><thead><tr><th>AspectJ 指示器</th><th>描述</th></tr></thead><tbody><tr><td>arg()</td><td>限制连接点匹配参数为指定类型的执行方法</td></tr><tr><td>@args()</td><td>限制连接点匹配参数由指定注解标注的执行方法</td></tr><tr><td>execution()</td><td>用于匹配是连接点的执行方法</td></tr><tr><td>this()</td><td>限制连接点匹配AOP代理的bean引用为指定类型的类</td></tr><tr><td>target</td><td>限制连接点匹配目标对象为指定类型的类</td></tr><tr><td>@target()</td><td>限制连接点匹配特定的执行对象，这些对象对应的类要具有指定类 型的注解</td></tr><tr><td>within()</td><td>限制连接点匹配指定的类型</td></tr><tr><td>@within()</td><td>限制连接点匹配指定注解所标注的类型（当使用Spring AOP时，方 法定义在由指定的注解所标注的类里）</td></tr><tr><td>@annotation</td><td>限定匹配带有指定注解的连接点</td></tr></tbody></table><p><strong>只有<code>execution</code>指示器是实际执行匹配的，而其他的指示器都是用来限制匹配的</strong></p><h5 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h5><p>支持<code>and</code>、<code>or</code>、<code>not</code>关系来连接指示器</p><p>在POJO中使用<code>&amp;&amp;</code>、<code>||</code>、<code>!</code>分别代表<code>and</code>、<code>or</code>、<code>not</code>关系</p><p>在XML中直接使用<code>and</code>、<code>or</code>、<code>not</code>来连接指示器</p><p><img src="/images/Spring-AOP1.jpg"></p><h4 id="bean指示器"><a href="#bean指示器" class="headerlink" title="bean指示器"></a>bean指示器</h4><p>除去<code>AspectJ</code>指示器外，<code>Spring</code>还引入了一个新的<code>bean()</code>指示器，用来在切点表达式中使用bean的ID来标识bean。<code>bean()</code>使用<code>bean Id</code>或<code>bean名称</code>作为参数来限制切点只匹配特定的<code>bean</code></p><h3 id="注解创建切面"><a href="#注解创建切面" class="headerlink" title="注解创建切面"></a>注解创建切面</h3><blockquote><p><code>AspectJ 5</code>支持使用注解来创建切面，使用少量的注解就可以把任意类转变为切面</p></blockquote><blockquote><p><code>Spring</code>同时支持<code>AspectJ</code>注解驱动的切面</p></blockquote><h4 id="AOP配置注解"><a href="#AOP配置注解" class="headerlink" title="AOP配置注解"></a>AOP配置注解</h4><h5 id="Aspect"><a href="#Aspect" class="headerlink" title="@Aspect"></a>@Aspect</h5><p>表明该类不仅仅是个POJO，还是一个切面</p><h5 id="通知注解"><a href="#通知注解" class="headerlink" title="通知注解"></a>通知注解</h5><blockquote><p>通知注解对应五种通知类型，来声明通知方法</p></blockquote><table><thead><tr><th>注解</th><th>通知</th></tr></thead><tbody><tr><td>@After</td><td>通知方法会在目标方法返回或抛出异常后调用</td></tr><tr><td>@AfterReturning</td><td>通知方法会在目标方法返回后调用</td></tr><tr><td>@AfterThrowing</td><td>通知方法会在目标方法抛出异常后调用</td></tr><tr><td>@Around</td><td>通知方法会将目标方法封装起来</td></tr><tr><td>@Before</td><td>通知方法会在目标方法调用之前执行</td></tr></tbody></table><h5 id="Pointcut"><a href="#Pointcut" class="headerlink" title="@Pointcut"></a>@Pointcut</h5><p><code>@Pointcut</code>注解可以在一个<code>@AspectJ</code>切面内定义可重用的切点</p><p>E.g.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Audience</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Pointcut(&quot;execution(** concert.Performance.perform(..))&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performce</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Before(&quot;performce()&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">silenceCellPhones</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Silencing cell phones&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Around(&quot;performce()&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takeSeats</span><span class="params">(ProceedingJoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">joinPoint.proceed(joinPoint.getArgs())</span><br><span class="line">    System.out.println(<span class="string">&quot;Taking seats&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@AfterReturning(&quot;performce()&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">applause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;CLAP CLAP CLAP!!!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@AfterThrowing(&quot;performce()&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demandRefund</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Demanding a refund&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过在 <code>performance()</code> 方法上添加 <code>@Pointcut</code> 注解，这样就可以在任何的切点表达式中使用 <code>performance()</code> 了</p><p><code>performance()</code> 方法的实际内容并不重要，在这里它实际上应该是空的。其实该方法本身只是一个标识，供 <code>@Pointcut</code> 注解依附。</p><h4 id="通过注解引入新功能"><a href="#通过注解引入新功能" class="headerlink" title="通过注解引入新功能"></a>通过注解引入新功能</h4><blockquote><p>类似<code>Groovy</code>不直接修改对象或类的定义就能为对象或类增加新的方法，虽然Java不是动态语言，但是通过<code>AOP</code>引用新的接口则可以实现其功能</p></blockquote><blockquote><p>但是当引入接口的方法被调用时，代理会把此调用委托给实现了新接口的某个其他对象。实际上，<strong>一个<code>bean</code>的实现被拆分到了多个类中</strong></p></blockquote><p>通过<code>@DeclareParents</code>注解可以将新的接口引入到<code>bean</code>中</p><p>定义新的接口:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> concert;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Encoreable</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">performEncore</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建切面引入接口:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> concert;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.DeclareParents;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EncodeableIntroducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@DeclareParents(value=&quot;concert.Performce+&quot;,</span></span><br><span class="line"><span class="meta">                  defaultImpl=DefaultEncoreable.class)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Encoreable encoreable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@DeclareParents</code> 注解由三部分组成：</p><ul><li><code>value</code> 属性指定了哪种类型的 <code>bean</code> 要引入该接口。在本例中，也就是所有实现 <code>Performance</code> 的类型。（标记符后面的加号表示是 <code>Performance</code> 的所有子类型，而不是 Performance 本身。）</li><li><code>defaultImpl</code> 属性指定了为引入功能提供实现的类。在这里，我们指定的是 <code>DefaultEncoreable</code> 提供实现。</li><li><code>@DeclareParents</code> 注解所标注的静态属性指明了要引入了接口。在这里，我们所引入的是 Encoreable 接口。</li></ul><h3 id="XML中声明切面"><a href="#XML中声明切面" class="headerlink" title="XML中声明切面"></a>XML中声明切面</h3><h4 id="AOP配置元素"><a href="#AOP配置元素" class="headerlink" title="AOP配置元素"></a>AOP配置元素</h4><p>在 Spring 的 aop 命名空间中，提供了多个元素用来在 XML 中声明切面</p><table><thead><tr><th>AOP 配置元素</th><th>用途</th></tr></thead><tbody><tr><td>&lt;aop:advisor&gt;</td><td>定义 AOP 通知器</td></tr><tr><td>&lt;aop:after&gt;</td><td>定义 AOP 后置通知（不管被通知的方法是否执行成功）</td></tr><tr><td>&lt;aop:after-returning&gt;</td><td>定义 AOP 返回通知</td></tr><tr><td>&lt;aop:after-throwing&gt;</td><td>定义 AOP 异常通知</td></tr><tr><td>&lt;aop:around&gt;</td><td>定义 AOP 环绕通知</td></tr><tr><td>&lt;aop:aspect&gt;</td><td>定义一个切面</td></tr><tr><td>&lt;aop:aspectj-autoproxy&gt;</td><td>启用 @AspectJ 注解驱动的切面</td></tr><tr><td>&lt;aop:before&gt;</td><td>定义一个 AOP 前置通知</td></tr><tr><td>&lt;aop:config&gt;</td><td>顶层的 AOP 配置元素。大多数的元素必须包含在元素内</td></tr><tr><td>&lt;aop:declare-parents&gt;</td><td>以透明的方式为被通知的对象引入额外的接口</td></tr><tr><td>&lt;aop:pointcut&gt;</td><td>定义一个切点</td></tr></tbody></table><p>E.g.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;audience&quot;</span>&gt;</span></span><br><span class="line">    &lt;aop:pointcut</span><br><span class="line">      id=&quot;performance&quot;</span><br><span class="line">      expressions=&quot;execution(** concert.Performance.perform(..))&quot; /&gt;</span><br><span class="line">  </span><br><span class="line">    &lt;aop:before</span><br><span class="line">      pointcut-ref=&quot;performance&quot;</span><br><span class="line">      method=&quot;silenceCellPhones&quot; /&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;aop:around</span><br><span class="line">      pointcut-ref=&quot;performance&quot;</span><br><span class="line">      method=&quot;takeSeats&quot; /&gt;</span><br><span class="line">      </span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:after-returning</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">pointcut</span>=<span class="string">&quot;execution(** concert.Performance.perform(..))&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">method</span>=<span class="string">&quot;applause&quot;</span> /&gt;</span></span><br><span class="line">      </span><br><span class="line">    &lt;aop:after-throwing</span><br><span class="line">      pointcut-ref=&quot;performance&quot;</span><br><span class="line">      method=&quot;demandRefund&quot; /&gt;</span><br><span class="line">      </span><br><span class="line">  <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="通过切面引入新功能"><a href="#通过切面引入新功能" class="headerlink" title="通过切面引入新功能"></a>通过切面引入新功能</h4><p>使用 <code>@DeclareParents</code> 注解可以为被通知的方法引入新的方法，使用 <code>Spring aop</code> 命名空间中的 <code>&lt;aop:declare-parents&gt;</code> 元素，可以实现相同的功能</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">  &lt;aop:delate-parents</span><br><span class="line">    types-matching=&quot;concert.Performance+&quot;</span><br><span class="line">    implement-interface=&quot;concert.Encoreable&quot;</span><br><span class="line">    default-impl=&quot;concert.DefaultEncoreable&quot; /&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>types-matching</code>类型匹配，匹配为哪些<code>bean</code>引入接口</li><li><code>implement-interface</code>指定新加的接口</li><li><code>default-impl</code>用全限定类名来显式指定新加接口的实现</li><li><code>delegate-ref</code>还支持引用了一个<code>Spring bean</code>作为引入接口的实现</li></ul><h3 id="启用AspectJ自动代理"><a href="#启用AspectJ自动代理" class="headerlink" title="启用AspectJ自动代理"></a>启用AspectJ自动代理</h3><p><strong>无论是注解创建、还是XML声明切面，都需要启用自动代理，来创建切面的代理，否则切面不会生效</strong></p><p>启用自动代理有两种方式：</p><ul><li><p>在<code>JavaConfig</code>中启用</p><blockquote><p>配置类的类级别上通过使用 <code>@EnableAspectJAutoProxy</code> 注解启用自动代理功能</p></blockquote></li><li><p> 在<code>XML</code>中启用</p><blockquote><p>使用 Spring aop 命名空间中的 <code>&lt;aop:aspectj-autoproxy/&gt;</code> 元素</p></blockquote></li></ul><h3 id="注入AspectJ切面"><a href="#注入AspectJ切面" class="headerlink" title="注入AspectJ切面"></a>注入AspectJ切面</h3><blockquote><p>虽然 <code>Spring AOP</code> 能够满足许多应用的切面需求，但是与 <code>AspectJ</code> 相比，<code>Spring AOP</code> 是一个功能比较弱的 <code>AOP</code> 解决方案。<code>AspectJ</code> 提供了 <code>Spring AOP</code> 所不能支持的许多类型的切点</p></blockquote><p><code>AspectJ</code> 可以织入到任意的Java应用程序中，而我们可以借助 <code>Spring</code> 的依赖注入把 <code>bean</code> 装配进 <code>AspectJ</code> 切面中，这样更为方便</p><h4 id="用AspectJ实现切面"><a href="#用AspectJ实现切面" class="headerlink" title="用AspectJ实现切面"></a>用AspectJ实现切面</h4><p>创建 <code>AspectJ</code> 的切面需要使用扩展的Java语言</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.aspect.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> aspect AspectInject &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AspectInject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Pointcut（切入点）：定义了相应Advice要发生的地方。</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 定义切入点的常用的两种方式：</span></span><br><span class="line"><span class="comment">     * 1、使用正则表达式。</span></span><br><span class="line"><span class="comment">     * 2、使用AspectJ表达式（Https://www.iteye.com/blog/jinnianshilongnian-1415606）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">pointcut <span class="title">printInfo</span><span class="params">()</span>:<span class="title">execution</span><span class="params">(* xxx.xxx.xxx.xxx.printInfo(..)</span>)</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造器切点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">pointcut <span class="title">constructEntity</span><span class="params">()</span>:<span class="title">execution</span><span class="params">(xxx.xxx.xxx.xxx.User.new()</span>)</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Advice定义了在Pointcut（切入点）具体要做的操作。</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 切入点在AOP中有多种类型，但在Spring中只有方法类型。</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * before advice, 前置。</span></span><br><span class="line"><span class="comment">     * after return advice, 后置（出错不执行）。</span></span><br><span class="line"><span class="comment">     * after throwing advice, 后置（出错才执行）。</span></span><br><span class="line"><span class="comment">     * after(final) advice, 后置（怎么都执行）。</span></span><br><span class="line"><span class="comment">     * around advice, 环绕（前后都执行）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"> </span><br><span class="line">    before():printInfo()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------printInfo()方法的前置------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    after():printInfo()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------printInfo()的后置------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    before():constructEntity()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------new User()时候的前置------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    after():constructEntity()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-------new User()时候的后置------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用aspectOf-方法注入"><a href="#使用aspectOf-方法注入" class="headerlink" title="使用aspectOf()方法注入"></a>使用aspectOf()方法注入</h4><p><code>Spring bean</code> 由 <code>Spring</code> 容器初始化，但是 <code>AspectJ</code> 切面是由 <code>AspectJ</code> 在运行期创建的。等到 <code>Spring</code> 有机会为 <code>AspectJ</code> 切面注入 <code>bean</code> 时，切面已经被实例化了。</p><p>所有的 <code>AspectJ</code> 切面都提供了一个静态的 <code>aspectOf()</code> 方法，该方法返回切面的一个单例。所以为了获得切面的实例，我们必须使用 <code>factory-method</code> 来调用 <code>asepctOf()</code> 方法</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.aspect.test.AspectInject&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;aspectOf&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li>《Spring 实战（第 4 版）》</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;面向切面编程(AOP)可以实现横切关注点与它们所影响对象之间的解耦，对业务逻辑没有任何侵入&lt;br&gt;使用场景有很多，如：日志、异常、声明式事物、安全、缓存等，包括但不限于这些场景&lt;br&gt;常见的AOP实现有&lt;code&gt;Spring-AOP&lt;/code&gt;</summary>
      
    
    
    
    <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
    <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>ssh-ControlMaster</title>
    <link href="http://yoursite.com/2020/11/18/ssh-ControlMaster/"/>
    <id>http://yoursite.com/2020/11/18/ssh-ControlMaster/</id>
    <published>2020-11-18T11:13:59.000Z</published>
    <updated>2020-11-19T12:18:58.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><code>ssh</code> 的配置文件<code>~/.ssh/config</code>可以大大的简化 <code>ssh</code> 的一些操作，如果没有这个文件则自己在 <code>~/.ssh/</code> 下<code>touch</code>一个即可</p></blockquote><blockquote><p>该文主要介绍使用 <code>ControlMaster</code> 来复用连接，每次<code>ssh</code>一台服务器时不需要每次输入密码</p></blockquote><h3 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h3><h4 id="ControlMaster"><a href="#ControlMaster" class="headerlink" title="ControlMaster"></a>ControlMaster</h4><blockquote><p>SSH支持 <code>ControlMaster</code> 模式，单一网络共享多个seesion，复用之前建立的连接，</p></blockquote><p>值可以为 <code>no(default)/yes/ask/auto</code>需要和 <code>ControlPath</code> 配合使用，当值为 yes 时，ssh 会监听该路径下的 <code>control socket</code>，多个 session 会去连接该 socket，则会尽可能的复用连接</p><h4 id="ControlPath"><a href="#ControlPath" class="headerlink" title="ControlPath"></a>ControlPath</h4><blockquote><p>指定 control socket 的路径</p></blockquote><p>值可以使用下面这些参数：</p><ul><li>%L 本地主机名的第一个组件</li><li>%l 本地主机名（包括域名）</li><li>%h 远程主机名（命令行输入）</li><li>%n 远程原始主机名</li><li>%p 远程主机端口</li><li>%r 远程登录用户名</li><li>%u 本地 ssh 正在使用的用户名</li><li>%i 本地 ssh 正在使用 uid</li><li>%C 值为 %l%h%p%r 的 hash</li></ul><h4 id="ControlPersist"><a href="#ControlPersist" class="headerlink" title="ControlPersist"></a>ControlPersist</h4><blockquote><p>结合 <code>ControlMaster</code> 使用，指定连接打开后后台保持的时间。值可以为 no/yes/整数，单位 s。如果为 no，最初的客户端关闭就关闭。如果 yes/0，无限期的，直到杀死或通过其它机制，如：<code>ssh -O exit</code></p></blockquote><h3 id="实际配置"><a href="#实际配置" class="headerlink" title="实际配置"></a>实际配置</h3><h4 id="ssh-config文件"><a href="#ssh-config文件" class="headerlink" title="~/.ssh/config文件"></a>~/.ssh/config文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">host *</span><br><span class="line">ControlPersist yes</span><br><span class="line">ControlMaster auto</span><br><span class="line">ControlPath ~&#x2F;.ssh&#x2F;master-%r@%h:%p</span><br></pre></td></tr></table></figure><ul><li><code>host</code> 标识匹配的主机名，<code>*</code>代表所有，也可匹配的主机</li><li><code>ControlPersist</code> 保持连接，客户端关闭并不会真的关闭连接</li><li><code>ControlMaster</code> 开启连接复用</li><li><code>ControlPath</code> 指定<code>control socket</code>的路径，当开启<code>ssh</code>连接后，会在<code>~/.ssh/</code>下产生一个master开头的文件，当有这这个文件时，再次<code>ssh</code>连接同一个服务器时判断有该文件则不需要输入密码</li></ul><h4 id="修改expect脚本"><a href="#修改expect脚本" class="headerlink" title="修改expect脚本"></a>修改expect脚本</h4><p>经常会使用<code>expect</code>脚本来连接服务器，开启<code>ControlMaster</code>模式后可能会使之前的<code>expect</code>脚本有问题，所以需要修改<code>expect</code>脚本</p><ul><li><p>before</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/expect</span></span><br><span class="line">set host [lindex $argv 0]</span><br><span class="line">set username &quot;&quot;</span><br><span class="line"></span><br><span class="line">spawn ssh $username@$host</span><br><span class="line">expect &#123;</span><br><span class="line">&quot;*yes/no)? &quot; &#123;send &quot;yes\n&quot;; exp_continue&#125;</span><br><span class="line">&quot;password:&quot; &#123;send &quot;password&quot;&#125;</span><br><span class="line">&#125;</span><br><span class="line">interact</span><br></pre></td></tr></table></figure></li><li><p>after</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/expect</span></span><br><span class="line">set host [lindex $argv 0]</span><br><span class="line">set username &quot;&quot;</span><br><span class="line"></span><br><span class="line">set controlMaster [file exists ~/.ssh/master-$username@$host:22]</span><br><span class="line"></span><br><span class="line">if &#123; $controlMaster&#125; &#123;</span><br><span class="line">spawn ssh $username@$host</span><br><span class="line">&#125; else &#123;</span><br><span class="line">spawn ssh $username@$host</span><br><span class="line">expect &#123;</span><br><span class="line">    &quot;*yes/no)? &quot; &#123;send &quot;yes\n&quot;; exp_continue&#125;</span><br><span class="line">&quot;password:&quot; &#123;send &quot;password&quot;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">interact</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;ssh&lt;/code&gt; 的配置文件&lt;code&gt;~/.ssh/config&lt;/code&gt;可以大大的简化 &lt;code&gt;ssh&lt;/code&gt; 的一些操作，如果没有这个文件则自己在 &lt;code&gt;~/.ssh/&lt;/code&gt; 下&lt;code&gt;touc</summary>
      
    
    
    
    <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Annotation注解</title>
    <link href="http://yoursite.com/2020/11/13/Annotation%E6%B3%A8%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/11/13/Annotation%E6%B3%A8%E8%A7%A3/</id>
    <published>2020-11-13T04:33:31.000Z</published>
    <updated>2020-11-13T04:54:41.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="三种内置注解"><a href="#三种内置注解" class="headerlink" title="三种内置注解:"></a>三种内置注解:</h4><ol><li><p><code>@Override</code>表示当前的方法定义将覆盖超类中的方法。</p></li><li><p><code>@Deprecated</code>使用了注解为它的元素编译器将发出警告，因为注解@Deprecated是不赞成使用的代码，被弃用的代码。</p></li><li><p><code>@SuppressWarnings</code>关闭不当编辑器警告信息。</p></li></ol><h4 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h4><blockquote><p>定义注解的注解,是java提供给我们用于定义注解的基本注解.在<code>java.lang.annotation</code>包</p></blockquote><h5 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h5><blockquote><p>用于定义注解的作用目标，表示该注解可以用于什么地方，ElementType参数有：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Target(ElementType.TYPE)           用于接口(注解本质上也是接口),类,枚举</span><br><span class="line">@Target(ElementType.FIELD)          用于字段,枚举常量</span><br><span class="line">@Target(ElementType.METHOD)         用于方法</span><br><span class="line">@Target(ElementType.PARAMETER)      用于方法参数</span><br><span class="line">@Target(ElementType.CONSTRUCTOR)    用于构造参数</span><br><span class="line">@Target(ElementType.LOCAL_VARIABLE) 用于局部变量</span><br><span class="line">@Target(ElementType.ANNOTATION_TYPE)用于注解</span><br><span class="line">@Target(ElementType.PACKAGE)        用于包</span><br></pre></td></tr></table></figure><h5 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h5><blockquote><p>用于定义注解保留策略，即定义的注解类在什么时候存在(源码阶段 or 编译后 or 运行阶段).</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.SOURCE)注解仅在源码中保留,class文件中不存在</span><br><span class="line">@Retention(RetentionPolicy.CLASS)注解在源码和class文件中都存在,但运行时不存在,即运行时无法获得,该策略也是默认的保留策略</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)注解在源码,class文件中存在且运行时可以通过反射机制获取到</span><br></pre></td></tr></table></figure><h5 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h5><blockquote><p>用于描述其它类型的annotation应该被javadoc文档化,出现在api doc中</p></blockquote><h5 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h5><blockquote><p>允许子类继承父类中的注解</p></blockquote><h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE&#125;)   ---作用范围 Class</span><br><span class="line">@Retention(RetentionPolicy.CLASS)  ---生命周期：仅保留到.class文件</span><br><span class="line">public @interface 注解名 &#123;定义体&#125;</span><br></pre></td></tr></table></figure><p>像<code>@Override</code>这样,没有成员定义的注解称之为标记注解.</p><p>自定义注解后，需要处理注解，注解实现的具体逻辑需要自己来写注解处理器</p><h3 id="注解处理器"><a href="#注解处理器" class="headerlink" title="注解处理器:"></a>注解处理器:</h3><p>注解处理器可以分为运行时注解处理和编译时注解处理器.运行时处理器需要借助反射机制实现,而编译时处理器则需要借助APT来实现.</p><p>无论是运行时注解处理器还是编译时注解处理器,主要工作都是读取注解然后处理特定注解</p><h4 id="运行时注解处理器"><a href="#运行时注解处理器" class="headerlink" title="运行时注解处理器"></a>运行时注解处理器</h4><p>运行时注解属性为<code>@Retention(RetentionPolicy.RUNTIME)</code>的注解.</p><p>为了运行时能准确获取到注解的相关信息，Java在java.lang.reflect 反射包下新增了<code>AnnotatedElement</code>接口，所有程序元素的(Class,Method)都实现了该接口，通过该接口提供的方法可以利用反射技术地读取注解的信息</p><p>常用<code>AnnotatedElement</code>中的反射方法:</p><table><thead><tr><th align="center">方法</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center"><T extends Annotation> T getAnnotation(Class<T> annotationClass)</td><td align="center">返回该元素上存在的制定类型的注解</td></tr><tr><td align="center">Annotation[] getAnnotations()</td><td align="center">返回该元素上存在的所有注解</td></tr><tr><td align="center">default <T extends Annotation> T[] getAnnotationsByType(Class<T> annotationClass)</td><td align="center">返回该元素指定类型的注解</td></tr><tr><td align="center">default <T extends Annotation> T getDeclaredAnnotation(Class<T> annotationClass)</td><td align="center">返回直接存在与该元素上的所有注释</td></tr><tr><td align="center">default <T extends Annotation> T[] getDeclaredAnnotationsByType(Class<T> annotationClass)</td><td align="center">返回直接存在该元素岸上某类型的注释</td></tr><tr><td align="center">Annotation[] getDeclaredAnnotations()</td><td align="center">返回直接存在与该元素上的所有注释</td></tr></tbody></table><p>通过这些反射方法获取到注解信息，然后对其进行业务操作即可</p><h4 id="编译时注解处理器"><a href="#编译时注解处理器" class="headerlink" title="编译时注解处理器"></a>编译时注解处理器</h4><blockquote><p>(Annotation Processor Tool)APT,处理注解来生成代码<br>获取注解及生成代码都是在代码编译时候完成的，相比反射在运行时处理注解大大提高了程序性能</p></blockquote><p>不同于运行时注解处理器，编写编译时注解处理器分两步:</p><h5 id="继承AbstractProcessor，实现自己的注解处理器"><a href="#继承AbstractProcessor，实现自己的注解处理器" class="headerlink" title="继承AbstractProcessor，实现自己的注解处理器"></a>继承AbstractProcessor，实现自己的注解处理器</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RouteProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ProcessingEnvironment env)</span></span>&#123; </span><br><span class="line">        <span class="keyword">super</span>.init(processingEnv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annoations, RoundEnvironment env)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">getSupportedAnnotationTypes</span><span class="params">()</span> </span>&#123; </span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">super</span>.getSupportedAnnotationTypes();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SourceVersion <span class="title">getSupportedSourceVersion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">super</span>.getSupportedSourceVersion();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">方法</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">init(ProcessingEnvironment processingEnv)</td><td align="center">该方法有注解处理器自动调用，其中ProcessingEnvironment类提供了很多有用的工具类：Filter，Types，Elements，Messager等</td></tr><tr><td align="center">getSupportedAnnotationTypes()</td><td align="center">该方法返回字符串的集合表示该处理器用于处理那些注解</td></tr><tr><td align="center">getSupportedSourceVersion()</td><td align="center">该方法用来指定支持的java版本，一般来说我们都是支持到最新版本，因此直接返回SourceVersion.latestSupported(）即可</td></tr><tr><td align="center">process(Set annotations, RoundEnvironment roundEnv)</td><td align="center">该方法是注解处理器处理注解的主要地方，我们需要在这里写扫描和处理注解的代码，以及最终生成的java文件。其中需要深入的是RoundEnvironment类，该用于查找出程序元素上使用的注解</td></tr></tbody></table><h5 id="注册处理器-并打成jar包"><a href="#注册处理器-并打成jar包" class="headerlink" title="注册处理器,并打成jar包"></a>注册处理器,并打成jar包</h5><blockquote><p>注解和注解处理器必须要新建jar包，然后通过jar包引用。</p></blockquote><p>为了让java编译器或能够找到自定义的注解处理器我们需要对其进行注册和打包：自定义的处理器需要被打成一个jar，并且需要在jar包的<code>META-INF/services</code>路径下中创建一个固定的文件<code>javax.annotation.processing.Processor</code>,在<code>javax.annotation.processing.Processor</code>文件中需要填写自定义处理器的完整路径名，有几个处理器就需要填写几个</p><blockquote><p>AbstractProcessor中生成java类，可以使用JavaPoet开源库进行编写，提升效率</p></blockquote><p>常用的<code>Lombok</code>来消除代码冗余，则是通过APT来实现的<br><img src="/images/Annotation%E6%B3%A8%E8%A7%A3.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h3&gt;&lt;h4 id=&quot;三种内置注解&quot;&gt;&lt;a href=&quot;#三种内置注解&quot; class=&quot;headerlink&quot; title=&quot;三种内置注</summary>
      
    
    
    
    <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>创建文档站点</title>
    <link href="http://yoursite.com/2020/10/23/%E5%88%9B%E5%BB%BA%E6%96%87%E6%A1%A3%E7%AB%99%E7%82%B9/"/>
    <id>http://yoursite.com/2020/10/23/%E5%88%9B%E5%BB%BA%E6%96%87%E6%A1%A3%E7%AB%99%E7%82%B9/</id>
    <published>2020-10-23T08:47:20.000Z</published>
    <updated>2020-10-23T10:14:17.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>经常看到一些文档的网站很简洁，于是便调研了一下，自己动手基于<code>GitHub Pages</code>搭建了一个文档站点</p></blockquote><h3 id="文档站点生成器"><a href="#文档站点生成器" class="headerlink" title="文档站点生成器"></a>文档站点生成器</h3><blockquote><p>调研了5种文档站点生成器</p></blockquote><ol><li><p><a href="https://docsify.js.org/#/zh-cn/">docsify</a><br>不同于 <code>GitBook</code>、<code>vuePress</code>、<code>Hexo</code> 的地方是它不会生成静态的 .html 文件，所有转换工作都是在运行时。无需构建，写完文档直接发布</p></li><li><p><a href="https://docute.org/zh/">docute</a><br><code>docute</code> 和 <code>docsify</code> 几乎相同，都是运行时驱动，但具有不同的 UI 和不同的使用方式，Docute（60kB）比 Docisfy（20kB）大 3 倍，因为<code>docute</code>使用了 Vue，Vue Router 和 Vuex，而 <code>Docsify</code> 使用的是 vanilla JavaScript。</p></li><li><p><a href="https://vuepress.vuejs.org/zh/">vuePress</a><br>使用vue开发，每一个由 <code>VuePress</code> 生成的页面都带有预渲染好的 HTML，也因此具有非常好的加载性能和搜索引擎优化（SEO）</p></li><li><p><a href="https://rust-lang.github.io/mdBook/">mdBook</a><br><code>mdBook</code> 是一个命令行工具和<code>Rust crate</code>。可将Markdown文件创建为书籍。它与<code>Gitbook</code>非常相似,但用<code>Rust</code>编写</p></li><li><p><a href="https://www.gitbook.com/">gitBook</a><br><code>GitBook</code> 是一个基于 Node.js 的命令行工具，可使用 Github/Git 和 Markdown 来制作精美的电子书，支持输出多种格式文档：静态站点、PDF、eBook、单HTML网页、JSON</p></li></ol><h3 id="使用docsify搭建站点"><a href="#使用docsify搭建站点" class="headerlink" title="使用docsify搭建站点"></a>使用docsify搭建站点</h3><blockquote><p><a href="http://leetcode.tianwj.com/">leetcode.tianwj.com</a><br>把之前刷的leetcode记录生成了一个站点，并且绑定二级域名</p></blockquote><p><a href="https://docsify.js.org/#/zh-cn/">docsify</a> 官方文档写的非常详细，并且还支持中文，官方文档就是使用 <code>docsify</code> 生成的，具体可以查看官方文档</p><p>设置<code>GitHub Pages</code>:<br><img src="/images/gitHub-pages.png"></p><p>最终成品:<br><img src="/images/leetcode1.png"><br><img src="/images/leetcode2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;经常看到一些文档的网站很简洁，于是便调研了一下，自己动手基于&lt;code&gt;GitHub Pages&lt;/code&gt;搭建了一个文档站点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;文档站点生成器&quot;&gt;&lt;a href=&quot;#文档站点生成器&quot; class</summary>
      
    
    
    
    <category term="其他" scheme="http://yoursite.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux expect</title>
    <link href="http://yoursite.com/2020/09/13/Linux-expect/"/>
    <id>http://yoursite.com/2020/09/13/Linux-expect/</id>
    <published>2020-09-13T07:54:52.000Z</published>
    <updated>2020-09-13T09:08:43.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><code>expect</code> 是基于<a href="http://tcl.tk/man/tcl8.5/TclCmd/contents.htm">Tcl</a>实现的一个脚本语言，用来实现自动和程序交互式通信。类似自动远程登录命令，模拟人手工交互输入密码的过程，从而实现自动远程登录<br><code>expect</code> 的工作流程为:<code>spawn</code>(启动指定进程)—&gt;<code>expect</code>(获取指定关键字)—&gt;<code>send</code>(向指定程序发送指定字符)—&gt;<code>interact</code>(允许用户交互)–&gt;退出结束</p></blockquote><h3 id="安装expect"><a href="#安装expect" class="headerlink" title="安装expect"></a>安装expect</h3><p>使用<code>expect</code>的前提需要安装，这里以<code>yum</code>安装为例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y expect</span><br></pre></td></tr></table></figure><h3 id="expect常用命令"><a href="#expect常用命令" class="headerlink" title="expect常用命令"></a>expect常用命令</h3><h4 id="spawn"><a href="#spawn" class="headerlink" title="spawn"></a>spawn</h4><p>启动一个进程，然后所有的<code>expect</code>都在这个进程中进行</p><h4 id="expect"><a href="#expect" class="headerlink" title="expect"></a>expect</h4><p>获取匹配信息匹配成功则执行<code>expect</code>后面的程序动作</p><blockquote><p>example:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">expect &#123;</span><br><span class="line">    “yes&#x2F;no”</span><br><span class="line">    &#123;send “yes\n”;exp_continue&#125;</span><br><span class="line">    “*password:”</span><br><span class="line">    &#123;send “123456\n”&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="exp-continue"><a href="#exp-continue" class="headerlink" title="exp_continue"></a>exp_continue</h4><p>在<code>expect</code>中多次匹配用到，使后面的匹配仍然从第一个关键字开始，否则第一次匹配从第一个关键字开始，但是后面第二次匹配则从第二个关键字开始</p><h4 id="send-exp-send"><a href="#send-exp-send" class="headerlink" title="send exp_send"></a>send exp_send</h4><p>用于发送指定的字符串信息</p><h4 id="send-user"><a href="#send-user" class="headerlink" title="send_user"></a>send_user</h4><p>把参数输出到标准输出中去，默认的<code>send</code>,<code>exp_send</code>命令都是将参数输出到程序中的，相当于<code>shell</code>中的<code>echo</code></p><h4 id="interact"><a href="#interact" class="headerlink" title="interact"></a>interact</h4><p>停留在当前进程，退出<code>expect</code>，交给用户操作</p><h4 id="exit"><a href="#exit" class="headerlink" title="exit"></a>exit</h4><p>退出<code>expect</code>脚本，还可以使用该命令指定退出前的一些命令</p><blockquote><p>example:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">exit -onexit &#123;</span><br><span class="line">    exec rm $tmpfile(删除临时文件)</span><br><span class="line">    send_user “Good bye\n”</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><blockquote><p><code>expect</code>变量使用方法和<code>Tcl</code>一致</p></blockquote><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p>定义变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set host localhost</span><br><span class="line">set passwrod 123456</span><br></pre></td></tr></table></figure><blockquote><p>example:接收命令行参数为变量</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set host [lindex $argv 0]</span><br><span class="line">set passwrod [lindex $argv 1]</span><br></pre></td></tr></table></figure><h4 id="puts"><a href="#puts" class="headerlink" title="puts"></a>puts</h4><p>输出变量</p><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><h4 id="eof"><a href="#eof" class="headerlink" title="eof"></a>eof</h4><p><code>expect</code>执行结束 退出</p><h4 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a>timeout</h4><p>设置全局性的超时时间，默认是10s</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set timeout 60</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;expect&lt;/code&gt; 是基于&lt;a href=&quot;http://tcl.tk/man/tcl8.5/TclCmd/contents.htm&quot;&gt;Tcl&lt;/a&gt;实现的一个脚本语言，用来实现自动和程序交互式通信。类似自动远程登录命令，模拟人</summary>
      
    
    
    
    <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>线程安全与锁优化</title>
    <link href="http://yoursite.com/2020/04/06/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2020/04/06/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/</id>
    <published>2020-04-06T09:48:29.000Z</published>
    <updated>2020-04-06T09:58:36.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><h4 id="Java中的线程安全"><a href="#Java中的线程安全" class="headerlink" title="Java中的线程安全"></a>Java中的线程安全</h4><p>按照线程安全的“安全程度”分为五大类：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立</p><ol><li><strong>不可变</strong><br>在Java中不可变(Immutable)对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要再进行任何线程安全保护措施。如<code>final</code>关键字</li><li><strong>绝对线程安全</strong><br>绝对的线程安全是指“不管运行时环境如何，调用者都不需要任何额外的同步策略”，绝对的线程安全是需要付出非常高的代价的，甚至是不切实际的代价。而在Java API中标注是线程安全的类，大多数都不是绝对的线程安全，都是相对的线程安全</li><li><strong>相对线程安全</strong><br>相对线程安全就是我们通常意义上所讲的线程安全。它需要保证<strong>对象单次的操作是安全的,</strong> 如<code>Vector</code>的<code>get()</code>方法，这个方法是同步的。但是对于一些特定顺序的连续调用，则需要调用端使用额外的同步手段来保证正确性，如使用<code>synchronized</code>关键字<br>在Java中，大部分声明线程安全的类都属于这种类型，如<code>Vector</code>、<code>HashTable</code>、<code>ConcurrentHashMap</code>和<code>Collections</code>的<code>synchronizedCollection()</code>方法包装的集合等</li><li><strong>线程兼容</strong><br>线程兼容是值对象本身并不是线程安全的，但是通过调用端正确的使用同步手段来保证对象在并发环境中可以安全的使用。平常我们说一个类不是线程安全的，指的就是这种情况。<br>Java类库中大部分类都是线程兼容的，如<code>ArrayList</code>和<code>HashMap</code>等</li><li><strong>线程对立</strong><br>线程独立是指不管调用端是否采取了同步措施，都无法在多线程环境中并发使用。<br>线程对立这种情况是很少出现的，而且通常都是有害的，应当避免<br>如<code>Thread</code>类的<code>suspend()</code>和<code>resume()</code>方法。</li></ol><h4 id="线程安全的实现方法"><a href="#线程安全的实现方法" class="headerlink" title="线程安全的实现方法"></a>线程安全的实现方法</h4><ol><li><p><strong>互斥同步</strong><br>互斥同步是最常见也是最主要的并发保障手段。同步是指共享数据在同一时刻只能背一个线程使用，而互斥是实现同步的一种手段，<code>临界区(Critical Section)</code>、<code>互斥量(Mutex)</code>和<code>信号量(Semaphore)</code>都是常见的互斥实现方式</p><ul><li>synchronized关键字:<br>在Java中，最基本的互斥同步手段就是<code>synchronized关键字</code>，这是一个块结构的语法。<code>synchronized</code>关键字经过javac编译后，会在同步块前后形成<code>monitorenter</code>和<code>monitorexit</code>两个字节码指令。<br>在执行<code>monitorenter</code>指令时，首先尝试去获取对象锁，如果对象没有被锁定或当前线程已经持有了该对象的锁，就把锁的计数器增加一，而在执行<code>monitorexit</code>指令时将会将锁计数器的值减一。当锁计数器的值为0时，锁则被释放了。如果获取对象锁失败则会一直阻塞等待，直到获取到锁  </li></ul></li></ol><p><strong><code>synchronized</code>对于一个线程来说是可重入的，同时<code>synchronized</code>中的锁是非公平的</strong></p><pre><code>- 重入锁(ReentrantLock):  </code></pre><p>重入锁(ReentrantLock)是Lock接口最常见的一种实现，与<code>synchronized</code>相似，但是比<code>synchronized</code>相比多了一些高级功能，主要是：等待可中断、可实现公平锁(默认也是非公平锁)、可以绑定多个条件</p><ol start="2"><li><p><strong>非阻塞同步</strong><br>互斥同步也被称为阻塞同步，是一种悲观悲观的并发策略，主要问题是进行线程阻塞和唤醒所带来的性能开销。与之对应的则是乐观的并发策略，最常用的是不断的重试，直接操作共享数据，当出现冲突时，不断的重试，直到没有冲突。<br>最常见的方法是CAS(Compare-and-Swap)，如juc包中的<code>Atomic</code>类则是通过自旋和CAS实现的，同时CAS可能会出现ABA问题，但是大部分情况下ABA问题不会影响程序并发的正确性</p></li><li><p><strong>无同步方案</strong><br>如果让一个方法不涉及多线程共享数据，自然也不需要去保证线程安全，因为他们天生就是线程安全的，如<code>ThreadLocal</code>这个类，每一个<code>Thread</code>对象都有一个<code>ThreadLocalMap</code>对象，用来存储当前线程的变量</p></li></ol><h3 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h3><blockquote><p>JDK 5升级到JDK 6后，进行了大量的锁优化</p></blockquote><h4 id="自旋锁和自适应自旋"><a href="#自旋锁和自适应自旋" class="headerlink" title="自旋锁和自适应自旋"></a>自旋锁和自适应自旋</h4><ul><li>自旋锁：当线程尝试获取锁时发现冲突，则让获取锁的线程等一会，但不放弃CPU的执行时间，而让线程等待则让线程执行一个循环(自旋)即可</li><li>自适应自旋：自旋所等待的时间必须有一定的限度，如果超过了限定的次数仍然没有获取到锁，则使用传统的方法挂起该线程，自旋次数默认是10次。而自适应自旋则是自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定</li></ul><h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><p>锁消除是虚拟机即时编译器在运行时，检测到数据不可能被其他线程访问，则会对锁进行消除。锁消除的主要判断依据来源于逃逸分析的数据支持，如果判断一段代码在堆上的所有数据都不会逃逸出去被其他线程访问到，则可以把他们当作栈上的数据对待，认为他们是线程私有的</p><h4 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h4><p>如果虚拟机探测到有一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展(粗化)到整个操作序列的外部。如果<code>StringBuffer.append()</code>方法，连续操作append方法，锁则会扩展到第一个append方法之前和最后一个append方法之后，只需加一次锁就可以</p><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><blockquote><p>轻量级锁是通过CAS来实现的</p></blockquote><p>HotSpot虚拟机的对象头中有一部分用来存储对象自身的运行时数据，如哈希码，GC分代年龄、存储标识位、偏向模式等，官方称它为“Mark Word”。</p><p>在代码即将进入同步块之前，如果同步对象没有被锁定，则在当前线程的栈帧中建立一个锁记录(Lock Record)的空间，用来存储锁对象Mark Word的拷贝。<br>然后虚拟机使用CAS操作尝试把对象的Mark Word更新为Lock Record的指针，如果更新成功，则代表该线程拥有了这个对象的所，如果更新失败了，首先检查是否是当前线程拥有了这个对象的锁，如果是的话直接执行即可，如果不是则说明锁被其他线程抢占了。解锁反之。</p><p>如果出现两个线程争用一个锁的情况，那轻量级锁则不再有效，必须膨胀为重量级锁</p><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>轻量级锁是在无竞争的情况下使用CAS来消除同步的互斥量，而偏向锁是在无竞争的情况下把整个同步都消除掉，连CAS都不再操作</p><p>具体是这样的，当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设置为“01”、把偏向模式设置为“1”，标识进入偏向模式。同时使用CAS操作把获取这个锁的线程ID记录在了对象头的Mark Word中，如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁都不需要有任何同步操作。但是如果另外的线程去尝试获取这个锁，偏向模式则马上宣告结束</p><p>偏向锁是一种权衡的优化，如果程序中的大多数锁都总是被多个不同的线程访问，那偏向模式反而是多余的。具体情况具体分析，可以使用参数<code>-CC:-UseBiasedLocking</code>来禁止偏向锁优化</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;线程安全&quot;&gt;&lt;a href=&quot;#线程安全&quot; class=&quot;headerlink&quot; title=&quot;线程安全&quot;&gt;&lt;/a&gt;线程安全&lt;/h3&gt;&lt;h4 id=&quot;Java中的线程安全&quot;&gt;&lt;a href=&quot;#Java中的线程安全&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>ThreadPoolExecutor</title>
    <link href="http://yoursite.com/2020/04/02/ThreadPoolExecutor/"/>
    <id>http://yoursite.com/2020/04/02/ThreadPoolExecutor/</id>
    <published>2020-04-02T14:51:58.000Z</published>
    <updated>2020-04-02T15:57:14.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>ThreadPoolExecutor是Java中线程池的核心实现类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">classDiagram</span><br><span class="line">Executor &lt;|-- ExecutorService : 继承</span><br><span class="line">ExecutorService &lt;|-- AbstractExecutorService : 实现</span><br><span class="line">AbstractExecutorService &lt;|-- ThreadPoolExecutor : 继承</span><br></pre></td></tr></table></figure><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new &#123;<span class="doctag">@code</span> ThreadPoolExecutor&#125; with the given initial</span></span><br><span class="line"><span class="comment"> * parameters and default thread factory.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> corePoolSize      核心线程池大小</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> maximumPoolSize   最大线程池大小</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> keepAliveTime     线程池中超过corePoolSize数目的空闲线程最大存活时间；可以allowCoreThreadTimeOut(true)成为核心线程的有效时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unit              keepAliveTime的时间单位</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> workQueue         阻塞任务队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> threadFactory     线程工厂，对线程命名 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> handler           拒绝策略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure><h3 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h3><p>所有任务的调度都是由execute方法完成的，这部分完成的工作是：检查现在线程池的运行状态、运行线程数、运行策略，决定接下来执行的流程，是直接申请线程执行，或是缓冲到队列中执行，亦或是直接拒绝该任务。其执行过程如下：</p><ol><li>首先检测线程池运行状态，如果不是RUNNING，则直接拒绝，线程池要保证在RUNNING的状态下执行任务。</li><li>如果workerCount &lt; corePoolSize，则创建并启动一个线程来执行新提交的任务。</li><li>如果workerCount &gt;= corePoolSize，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中。</li><li>如果workerCount &gt;= corePoolSize &amp;&amp; workerCount &lt; maximumPoolSize，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务。</li><li>如果workerCount &gt;= maximumPoolSize，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。</li></ol><h3 id="任务存储策略"><a href="#任务存储策略" class="headerlink" title="任务存储策略"></a>任务存储策略</h3><p>使用不同的队列可以实现不一样的任务存取策略</p><ul><li><strong>ArrayBlockingQueue:</strong> 一个用数组实现的有界阻塞队列，此队列按照先进先出(FIFO)的原则对元素进行排序。支持公平锁和非公平锁</li><li><strong>LinkedBlockingQueue:</strong> 一个由链表结构组成的有界队列，此队列按照先进先出(FIFO)的原则对元素进行排序。此队列的默认长度是Integer.MAX_VALUE，所以默认创建的队列有容量危险</li><li><strong>PriorityBlockingQueue:</strong> 一个支持线程优先级排序的无界队列，默认自然序进行排序，也可以自定义实现compareTo()方法来指定元素排序规则，不能保证同优先级元素的排序</li><li><strong>DelayQueue:</strong> 一个实现<code>PriorityBlockingQueue</code>实现延迟获取的无界队列，在创建元素时，可以指定多久才能从队列中获取当前元素。只有延时期满后才能从队列中获取元素</li><li><strong>SynchronousQueue:</strong> 一个不存储元素的阻塞队列，每一个put操作必须等待take操作，否则不能添加元素。支持公平锁和非公平锁。<code>SynchronousQueue</code>的一个使用场景是在线程里。<code>Executors.newCachedThreadPool()</code>就使用了<code>SynchronousQueue</code>，这个线程池根据需要(新任务到来时)创建新的线程，如果有空闲线程则会重复使用，线程空闲60秒后会被回收</li><li><strong>LinkedTransferQueue:</strong> 一个由链表结构组成的无界阻塞队列，相当于其他队列，<code>LinkedTransferQueue</code>队列多了<code>transfer</code>和<code>tryTransfer</code>方法</li><li><strong>LinkedBlockingDeque:</strong> 一个由链表结构组成的双向阻塞队列，队列的头和尾部都可以添加和移除元素，多线程并发时，可以将锁的竞争最多降低一半</li></ul><h3 id="RejectedExecutionHandler拒绝策略"><a href="#RejectedExecutionHandler拒绝策略" class="headerlink" title="RejectedExecutionHandler拒绝策略"></a>RejectedExecutionHandler拒绝策略</h3><ul><li><p><strong>AbortPolicy:</strong> 默认策略，直接抛出异常阻止系统正常运行</p></li><li><p><strong>CallerRunsPolicy:</strong> “调用者运行”一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将任务回馈至发起方比如main线程</p></li><li><p><strong>DiscardOldestPolicy:</strong> 抛弃队列中等待最久的任务，然后把当前任务加入队列中尝试再次提交当前任务</p></li><li><p><strong>DiscardPolicy:</strong> 直接丢弃任务，不给予任何处理也不跑出异常，如果允许任务丢失，这是最好的一种方案</p></li></ul><h3 id="execute-和submit-区别"><a href="#execute-和submit-区别" class="headerlink" title="execute()和submit()区别"></a>execute()和submit()区别</h3><ol><li>接收的参数不一样</li><li>submit有返回值，而execute没有</li><li>submit方便Exception处理：可以通过捕获Future.get抛出的异常</li></ol><h3 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ThreadFactory factory &#x3D; new ThreadFactoryBuilder().setDaemon(true).setNameFormat(&quot;test-666-%d&quot;).build();</span><br><span class="line">ExecutorService threadPoolExecutor &#x3D; new ThreadPoolExecutor(5, 5, 0L, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(), factory);</span><br><span class="line">threadPoolExecutor.execute(()-&gt;&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br><span class="line">&lt;!--threadPoolExecutor.submit(()-&gt;&#123;--&gt;</span><br><span class="line">&lt;!--    ...--&gt;</span><br><span class="line">&lt;!--&#125;);--&gt;</span><br><span class="line">threadPoolExecutor.shutdown();</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;ThreadPoolExecutor是Java中线程池的核心实现类&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;</summary>
      
    
    
    
    <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>事物隔离级别</title>
    <link href="http://yoursite.com/2020/02/01/%E4%BA%8B%E7%89%A9%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    <id>http://yoursite.com/2020/02/01/%E4%BA%8B%E7%89%A9%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</id>
    <published>2020-02-01T05:25:55.000Z</published>
    <updated>2020-02-01T05:55:34.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="事物"><a href="#事物" class="headerlink" title="事物"></a>事物</h3><p>事务是由一组SQL语句组成的逻辑处理单元，是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。事务具有以下4个属性，通常简称为事务的ACID属性:</p><ul><li><p><strong>原子性(Atomicity):</strong> 事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。</p></li><li><p><strong>一致性(Consistent):</strong> 在事务开始和完成时，数据都必须保持一致状态。</p></li><li><p><strong>隔离性(Isolation):</strong> 并发访问数据库时，一个用户的事物不被其他事物所干扰，各并发事务之间数据库是独立的。</p></li><li><p><strong>持久性(Durable):</strong> 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</p></li></ul><h3 id="并发一致性问题"><a href="#并发一致性问题" class="headerlink" title="并发一致性问题"></a>并发一致性问题</h3><ul><li><p><strong>脏读(Dirty read):</strong> 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。<br>解决办法: 把数据库的事务隔离级别调整到<code>READ_COMMITTED</code></p></li><li><p><strong>更新丢失(Lost Update):</strong> 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 </p></li><li><p><strong>不可重复读(Unrepeatableread):</strong> 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。  </p></li></ul><p><strong>一个事务范围内两个相同的查询却返回了不同数据。</strong><br>解决办法: 把数据库的事务隔离级别调整到<code>REPEATABLE_READ</code></p><ul><li><p><strong>幻读(Phantom read):</strong> 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</p></li><li><p><strong>不可重复度和幻读区别:</strong><br>不可重复读的重点是修改，幻读的重点在于新增或者删除。</p></li></ul><h3 id="事物的隔离级别"><a href="#事物的隔离级别" class="headerlink" title="事物的隔离级别"></a>事物的隔离级别</h3><p>“脏读”、”不可重复读”和”幻读”，必须由事务隔离机制来解决。</p><h4 id="SQL-标准定义了四个隔离级别"><a href="#SQL-标准定义了四个隔离级别" class="headerlink" title="SQL 标准定义了四个隔离级别:"></a>SQL 标准定义了四个隔离级别:</h4><ul><li><p><strong>读未提交(Read Uncommitted):</strong><br>最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读</p></li><li><p><strong>读已提交(Read Committed):</strong><br>允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong><br>Oracle、SqlServer默认隔离级别都是<code>READ-COMMITTED</code></p></li><li><p><strong>可重复读(Repeatable Read):</strong><br>对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong><br>MYSQL默认隔离级别是<code>REPEATABLE-READ</code></p></li><li><p><strong>串行化(Serializable):</strong><br>最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong></p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><p>读未提交: 一个事务还没提交时，它做的变更就能被别的事务看到。</p></li><li><p>读已提交: 一个事务提交之后，它做的变更才会被其他事务看到。</p></li><li><p>可重复读 : 一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。</p></li><li><p>串行化: 顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</p></li></ul><p>四个级别逐渐增强，每个级别解决一个问题，事务级别越高，性能越差，大多数环境(<code>Read committed</code> 就可以了)</p><table><thead><tr><th>隔离级别</th><th>读数据一致性</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>读未提交</td><td>最低级别</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>读已提交</td><td>语句级</td><td>N</td><td>Y</td><td>Y</td></tr><tr><td>可重复读</td><td>事物级</td><td>N</td><td>N</td><td>Y</td></tr><tr><td>串行化</td><td>最高级别、事物级</td><td>N</td><td>N</td><td>N</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;事物&quot;&gt;&lt;a href=&quot;#事物&quot; class=&quot;headerlink&quot; title=&quot;事物&quot;&gt;&lt;/a&gt;事物&lt;/h3&gt;&lt;p&gt;事务是由一组SQL语句组成的逻辑处理单元，是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollbac</summary>
      
    
    
    
    <category term="DB" scheme="http://yoursite.com/categories/DB/"/>
    
    
    <category term="DB" scheme="http://yoursite.com/tags/DB/"/>
    
  </entry>
  
  <entry>
    <title>Spring中的FactoryBean</title>
    <link href="http://yoursite.com/2019/12/27/Spring%E4%B8%AD%E7%9A%84FactoryBean/"/>
    <id>http://yoursite.com/2019/12/27/Spring%E4%B8%AD%E7%9A%84FactoryBean/</id>
    <published>2019-12-27T11:22:04.000Z</published>
    <updated>2019-12-27T11:25:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>Spring 中有两种类型的Bean，一种是普通Bean，另一种是工厂Bean 即 FactoryBean。<br>FactoryBean跟普通Bean不同，其返回的对象不是指定类的一个实例，而是该<code>FactoryBean</code>的<code>getObject</code>方法所返回的对象</p><h3 id="FactoryBean接口定义"><a href="#FactoryBean接口定义" class="headerlink" title="FactoryBean接口定义"></a>FactoryBean接口定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.beans.factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FactoryBean</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//返回的对象实例</span></span><br><span class="line">    <span class="function">T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Bean的类型</span></span><br><span class="line">    Class&lt;?&gt; getObjectType();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//true是单例，false是非单例  在Spring5.0中此方法利用了JDK1.8的新特性变成了default方法，返回true</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>FactoryBean 通常是用来创建比较复杂的bean，一般的bean 直接用xml配置即可，但如果一个bean的创建过程中涉及到很多其他的bean 和复杂的逻辑，用xml配置比较困难，这时可以考虑用FactoryBean。</p><blockquote><p>当使用ApplicationContext的getBean()方法获取FactoryBean实例本身而不是它所产生的bean，则要使用&amp;符号+id。比如，现有FactoryBean，它有id，在容器上调用getBean(“myBean”)将返回FactoryBean所产生的bean，调用getBean(“&amp;myBean”)将返回FactoryBean它本身的实例。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Spring 中有两种类型的Bean，一种是普通Bean，另一种是工厂Bean 即 FactoryBean。&lt;br&gt;FactoryBean跟普通Bean不同，其返回的对象不是指定类的一个实例，而是该&lt;code&gt;FactoryBean&lt;/code&gt;的&lt;code&gt;getObje</summary>
      
    
    
    
    <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
    <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Java代理模式</title>
    <link href="http://yoursite.com/2019/12/24/Java%E7%9A%84%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/12/24/Java%E7%9A%84%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</id>
    <published>2019-12-24T12:03:53.000Z</published>
    <updated>2019-12-24T12:41:13.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><blockquote><p>在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。</p></blockquote><blockquote><p>在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。</p></blockquote><blockquote><p>java中的代理分为：静态代理、动态代理。动态代理又分为jdk代理和Cglib代理。</p></blockquote><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>静态代理在使用时，需要定义接口或者父类，被代理的对象和代理对象需要一起实现同一个接口或者继承同一个父类。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h4><ul><li><p>抽象接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>委托类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserImpl</span> <span class="keyword">implements</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;name is &quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>代理类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserProxy</span> <span class="keyword">implements</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserProxy</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.user = user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        String result = user.getName(name); </span><br><span class="line">        System.out.println(result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Demo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        UserProxy userProxy = <span class="keyword">new</span> UserProxy(<span class="keyword">new</span> UserImpl());</span><br><span class="line">        userProxy.getName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h4><blockquote><p>代理类不仅是一个隔离客户端和委托类的中介，还可以通过代理类在不修改原有代码的前提下增加一些新功能，是开闭原则(Open for Extension, Closed for Modification)最典型的实践。</p><p>代理类可以为委托类预处理消息、过滤消息、把消息转发给委托类以及事后处理消息等。代理类与委托类之间通常会存在关联关系，一个代理类的对象与一个委托类的对象关联，代理类对象本身并不真正实现服务，而是通过调用委托类的对象的相关方法来提供特定的服务。</p></blockquote></li><li><p>优点:可以做到在不修改目标对象的功能前提下,对目标功能扩展；</p></li><li><p>缺点:因为代理对象需要与目标对象实现一样的接口，所以会有很多代理类，同时，一旦接口增加方法，目标对象与代理对象都要维护。</p></li></ul><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>静态代理的缺点怎么改进呢？让代理类动态的生成是不就可以了呢，也就是<code>动态代理</code></p><p><code>动态代理</code>两种最常见的方式：</p><ol><li>通过实现接口的方式 -&gt; JDK动态代理</li><li>通过继承类的方式 -&gt; CGLIB动态代理</li></ol><h4 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h4><p><strong>JDK动态代理又称接口代理</strong>，基于Java反射机制实现，必须要实现了接口的业务类才能用这种办法生成代理对象。</p><p>JDK动态代理主要涉及两个类：<code>java.lang.reflect.Proxy</code> 和 <code>java.lang.reflect.InvocationHandler</code></p><p>InvocationHandler 和 Proxy 的主要方法介绍:</p><ul><li><p><code>java.lang.reflect.InvocationHandler</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义了代理对象调用方法时希望执行的动作，用于集中处理在动态代理类对象上的方法调用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> proxy     被代理的对象 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> method    要调用的方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args      方法调用时所需要参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br></pre></td></tr></table></figure></li><li><p><code>java.lang.reflect.Proxy</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造实现指定接口的代理类的一个新实例，所有方法会调用给定处理器对象的 invoke 方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> loader        指定当前目标对象使用类加载器，获取加载器的方法是固定的</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> interfaces    目标对象实现的接口的类型，使用泛型方式确认类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> h             InvocationHandler接口的子类的实例  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          InvocationHandler h)</span></span></span><br></pre></td></tr></table></figure><p>  <strong>推荐使用Guava中的 <code>com.google.common.reflect.Reflection</code>的<code>newProxy</code>方法，更加方便</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造实现指定接口的代理类的一个新实例，所有方法会调用给定处理器对象的 invoke 方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> interfaceType</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">newProxy</span><span class="params">(Class&lt;T&gt; interfaceType, InvocationHandler handler)</span></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 返回指定接口的代理类</span></span></span><br><span class="line"><span class="function"><span class="comment"> *</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @param loader        目标对象的类加载</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @param interfaces    目标对象实现的接口类型</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; <span class="title">getProxyClass</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                         Class&lt;?&gt;... interfaces)</span></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 获取指定代理对象所关联的调用处理器</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InvocationHandler <span class="title">getInvocationHandler</span><span class="params">(Object proxy)</span></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 判断cl是否为一个代理类</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isProxyClass</span><span class="params">(Class&lt;?&gt; cl)</span></span></span><br></pre></td></tr></table></figure></li></ul><h5 id="示例-1"><a href="#示例-1" class="headerlink" title="示例:"></a>示例:</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    User user = (User) Proxy.newProxyInstance(User.class.getClassLoader(), <span class="comment">// 传入ClassLoader</span></span><br><span class="line">                                              User.class.getInterfaces(), <span class="comment">// 传入要实现的接口</span></span><br><span class="line">                                              (object, method, para) -&gt; &#123;</span><br><span class="line">                                                System.out.println(method);</span><br><span class="line">                                                <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;getName&quot;</span>)) &#123;</span><br><span class="line">                                                  System.out.println(<span class="string">&quot;name is &quot;</span> + args[<span class="number">0</span>]);</span><br><span class="line">                                                &#125;</span><br><span class="line">                                                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                                              &#125;); <span class="comment">// 传入处理调用方法的InvocationHandler</span></span><br><span class="line"></span><br><span class="line">    user.getName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>在运行期动态创建一个interface实例的步骤如下：</p><ol><li>定义一个InvocationHandler实例，它负责实现接口的方法调用；</li><li>通过Proxy.newProxyInstance()创建interface实例，它需要3个参数：<ol><li>使用的ClassLoader，通常就是接口类的ClassLoader；</li><li>需要实现的接口数组，至少需要传入一个接口进去；</li><li>用来处理接口方法调用的InvocationHandler实例。</li></ol></li><li>将返回的Object强制转型为接口。</li></ol><h4 id="Cglib动态代理"><a href="#Cglib动态代理" class="headerlink" title="Cglib动态代理"></a>Cglib动态代理</h4><p><strong>Cglib动态代理又称子类代理</strong>，基于ASM机制实现，通过生成业务类的子类作为代理类。</p><h5 id="Cglib子类实现代理的方法"><a href="#Cglib子类实现代理的方法" class="headerlink" title="Cglib子类实现代理的方法:"></a>Cglib子类实现代理的方法:</h5><ol><li>需要引入cglib和asm的jar包文件，Spring的核心包里面已经包含了此包；</li><li>引入jar包后，就可以在内存中动态构建子类；</li><li><strong>代理的类不能为final，否则报错；</strong></li><li><strong>目标对象的方法如果为final/static，那么就不会被拦截，即不会执行目标对象额外的方法。</strong></li></ol><h5 id="示例-2"><a href="#示例-2" class="headerlink" title="示例:"></a>示例:</h5><ul><li><p>被代理类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserImpl</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;name is &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现MethodInterceptor接口生成方法拦截器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserMethodInterceptor</span>  <span class="keyword">implements</span> <span class="title">MethodInterceptor</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> object 表示要进行增强的对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 表示拦截的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> objects 数组表示参数列表，基本数据类型需要传入其包装类型，如int--&gt;Integer、long-Long、double--&gt;Double</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodProxy 表示对方法的代理，invokeSuper方法表示对被代理对象方法的调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Before: &quot;</span>  + method.getName());</span><br><span class="line">        <span class="comment">// 注意这里是调用 invokeSuper 而不是 invoke，否则死循环，methodProxy.invokesuper执行的是原始类的方法，method.invoke执行的是子类的方法</span></span><br><span class="line">        Object object = methodProxy.invokeSuper(o, objects);</span><br><span class="line">        System.out.println(<span class="string">&quot;After: &quot;</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Demo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">//继承被代理类</span></span><br><span class="line">        enhancer.setSuperclass(UserImpl.class);</span><br><span class="line">        <span class="comment">//设置回调</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> UserMethodInterceptor());</span><br><span class="line">        <span class="comment">//设置代理类对象</span></span><br><span class="line">        UserImpl user = (UserImpl) enhancer.create();</span><br><span class="line">        <span class="comment">//在调用代理类中方法时会被我们实现的方法拦截器进行拦截</span></span><br><span class="line">        user.getName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="在Spring的AOP编程中"><a href="#在Spring的AOP编程中" class="headerlink" title="在Spring的AOP编程中:"></a>在Spring的AOP编程中:</h4><ul><li>如果加入容器的目标对象有实现接口，用JDK代理</li><li>如果目标对象没有实现接口，用Cglib代理</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;代理模式&quot;&gt;&lt;a href=&quot;#代理模式&quot; class=&quot;headerlink&quot; title=&quot;代理模式&quot;&gt;&lt;/a&gt;代理模式&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型</summary>
      
    
    
    
    <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
    <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Bean Copy</title>
    <link href="http://yoursite.com/2019/09/25/Bean-Copy/"/>
    <id>http://yoursite.com/2019/09/25/Bean-Copy/</id>
    <published>2019-09-25T08:50:48.000Z</published>
    <updated>2019-09-25T10:23:07.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在日常开发中，经常会遇到需要Bean copy的情况，有好多copy的方法</p></blockquote><h2 id="克隆的分类"><a href="#克隆的分类" class="headerlink" title="克隆的分类"></a>克隆的分类</h2><ul><li>浅克隆（shallow clone），浅克隆是指拷贝对象时仅仅copy对象本身和对象中的基本变量，而不拷贝对象包含的引用指向的对象。</li><li>深克隆（deep clone），不仅copy对象本身，而且copy对象包含的引用指向的所有对象。</li></ul><h2 id="克隆方法"><a href="#克隆方法" class="headerlink" title="克隆方法"></a>克隆方法</h2><h3 id="传统的setter方法"><a href="#传统的setter方法" class="headerlink" title="传统的setter方法"></a>传统的setter方法</h3><p>手工来setter对象的每个属性，这种方法性能非常高，但是写法不优雅、繁琐</p><h3 id="Object-clone"><a href="#Object-clone" class="headerlink" title="Object.clone()"></a>Object.clone()</h3><ul><li><p>实现<code>java.lang.Cloneable</code>接口<br>Cloneable是标记型的接口，它们内部都没有方法和属性，实现 Cloneable来表示该对象能被克隆，能使用Object.clone()方法。如果没有实现 Cloneable的类对象调用clone()就会抛出CloneNotSupportedException。</p></li><li><p>重写（Override）Object的<code>clone()</code>方法，并声明为<code>public</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">        String name;</span><br><span class="line">        <span class="keyword">int</span> age;</span><br><span class="line">        </span><br><span class="line">        Student(String name,<span class="keyword">int</span> age) &#123;</span><br><span class="line">            <span class="keyword">this</span>.name=name;</span><br><span class="line">            <span class="keyword">this</span>.age=age;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这只是浅克隆，如果需要深克隆的话则重写（Override）Object类的clone()方法，并且在方法内部调用持有对象的clone方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">        String name;    </span><br><span class="line">        Info info;    </span><br><span class="line"></span><br><span class="line">        Student(String name,Info info) &#123;    </span><br><span class="line">            <span class="keyword">this</span>.name=name;    </span><br><span class="line">            <span class="keyword">this</span>.info=info;    </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">            Student student = (Student) <span class="keyword">super</span>.clone();</span><br><span class="line">            student.info = (Info) student.info.clone();</span><br><span class="line">            <span class="keyword">return</span> student;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以调用<code>Object.clone()</code>方法或调用<code>org.apache.commons.lang3.ObjectUtils</code>的clone()方法来克隆对象了</p></li></ul><h3 id="序列化来实现深克隆"><a href="#序列化来实现深克隆" class="headerlink" title="序列化来实现深克隆"></a>序列化来实现深克隆</h3><p>自定义类需要实现<code>Serializable</code>接口，然后把对象（实际上只是对象的一个拷贝）写到一个流里，再从流里读出来，便可以重建对象</p><h3 id="使用第三方工具"><a href="#使用第三方工具" class="headerlink" title="使用第三方工具"></a>使用第三方工具</h3><p>常见的第三方工具大概有这几种:</p><blockquote><p>Apache 的 BeanUtils<br>Apache 的 PropertyUtils<br>Spring 的 BeanUtils<br>Cglib 的 BeanCopier</p></blockquote><h4 id="Apache-的-BeanUtils-和-PropertyUtils"><a href="#Apache-的-BeanUtils-和-PropertyUtils" class="headerlink" title="Apache 的 BeanUtils 和 PropertyUtils:"></a>Apache 的 BeanUtils 和 PropertyUtils:</h4><p>Apache的BeanUtils和PropertyUtils<strong>性能非常差</strong>，一般都不使用。<br>这个俩个类都是浅克隆，Apache还提供了 <code>SerializationUtils.clone(T)</code>，T对象需要实现<code>Serializable</code>接口，他属于深克隆。</p><h4 id="Spring-的-BeanUtils"><a href="#Spring-的-BeanUtils" class="headerlink" title="Spring 的 BeanUtils"></a>Spring 的 BeanUtils</h4><p>Spring的BeanUtils的<code>BeanUtils.copyProperties()</code>方法相比Apache来说性能要好很多。<br>并且相比Cglib 的 BeanCopier来说，它是静态方法，直接使用即可，非常方便。而BeanCopier不是静态方法，使用前需要使用<code>BeanCopier.create()</code>来初始化。</p><h4 id="Cglib-的-BeanCopier"><a href="#Cglib-的-BeanCopier" class="headerlink" title="Cglib 的 BeanCopier"></a>Cglib 的 BeanCopier</h4><p>Cglib 的 BeanCopier相比来说性能是最高的，但是使用前需要通过<code>BeanCopier.create()</code>来初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BeanCopier beanCopier = BeanCopier.create(srcClass, dstClass, <span class="keyword">false</span>);</span><br><span class="line">beanCopier.copy(srcObject, dstObject, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>其实BeanCopier主要花费的时间是调用create()方法，真正执行copy Bean花费的时间较少，所以我们可以进行优化，不是每次执行创建新BeanCopier，将BeanCopier.create()创建的BeanCopier进行缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@UtilityClass</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanCopierUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, BeanCopier&gt; cache = Maps.newConcurrentMap();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &lt;S, D&gt; <span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">(S srcObject, D dstObject)</span> </span>&#123;</span><br><span class="line">    BeanCopier beanCopier = getBeanCopier(srcObject.getClass(), dstObject.getClass());</span><br><span class="line">    beanCopier.copy(srcObject, dstObject, <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> BeanCopier <span class="title">getBeanCopier</span><span class="params">(Class&lt;?&gt; srcClass, Class&lt;?&gt; dstClass)</span> </span>&#123;</span><br><span class="line">    String key = Joiner.on(<span class="string">&#x27;\u0003&#x27;</span>).join(srcClass.getName(), dstClass.getName());</span><br><span class="line">    <span class="keyword">return</span> cache.computeIfAbsent(key, k -&gt; BeanCopier.create(srcClass, dstClass, <span class="keyword">false</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加入缓存后和手工set的性能接近</p><hr><blockquote><p>建议不要使用Apache的工具，如果是偶尔使用为了方便可以使用Spring的BeanUtils，如果是频繁使用时还是推荐使用Cglib 的 BeanCopier</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;在日常开发中，经常会遇到需要Bean copy的情况，有好多copy的方法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;克隆的分类&quot;&gt;&lt;a href=&quot;#克隆的分类&quot; class=&quot;headerlink&quot; title=&quot;克隆的分类&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>死锁DeadLock</title>
    <link href="http://yoursite.com/2019/09/18/MySQL-DeadLock/"/>
    <id>http://yoursite.com/2019/09/18/MySQL-DeadLock/</id>
    <published>2019-09-18T11:24:51.000Z</published>
    <updated>2019-09-25T07:52:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="死锁问题"><a href="#死锁问题" class="headerlink" title="死锁问题"></a>死锁问题</h2><blockquote><p>Deadlock found when trying to get lock; try restarting transaction</p></blockquote><p>发现在批量update时偶尔报Deadlock found when trying to get lock; try restarting transaction错误</p><h3 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h3><p>根本原因是两个事物同时批量操作时，有操作相同的记录，但是两个事物操作相同记录的顺序不一样，导致两个两个事物都获取不到锁，互锁了<br><img src="/images/deadlock.jpg" alt="deadlock"></p><p>正如阿里Java开发手册中说的一样:</p><blockquote><p>【强制】对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造 成死锁。<br>说明:线程一需要对表 A、B、C 依次全部加锁后才可以进行更新操作，那么线程二的加锁顺序 也必须是 A、B、C，否则可能出现死锁。</p></blockquote><hr><h3 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h3><ul><li>减小事务</li><li>给字段排序，按照排序后顺序执行，让死锁变为锁等待。</li></ul><hr><h4 id="减小事物"><a href="#减小事物" class="headerlink" title="减小事物:"></a>减小事物:</h4><p>减小在一个事物中的语句和执行时间，这样只是减小发生deadlock的概率，推荐给字段排序来解决。</p><h4 id="给字段排序"><a href="#给字段排序" class="headerlink" title="给字段排序:"></a>给字段排序:</h4><p>看到网上有这样解决的：<br>Change</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> onlineusers <span class="keyword">WHERE</span> datetime <span class="operator">&lt;=</span> now() <span class="operator">-</span> <span class="type">INTERVAL</span> <span class="number">900</span> <span class="keyword">SECOND</span></span><br></pre></td></tr></table></figure><p>TO</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> onlineusers <span class="keyword">WHERE</span> id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> onlineusers</span><br><span class="line">    <span class="keyword">WHERE</span> datetime <span class="operator">&lt;=</span> now() <span class="operator">-</span> <span class="type">INTERVAL</span> <span class="number">900</span> <span class="keyword">SECOND</span> <span class="keyword">order</span> <span class="keyword">by</span> id) u;</span><br></pre></td></tr></table></figure><p><strong>需要注意这样写可能会非常慢，因为IN中的子查询可能会不走索引，全表扫描，如果表中的数据很多，那这样就会产生很大的问题</strong></p><ul><li><p>可以修改为join：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE tableName <span class="keyword">AS</span> table1 <span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> tableName <span class="keyword">WHERE</span> <span class="keyword">AND</span> id <span class="keyword">IN</span> (<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>) <span class="keyword">ORDER</span> <span class="keyword">BY</span> id) <span class="keyword">AS</span> table2 <span class="keyword">ON</span> table1.id<span class="operator">=</span>table2.id <span class="keyword">SET</span> column1<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure></li><li><p>或者可以修改为:</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE tableNmae <span class="keyword">SET</span> column1<span class="operator">=</span><span class="number">1</span> <span class="keyword">WHERE</span> <span class="keyword">AND</span> id <span class="keyword">IN</span> (<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>)  <span class="keyword">ORDER</span> <span class="keyword">BY</span> id;</span><br></pre></td></tr></table></figure><p>  MySQL支持这种语法</p></li><li><p>或者可以在程序中把需要排序的字段排好序，然后再去执行SQL</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;死锁问题&quot;&gt;&lt;a href=&quot;#死锁问题&quot; class=&quot;headerlink&quot; title=&quot;死锁问题&quot;&gt;&lt;/a&gt;死锁问题&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Deadlock found when trying to get lock; try resta</summary>
      
    
    
    
    <category term="DB" scheme="http://yoursite.com/categories/DB/"/>
    
    
    <category term="DB" scheme="http://yoursite.com/tags/DB/"/>
    
    <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
</feed>
