<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tianwj&#39;s blog</title>
  
  
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2023-04-16T14:07:54.120Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>tianwj</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>DDD-分层架构</title>
    <link href="http://yoursite.com/2023/03/01/DDD-%E5%88%86%E5%B1%82%E6%9E%B6%E6%9E%84/"/>
    <id>http://yoursite.com/2023/03/01/DDD-%E5%88%86%E5%B1%82%E6%9E%B6%E6%9E%84/</id>
    <published>2023-03-01T08:09:43.000Z</published>
    <updated>2023-04-16T14:07:54.120Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>DDD更重要的是战略设计，DDD分层架构只是实现DDD的一种方式，但不限这一种，如六边形架构、整洁架构等。</p><p>六边形架构、整洁架构、DDD分层架构，虽然表现形式不同，但是设计思想都是相同的，都是以领域模型为中心，都体现了高内聚低耦合原则。</p><p>下面对比六边形架构、整洁架构、DDD分层架构三种架构模型，以及DDD分层架构的代码结构、命名规则。</p><h1 id="六边形架构"><a href="#六边形架构" class="headerlink" title="六边形架构"></a>六边形架构</h1><p><img src="/images/85fb9fb2782b343d45b4ca18c8f21e6c.png" alt="img"></p><p>六边形架构是Alistair Cockburn在2005年提出的，它把系统分为内部和外部。内部代表业务逻辑，外部代表业务逻辑的入口调用和底层依赖。</p><p>不同形态的外部要顺利访问到内部之前，或者内部需要依赖外部之前都需要经过必要的适配实现。因此六边形架构又名<strong>端口适配器架构。</strong></p><p>因为端口可能有多个，比如入口侧有用户界面、API、命令行、消息流、甚至是系统定时任务脚本等方式访问内部业务逻辑，出口侧可能会依赖数据库、缓存系统、中间件系统、外部应用系统等等，因此架构图就是一个多边形形状，只是六个端口比较形象因而得名为六边形架构。</p><h2 id="各层职能"><a href="#各层职能" class="headerlink" title="各层职能"></a>各层职能</h2><p>六边形架构将系统分为内六边形和外六边形两层，这两层的职能划分如下：</p><ul><li>红圈内的六边形实现应用的核心业务逻辑。</li><li>外六边形完成外部应用、驱动和基础资源等的交互和访问，对前端应用以API主动适配的方式提供服务，对基础资源以依赖倒置被动适配的方式实现资源访问。</li></ul><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li><p>对分层做了进一步明确，隔离了内部的业务逻辑和外部的主动或被动的依赖。很好地体现了DDD的思想，分开了业务和技术实现。带来很多好处，比如可测试性高，外部可替代性高。</p></li><li><p>解决了业务逻辑不应该依赖基础设施层的问题，实现了依赖倒置，即外部各适配器依赖内部的端口，适配器是对端口的实现。</p></li></ul><h1 id="整洁架构"><a href="#整洁架构" class="headerlink" title="整洁架构"></a>整洁架构</h1><p><img src="/images/fc8208d9f4cfadb7949d6e98a8c18442.png" alt="img"></p><p>整洁架构又名“洋葱架构”。从外部到内部每层都用圆圈表示，因为架构图很像洋葱而得名。</p><p>洋葱架构是2008年Jeffrey Palermo结合六边形架构和DDD提出的，在洋葱架构里，同心圆代表应用软件的不同部分，从里到外依次是领域模型、领域服务、应用服务和最外围的容易变化的内容，比如用户界面和基础设施。</p><p>整洁架构最主要的原则是依赖原则，它定义了各层的依赖关系，越往里依赖越低，代码级别越高，越是核心能力。外圆代码依赖只能指向内圆，内圆不需要知道外圆的任何情况。</p><h2 id="各层职能-1"><a href="#各层职能-1" class="headerlink" title="各层职能"></a>各层职能</h2><p>在洋葱架构中，各层的职能是这样划分的：</p><ul><li>领域模型实现领域内核心业务逻辑，它封装了企业级的业务规则。领域模型的主体是实体，一个实体可以是一个带方法的对象，也可以是一个数据结构和方法集合。</li><li>领域服务实现涉及多个实体的复杂业务逻辑。</li><li>应用服务实现与用户操作相关的服务组合与编排，它包含了应用特有的业务流程规则，封装和实现了系统所有用例。</li><li>最外层主要提供适配的能力，适配能力分为主动适配和被动适配。主动适配主要实现外部用户、网页、批处理和自动化测试等对内层业务逻辑访问适配。被动适配主要是实现核心业务逻辑对基础资源访问的适配，比如数据库、缓存、文件系统和消息中间件等。</li><li>红圈内的领域模型、领域服务和应用服务一起组成软件核心业务能力。</li></ul><h1 id="DDD分层架构"><a href="#DDD分层架构" class="headerlink" title="DDD分层架构"></a>DDD分层架构</h1><h2 id="四层架构"><a href="#四层架构" class="headerlink" title="四层架构"></a>四层架构</h2><p><img src="/images/webp" alt="img"><img src="/images/1a4e5210301a669f74bff8801e3d9e1d.png" alt="image.png"></p><p>从上到下依次是：用户接口层、应用层、领域层和基础设施层。</p><p>四层架构是<strong>限定型松散分层架构</strong>，即Infrastructure层的任意上层都可以访问该层（“L”型），而其它层遵守<strong>严格分层架构</strong>。</p><h3 id="各层职能-2"><a href="#各层职能-2" class="headerlink" title="各层职能"></a>各层职能</h3><ul><li><p><strong>用户接口层：</strong></p><p>用户接口层负责向用户显示信息和解释用户指令。这里的用户可能是：用户、程序、自动化测试和批处理脚本等等。</p></li><li><p><strong>应用层：</strong></p><p>应用层是很薄的一层，理论上不应该有业务规则或逻辑，主要面向用例和流程相关的操作。但应用层又位于领域层之上，因为领域层包含多个聚合，所以它可以协调多个聚合的服务和领域对象完成服务编排和组合，协作完成业务操作。</p><p>此外，应用层也是微服务之间交互的通道，它可以调用其它微服务的应用服务，完成微服务之间的服务组合和编排。</p></li><li><p><strong>领域层：</strong></p><p>领域层的作用是实现企业核心业务逻辑，通过各种校验手段保证业务的正确性。领域层主要体现领域模型的业务能力，它用来表达业务概念、业务状态和业务规则。</p><p>领域层包含聚合根、实体、值对象、领域服务等领域模型中的领域对象。</p></li><li><p><strong>基础设施层：</strong></p><p>基础层是贯穿所有层的，它的作用就是为其它各层提供通用的技术和基础服务，包括第三方工具、驱动、消息中间件、网关、文件、缓存以及数据库等。比较常见的功能还是提供数据库持久化。</p><p>基础层包含基础服务，它采用依赖倒置设计，封装基础资源服务，实现应用层、领域层与基础层的解耦，降低外部资源变化对应用的影响。</p></li></ul><h3 id="三层架构与四层架构对应"><a href="#三层架构与四层架构对应" class="headerlink" title="三层架构与四层架构对应"></a>三层架构与四层架构对应</h3><p>传统三层架构，如何演进到四层架构，可以参考下图对应关系：</p><p><img src="/images/1680723ca91aa57d719d5cdbc1d910a1.jpg" alt="img"></p><p>三层架构向DDD分层架构演进，主要发生在业务逻辑层和数据访问层。</p><p>DDD分层架构对三层架构的业务逻辑层进行了更清晰的划分，改善了三层架构核心业务逻辑混乱，代码改动相互影响大的情况。DDD分层架构将业务逻辑层的服务拆分到了应用层和领域层。应用层快速响应前端的变化，领域层实现领域模型的能力。</p><p>另外一个重要的变化发生在数据访问层和基础层之间。三层架构数据访问采用DAO方式；DDD分层架构的数据库等基础资源访问，采用了仓储（Repository）设计模式，通过依赖倒置实现各层对基础资源的解耦。</p><p>仓储又分为两部分：仓储接口和仓储实现。仓储接口放在领域层中，仓储实现放在基础层。原来三层架构通用的第三方工具包、驱动、Common、Utility、Config等通用的公共的资源类统一放到了基础层。</p><h2 id="五层架构"><a href="#五层架构" class="headerlink" title="五层架构"></a>五层架构</h2><p>五层架构是基于四层架构和DCI架构扩展而来的，先了解一下DCI架构</p><h3 id="DCI"><a href="#DCI" class="headerlink" title="DCI"></a>DCI</h3><p>James O. Coplien和Trygve Reenskaug在2009年发表了一篇论文《DCI架构：面向对象编程的新构想》，标志着DCI架构模式的诞生。</p><p>DCI是数据Data 场景Context 交互Interactions的简称，DCI是一种特别关注行为的模式(可以对应GoF行为模式)，而MVC模式是一种结构性模式，MVC模式由于结构化，而可能忽视了行为事件。</p><p>DCI目前广泛被看作是对DDD的一种发展和补充，用在基于面向对象的领域建模上。</p><p>DCI 包括三层架构：</p><ul><li><p><strong>Data层：</strong></p><p>述系统有哪些领域概念及其之间的关系，该层专注于领域对象的确立和这些对象的生命周期管理及关系，让程序员站在对象的角度思考系统，从而让“系统是什么”更容易被理解。</p></li><li><p><strong>Context层：</strong></p><p>是尽可能薄的一层。Context往往被实现得无状态，只是找到合适的role，让role交互起来完成业务逻辑即可。但是简单并不代表不重要，显示化context层正是为人去理解软件业务流程提供切入点和主线。</p></li><li><p><strong>Interactive层：</strong></p><p>主要体现在对role的建模，role是每个context中复杂的业务逻辑的真正执行者，体现“系统做什么”。role所做的是对行为进行建模，它联接了context和领域对象。由于系统的行为是复杂且多变的，role使得系统将稳定的领域模型层和多变的系统行为层进行了分离，由role专注于对系统行为进行建模。该层往往关注于系统的可扩展性，更加贴近于软件工程实践，在面向对象中更多的是以类的视角进行思考设计。</p></li></ul><p>引入DCI后，DDD四层架构模式中的Domain层变薄了，以前Domain层对应DCI中的三层，而现在：</p><ol><li>Domain层只保留了DCI中的Data层和Interaction层，我们在实践中通常将这两层使用目录隔离，即通过两个目录object和role来分离层Data和Interaction</li><li>DCI中的Context层从Domain层上移变成Context层</li></ol><p>因此，DDD分层架构模式就变成了五层，如下：</p><p><img src="/images/webp-20230228194601354" alt="img"></p><h3 id="各层职能-3"><a href="#各层职能-3" class="headerlink" title="各层职能"></a>各层职能</h3><ul><li><p><strong>用户接口层：</strong></p><p>主要用于处理用户发送的Restful请求和解析用户输入的配置文件等，并将信息传递给Application层的接口。</p></li><li><p><strong>应用层：</strong></p><p>负责多进程管理及调度、多线程管理及调度、多协程调度和维护业务实例的状态模型。当调度层收到用户接口层的请求后，委托Context层与本次业务相关的上下文进行处理。</p></li><li><p><strong>环境层：</strong></p><p>以上下文为单位，将Domain层的领域对象cast成合适的role，让role交互起来完成业务逻辑。</p></li><li><p><strong>领域层：</strong></p><p>定义领域模型，不仅包括领域对象及其之间关系的建模，还包括对象的角色role的显式建模。</p></li><li><p><strong>基础实施层：</strong></p><p>为其他层提供通用的技术能力：业务平台，编程框架，持久化机制，消息机制，第三方库的封装，通用算法，等等。</p></li></ul><h2 id="六层架构"><a href="#六层架构" class="headerlink" title="六层架构"></a>六层架构</h2><p>在面向控制面或管理面且消息交互比较多的系统中，五层架构可以变体为六层架构，如下：</p><p><img src="/images/webp-20230228194615167" alt="img"></p><h3 id="各层职能-4"><a href="#各层职能-4" class="headerlink" title="各层职能"></a>各层职能</h3><ul><li><p><strong>用户接口层：</strong></p><p>主要用于处理用户发送的Restful请求和解析用户输入的配置文件等，并将信息传递给Scheduler层的接口。</p></li><li><p><strong>调度层：</strong></p><p>负责多进程管理及调度、多线程管理及调度、多协程调度和维护业务实例的状态模型。当调度层收到用户接口层的请求后，委托Transaction层与本次操作相关的事务进行处理。</p></li><li><p><strong>事务层：</strong></p><p>对应一个业务流程，比如UE Attach，将多个同步消息或异步消息的处理序列组合成一个事务，而且在大多场景下，都有选择结构。万一事务执行失败，则立即进行回滚。当事务层收到调度层的请求后，委托Context层的Action进行处理，常常还伴随使用Context层的Specification（谓词）进行Action的选择。</p></li><li><p><strong>环境层：</strong></p><p>以Action为单位，处理一条同步消息或异步消息，将Domain层的领域对象cast成合适的role，让role交互起来完成业务逻辑。环境层通常也包括Specification的实现，即通过Domain层的知识去完成一个条件判断。</p></li><li><p><strong>领域层：</strong></p><p>定义领域模型，不仅包括领域对象及其之间关系的建模，还包括对象的角色role的显式建模。</p></li><li><p><strong>基础实施层：</strong></p><p>为其他层提供通用的技术能力：业务平台，编程框架，持久化机制，消息机制，第三方库的封装，通用算法，等等。</p></li></ul><h1 id="三种架构对比分析"><a href="#三种架构对比分析" class="headerlink" title="三种架构对比分析"></a>三种架构对比分析</h1><p>虽然DDD分层架构、整洁架构、六边形架构的架构模型表现形式不一样，但这三种架构模型的核心思想是一致的，都是以领域模型为中心的设计思想，都完美体现了高内聚低耦合的原则。</p><p><img src="/images/b2e4dad1040857b5aedf0b1675ae4171.png" alt="img"></p><p>关注图中的红色线框，它们是非常重要的分界线，这三种架构里面都有，它的作用就是将核心业务逻辑与外部应用、基础资源进行隔离。</p><p>红色框内部主要实现核心业务逻辑，但核心业务逻辑也是有差异的，有的业务逻辑属于领域模型的能力，有的则属于面向用户的用例和流程编排能力。按照这种功能的差异，我们在这三种架构中划分了应用层和领域层，来承担不同的业务逻辑。</p><p>领域层实现面向领域模型，实现领域模型的核心业务逻辑，属于原子模型，它需要保持领域模型和业务逻辑的稳定，对外提供稳定的细粒度的领域服务，所以它处于架构的核心位置。</p><p>应用层实现面向用户操作相关的用例和流程，对外提供粗粒度的API服务。它就像一个齿轮一样进行前台应用和领域层的适配，接收前台需求，随时做出响应和调整，尽量避免将前台需求传导到领域层。应用层作为配速齿轮则位于前台应用和领域层之间。</p><h1 id="DDD分层架构代码结构"><a href="#DDD分层架构代码结构" class="headerlink" title="DDD分层架构代码结构"></a>DDD分层架构代码结构</h1><p>来自极客时间中的DDD实战课：<a href="https://time.geekbang.org/column/article/165248">https://time.geekbang.org/column/article/165248</a></p><p>按最常用的四层架构，目录结构如下：</p><ol><li><p>用户接口层</p><p><img src="/images/c6ea040a520c91dfe6400f206ff36fef.jpg" alt="img"></p><p><strong>Assembler：</strong>实现DTO与领域对象之间的相互转换和数据交换。一般来说Assembler与DTO总是一同出现。</p><p><strong>Dto：</strong>它是数据传输的载体，内部不存在任何业务逻辑，我们可以通过DTO把内部的领域对象与外界隔离。</p><p><strong>Facade：</strong>提供较粗粒度的调用接口，将用户请求委派给一个或多个应用服务进行处理。</p></li><li><p>应用层</p><p><img src="/images/30caee3ceaf1085b7aa2cc388f996e61.jpg" alt="img"></p><p><strong>Event（事件）：</strong>这层目录主要存放事件相关的代码。它包括两个子目录：publish 和 subscribe。前者主要存放事件发布相关代码，后者主要存放事件订阅相关代码（事件处理相关的核心业务逻辑在领域层实现）。</p><blockquote><p> 虽然应用层和领域层都可以进行事件的发布和处理，但为了实现事件的统一管理，建议将微服务内所有事件的发布和订阅的处理都统一放到应用层，事件相关的核心业务逻辑实现放在领域层。通过应用层调用领域层服务，来实现完整的事件发布和订阅处理流程。</p></blockquote><p><strong>Service（应用服务）：</strong>这层的服务是应用服务。应用服务会对多个领域服务或外部应用服务进行封装、编排和组合，对外提供粗粒度的服务。应用服务主要实现服务组合和编排，是一段独立的业务逻辑。</p></li><li><p>领域层</p><p><img src="/images/688dd55b8399779baff8fc5b7c124c2c.jpg" alt="img"></p><p><strong>Aggregate（聚合）：</strong>它是聚合软件包的根目录，可以根据实际项目的聚合名称命名，比如权限聚合。在聚合内定义聚合根、实体和值对象以及领域服务之间的关系和边界。聚合内实现高内聚的业务逻辑，它的代码可以独立拆分为微服务。</p><p><strong>Entity（实体）：</strong>它存放聚合根、实体、值对象以及工厂模式（Factory）相关代码。实体类采用充血模型，同一实体相关的业务逻辑都在实体类代码中实现。跨实体的业务逻辑代码在领域服务中实现。</p><p><strong>Event（事件）：</strong>它存放事件实体以及与事件活动相关的业务逻辑代码。</p><p><strong>Service（领域服务）：</strong>它存放领域服务代码。一个领域服务是多个实体组合出来的一段业务逻辑。你可以将聚合内所有领域服务都放在一个领域服务类中，你也可以把每一个领域服务设计为一个类。如果领域服务内的业务逻辑相对复杂，我建议你将一个领域服务设计为一个领域服务类，避免由于所有领域服务代码都放在一个领域服务类中，而出现代码臃肿的问题。领域服务封装多个实体或方法后向上层提供应用服务调用。</p><p><strong>Repository（仓储）：</strong>它存放所在聚合的查询或持久化领域对象的代码，通常包括仓储接口和仓储实现方法。为了方便聚合的拆分和组合，我们设定了一个原则：一个聚合对应一个仓储。</p></li><li><p>基础设施层</p><p><img src="/images/5bbe3454e2ecf4ff4770e887a4967b5a.jpg" alt="img"></p><p><strong>Config：</strong>主要存放配置相关代码。</p><p><strong>Util：</strong>主要存放平台、开发框架、消息、数据库、缓存、文件、总线、网关、第三方类库、通用算法等基础代码，你可以为不同的资源类别建立不同的子目录。</p></li></ol><p>还可以参考下面项目：</p><ul><li>COLA架构：<a href="https://github.com/alibaba/COLA">https://github.com/alibaba/COLA</a></li><li>DDD demo：<a href="https://github.com/citerus/dddsample-core">https://github.com/citerus/dddsample-core</a></li></ul><h1 id="DDD分层架构命名规范"><a href="#DDD分层架构命名规范" class="headerlink" title="DDD分层架构命名规范"></a>DDD分层架构命名规范</h1><p>可以参考下面命名规范，来做到见名之意</p><p><img src="/images/54fbb2fb43166d22431bc9244c7930fd9152d2f2.png" alt="img"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.jianshu.com/p/a775836c7e25?from=groupmessage">https://www.jianshu.com/p/a775836c7e25?from=groupmessage</a></li><li><a href="https://time.geekbang.org/column/article/156849">https://time.geekbang.org/column/article/156849</a></li><li><a href="https://baijiahao.baidu.com/s?id=1730410669695261834&amp;wfr=spider&amp;for=pc">https://baijiahao.baidu.com/s?id=1730410669695261834&amp;wfr=spider&amp;for=pc</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;DDD更重要的是战略设计，DDD分层架构只是实现DDD的一种方式，但不限这一种，如六边形架构、整洁架构等。&lt;/p&gt;
&lt;p&gt;六边形架构、整洁架</summary>
      
    
    
    
    <category term="DDD" scheme="http://yoursite.com/categories/DDD/"/>
    
    
    <category term="DDD" scheme="http://yoursite.com/tags/DDD/"/>
    
  </entry>
  
  <entry>
    <title>DDD-领域事件</title>
    <link href="http://yoursite.com/2023/02/01/DDD-%E9%A2%86%E5%9F%9F%E4%BA%8B%E4%BB%B6/"/>
    <id>http://yoursite.com/2023/02/01/DDD-%E9%A2%86%E5%9F%9F%E4%BA%8B%E4%BB%B6/</id>
    <published>2023-02-01T08:09:43.000Z</published>
    <updated>2023-04-16T13:46:53.144Z</updated>
    
    <content type="html"><![CDATA[<h1 id="领域事件"><a href="#领域事件" class="headerlink" title="领域事件"></a>领域事件</h1><p>领域事件是领域模型中非常重要的一部分，用来表示领域中发生的事件。一个领域事件将导致进一步的业务操作，在实现业务解耦的同时，还有助于形成完整的业务闭环。</p><p>领域事件驱动设计可以切断领域模型之间的强依赖关系，事件发布完成后，发布方不必关心后续订阅方事件处理是否成功，这样可以实现领域模型的解耦，维护领域模型的独立性和数据的一致性。在领域模型映射到微服务系统架构时，领域事件可以解耦微服务，微服务之间的数据不必要求强一致性，而是基于事件的最终一致性。</p><p>一次事务最多只能更改一个聚合的状态。如果一次业务操作涉及多个聚合状态的更改，应采用领域事件的最终一致性。</p><h2 id="微服务内领域事件"><a href="#微服务内领域事件" class="headerlink" title="微服务内领域事件"></a>微服务内领域事件</h2><p>当领域事件发生在微服务内的聚合之间，领域事件发生后完成事件实体构建和事件数据持久化，发布方聚合将事件发布到事件总线，订阅方接收事件数据完成后续业务操作。</p><p>在一个进程中的领域事件一般不需要使用消息中间件，可以使用类似<code>Guava EvenBus</code>的第三方事件总线。</p><h2 id="微服务间领域事件"><a href="#微服务间领域事件" class="headerlink" title="微服务间领域事件"></a>微服务间领域事件</h2><p>跨微服务的领域事件会在不同的限界上下文或领域模型之间实现业务协作，其主要目的是实现微服务解耦，减轻微服务之间实时服务访问的压力。</p><p>跨微服务的事件机制要总体考虑事件构建、发布和订阅、事件数据持久化、消息中间件，甚至事件数据持久化时还可能需要考虑引入分布式事务机制等。</p><h1 id="领域事件架构"><a href="#领域事件架构" class="headerlink" title="领域事件架构"></a>领域事件架构</h1><h2 id="1-事件构建和发布"><a href="#1-事件构建和发布" class="headerlink" title="1. 事件构建和发布"></a>1. 事件构建和发布</h2><p>领域事件包括基本属性和业务属性，事件实体依赖聚合根。领域事件发生后，事件中的业务数据不再修改。</p><p>基本属性：至少包括事件唯一标识、发生时间、事件类型和事件源，其中事件唯一标识应该是全局唯一的，以便事件能够无歧义地在多个限界上下文中传递。事件基本属性主要记录事件自身以及事件发生背景的数据。</p><p>业务属性：用于记录事件发生那一刻的业务数据，这些数据会随事件传输到订阅方，以开展下一步的业务操作。</p><p>可以创建基类来保证事件结构的统一，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DomainEvent</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String eventId;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> timestamp;</span><br><span class="line">  <span class="keyword">private</span> String eventType;</span><br><span class="line">  <span class="keyword">private</span> String source;</span><br><span class="line">  <span class="keyword">private</span> T data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-事件数据持久化"><a href="#2-事件数据持久化" class="headerlink" title="2. 事件数据持久化"></a>2. 事件数据持久化</h2><p>事件数据持久化可用于系统之间的数据对账，或者实现发布方和订阅方事件数据的审计。当遇到消息中间件、订阅方系统宕机或者网络中断，在问题解决后仍可继续后续业务流转，保证数据的一致性。</p><p>对于领域事件敏感的业务，可以将事件持久化到数据库：</p><ul><li>持久化到本业务数据库中，利用本地事务保证业务和事件数据的一致性</li><li>持久化到共享的事件数据库中，业务数据库和事件数据库不在一个数据库中，它们的数据持久化操作会跨数据库，可能需要分布式事务保证事件和业务的一致性</li></ul><p>对于领域事件不太敏感的业务，可以将事件异步的同步到日志中心或离线数仓中</p><h2 id="3-事件总线"><a href="#3-事件总线" class="headerlink" title="3. 事件总线"></a>3. 事件总线</h2><p>事件总线是进程内模型，是实现服务内聚合之间领域事件的重要组件，它提供事件分发和接收等服务。流程大致如下：</p><ul><li>如果是微服务内的订阅者（其它聚合），则直接分发到指定订阅者</li><li>如果是微服务外的订阅者，将事件数据保存到事件库（表）并异步发送到消息中间件</li><li>如果同时存在微服务内和外订阅者，则先分发到内部订阅者，将事件消息保存到事件库（表），再异步发送到消息中间件</li></ul><h2 id="4-消息中间件"><a href="#4-消息中间件" class="headerlink" title="4. 消息中间件"></a>4. 消息中间件</h2><p>跨微服务的领域事件大多会用到消息中间件，实现跨微服务的事件发布和订阅。</p><h2 id="5-事件接收和处理"><a href="#5-事件接收和处理" class="headerlink" title="5. 事件接收和处理"></a>5. 事件接收和处理</h2><p>微服务订阅方在应用层采用监听机制，接收消息队列中的事件数据，完成事件数据的持久化后，就可以开始进一步的业务处理。领域事件处理可在领域服务中实现。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;领域事件&quot;&gt;&lt;a href=&quot;#领域事件&quot; class=&quot;headerlink&quot; title=&quot;领域事件&quot;&gt;&lt;/a&gt;领域事件&lt;/h1&gt;&lt;p&gt;领域事件是领域模型中非常重要的一部分，用来表示领域中发生的事件。一个领域事件将导致进一步的业务操作，在实现业务解耦的同时，还</summary>
      
    
    
    
    <category term="DDD" scheme="http://yoursite.com/categories/DDD/"/>
    
    
    <category term="DDD" scheme="http://yoursite.com/tags/DDD/"/>
    
  </entry>
  
  <entry>
    <title>DDD-基础概念</title>
    <link href="http://yoursite.com/2023/01/01/DDD-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <id>http://yoursite.com/2023/01/01/DDD-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</id>
    <published>2023-01-01T08:09:43.000Z</published>
    <updated>2023-04-16T13:45:41.501Z</updated>
    
    <content type="html"><![CDATA[<p>DDD基础概念比较多，都是新的名词，刚开始接触会比较混乱。而且有些名词也比较晦涩难懂，这里统一学习整理DDD相关的基础概念。</p><p>这些基础概念，在架构设计、业务建模和实际开发过程中不一定用到，或不全用到。但是这些概念可以帮助理解DDD的核心思想和理念，在实际操作中可以借鉴。</p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>主要包括领域、子域、核心域、通用域、支撑域、限界上下文、聚合、聚合根、实体、值对象等等</p><h2 id="领域和子域"><a href="#领域和子域" class="headerlink" title="领域和子域"></a>领域和子域</h2><p>领域是用来限定业务边界和范围的，领域越大，业务范围就越大，反之则相反。</p><p>领域可以进一步划分为子领域。划分出来的多个子领域称为子域，每个子域对应一个更小的问题域或更小的业务范围。</p><p>领域划分通常的做法就是将问题一步一步地细分，再针对细分出来的问题域，逐个深入研究，探索和建立所有子域。</p><h2 id="核心域、通用域和支撑域"><a href="#核心域、通用域和支撑域" class="headerlink" title="核心域、通用域和支撑域"></a>核心域、通用域和支撑域</h2><p>在领域不断划分的过程中，领域会细分为不同的子域，子域可以根据自身重要性和功能属性划分为三类子域：<strong>核心域、通用域和支撑域</strong></p><p>核心域：业务的核心子域。包含核心的业务特性</p><p>通用域：具有通用功能的子域。可以同时被多个子域使用</p><p>支撑域：既不包含<strong>核心</strong>的业务特性，也不包含通用功能的子域。包含非核心的业务特性</p><h2 id="限界上下文"><a href="#限界上下文" class="headerlink" title="限界上下文"></a>限界上下文</h2><h3 id="通用语言"><a href="#通用语言" class="headerlink" title="通用语言"></a>通用语言</h3><p>在事件风暴过程中，通过团队交流达成共识的，能够简单、清晰、准确描述业务涵义和规则的语言就是通用语言</p><p>通用语言是团队统一的语言，不管你在团队中承担什么角色，在同一个领域的软件生命周期里都使用统一的语言进行交流</p><p>通用语言作用是解决交流障碍问题，确保业务需求的正确表达。</p><h3 id="限界上下文-1"><a href="#限界上下文-1" class="headerlink" title="限界上下文"></a>限界上下文</h3><p>通用语言是有语义环境的，限界上下文是用来确定语义所在的领域边界</p><p><strong>限界上下文 = 限界 + 上下文</strong>，限界：领域边界，上下文：语义环境</p><p>通过领域的限界上下文，我们就可以在统一的领域边界内用统一的语言进行交流</p><p><strong>通用语言确定了项目团队内部交流的统一语言，而这个语言所在的语义环境则是由限界上下文来限定的，以确保语义的唯一性</strong></p><h2 id="实体和值对象"><a href="#实体和值对象" class="headerlink" title="实体和值对象"></a>实体和值对象</h2><p>实体和值对象是组成领域模型的基础单元</p><h3 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h3><p><strong>实体一般对应业务对象，它具有业务属性和业务行为</strong></p><ul><li><p>业务形态：按照一定的业务规则将依存度高和业务关联紧密的多个实体对象和值对象进行聚类，形成聚合</p></li><li><p>代码形态：在DDD里，这些实体类通常采用充血模型，与这个实体相关的所有业务逻辑都在实体类的方法中实现，跨多个实体的领域逻辑则在领域服务中实现</p></li><li><p>运行形态：每个实体对象都有唯一的ID，并且ID始终保持不变</p></li><li><p>数据库形态：在领域模型映射到数据模型时，一个实体可能对应0个、1个或者多个数据库持久化对象。大多数情况下实体与持久化对象是一对一。在某些场景中，有些实体只是暂驻静态内存的一个运行态实体，它不需要持久化</p></li></ul><h3 id="值对象"><a href="#值对象" class="headerlink" title="值对象"></a>值对象</h3><p><strong>值对象主要是属性集合，对实体的状态和特征进行描述</strong></p><p>通过对象属性值来识别的对象，它将多个相关属性组合为一个概念整体。在DDD中用来描述领域的特定方面，并且是一个没有标识符的对象，叫作值对象</p><p>值对象本质上就是一个集合。集合里包括若干个用于描述目的、具有整体概念和不可修改的属性。那这个集合存在的意义又是什么？在领域建模的过程中，<strong>值对象可以保证属性归类的清晰和概念的完整性，避免属性零碎</strong></p><ul><li>业务形态：是领域模型中的一个基础对象，包含若干属性，与实体一起构成聚合</li><li>代码形态：值对象是单一属性，则直接定义为实体类的属性；如果值对象是属性集合，则把它设计为Class类</li><li>运行形态：两种方式：以属性嵌入的方式嵌入到实体对象中；以序列化后的JSON嵌入到实体对象</li><li>数据库形态：在领域建模时，我们可以将部分对象设计为值对象，保留对象的业务涵义，同时又减少了实体的数量；在数据建模时，我们可以将值对象嵌入实体，减少实体表的数量，简化数据库设计</li></ul><h3 id="实体与值对象关系"><a href="#实体与值对象关系" class="headerlink" title="实体与值对象关系"></a>实体与值对象关系</h3><p>实体和值对象是最基础的对象，一起实现实体最基本的核心领域逻辑</p><p>DDD提倡从领域模型设计出发，而不是先设计数据模型。传统的数据模型设计通常是一个表对应一个实体，一个主表关联多个从表，当实体表太多的时候就很容易陷入无穷无尽的复杂的数据库设计，领域模型就很容易被数据模型绑架</p><p><strong>值对象的优势是简化数据库设计，更注重领域模型</strong></p><h2 id="聚合和聚合根"><a href="#聚合和聚合根" class="headerlink" title="聚合和聚合根"></a>聚合和聚合根</h2><h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><p>领域模型内的实体和值对象就好比个体，而能让实体和值对象协同工作的组织就是聚合，它用来确保这些领域对象在实现共同的业务逻辑时，能保证数据的一致性。</p><p>聚合在DDD分层架构里属于领域层，领域层包含了多个聚合，共同实现核心业务逻辑。聚合内实体以充血模型实现个体业务能力，以及业务逻辑的高内聚。跨多个实体的业务逻辑通过领域服务来实现，跨多个聚合的业务逻辑通过应用服务来实现。</p><h3 id="聚合根"><a href="#聚合根" class="headerlink" title="聚合根"></a>聚合根</h3><p>聚合根的主要目的是为了避免由于复杂数据模型缺少统一的业务规则控制，而导致聚合、实体之间数据不一致性的问题。</p><p>聚合根也称为根实体，它不仅是实体，还是聚合的管理者：</p><ul><li><p>首先它作为实体本身，拥有实体的属性和业务行为，实现自身的业务逻辑。</p></li><li><p>其次它作为聚合的管理者，在聚合内部负责协调实体和值对象按照固定的业务规则协同完成共同的业务逻辑。</p></li></ul><p>在聚合之间，它还是聚合对外的接口人，以聚合根ID关联的方式接受外部任务和请求，在上下文内实现聚合之间的业务协同。也就是说，聚合之间通过聚合根ID关联引用，如果需要访问其它聚合的实体，就要先访问聚合根，再导航到聚合内部实体，外部对象不能直接访问聚合内实体。</p><h3 id="聚合设计原则"><a href="#聚合设计原则" class="headerlink" title="聚合设计原则"></a>聚合设计原则</h3><p><strong>1. 在一致性边界内建模真正的不变条件。</strong>聚合用来封装真正的不变性，而不是简单地将对象组合在一起。聚合内有一套不变的业务规则，各实体和值对象按照统一的业务规则运行，实现对象数据的一致性，边界之外的任何东西都与该聚合无关，这就是聚合能实现业务高内聚的原因。</p><p><strong>2. 设计小聚合。</strong>如果聚合设计得过大，聚合会因为包含过多的实体，导致实体之间的管理过于复杂，高频操作时会出现并发冲突或者数据库锁，最终导致系统可用性变差。而小聚合设计则可以降低由于业务过大导致聚合重构的可能性，让领域模型更能适应业务的变化。</p><p><strong>3. 通过唯一标识引用其它聚合。</strong>聚合之间是通过关联外部聚合根ID的方式引用，而不是直接对象引用的方式。外部聚合的对象放在聚合边界内管理，容易导致聚合的边界不清晰，也会增加聚合之间的耦合度。</p><p><strong>4. 在边界之外使用最终一致性。</strong>聚合内数据强一致性，而聚合之间数据最终一致性。在一次事务中，最多只能更改一个聚合的状态。如果一次业务操作涉及多个聚合状态的更改，应采用领域事件的方式异步修改相关的聚合，实现聚合之间的解耦（相关内容我会在领域事件部分详解）。</p><p><strong>5. 通过应用层实现跨聚合的服务调用。</strong>为实现微服务内聚合之间的解耦，以及未来以聚合为单位的微服务组合和拆分，应避免跨聚合的领域服务调用和跨聚合的数据库表关联。</p><h2 id="聚合、聚合根、实体、值对象特点总结"><a href="#聚合、聚合根、实体、值对象特点总结" class="headerlink" title="聚合、聚合根、实体、值对象特点总结"></a>聚合、聚合根、实体、值对象特点总结</h2><p><strong>聚合的特点：</strong>高内聚、低耦合，它是领域模型中最底层的边界，可以作为拆分微服务的最小单位，但不建议对微服务过度拆分。但在对性能有极致要求的场景中，聚合可以独立作为一个微服务，以满足版本的高频发布和极致的弹性伸缩能力。</p><p>一个微服务可以包含多个聚合，聚合之间的边界是微服务内天然的逻辑边界。有了这个逻辑边界，在微服务架构演进时就可以以聚合为单位进行拆分和组合了，微服务的架构演进也就不再是一件难事了。</p><p><strong>聚合根的特点：</strong>聚合根是实体，有实体的特点，具有全局唯一标识，有独立的生命周期。一个聚合只有一个聚合根，聚合根在聚合内对实体和值对象采用直接对象引用的方式进行组织和协调，聚合根与聚合根之间通过ID关联的方式实现聚合之间的协同。</p><p><strong>实体的特点：</strong>有ID标识，通过ID判断相等性，ID在聚合内唯一即可。状态可变，它依附于聚合根，其生命周期由聚合根管理。实体一般会持久化，但与数据库持久化对象不一定是一对一的关系。实体可以引用聚合内的聚合根、实体和值对象。</p><p><strong>值对象的特点：</strong>无ID，不可变，无生命周期，用完即扔。值对象之间通过属性值判断相等性。它的核心本质是值，是一组概念完整的属性组成的集合，用于描述实体的状态和特征。值对象尽量只引用值对象。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;DDD基础概念比较多，都是新的名词，刚开始接触会比较混乱。而且有些名词也比较晦涩难懂，这里统一学习整理DDD相关的基础概念。&lt;/p&gt;
&lt;p&gt;这些基础概念，在架构设计、业务建模和实际开发过程中不一定用到，或不全用到。但是这些概念可以帮助理解DDD的核心思想和理念，在实际操作中</summary>
      
    
    
    
    <category term="DDD" scheme="http://yoursite.com/categories/DDD/"/>
    
    
    <category term="DDD" scheme="http://yoursite.com/tags/DDD/"/>
    
  </entry>
  
  <entry>
    <title>常用方法论总结</title>
    <link href="http://yoursite.com/2022/11/25/%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E8%AE%BA%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2022/11/25/%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E8%AE%BA%E6%80%BB%E7%BB%93/</id>
    <published>2022-11-25T08:09:43.000Z</published>
    <updated>2023-04-16T13:22:05.321Z</updated>
    
    <content type="html"><![CDATA[<h2 id="5WHY"><a href="#5WHY" class="headerlink" title="5WHY"></a>5WHY</h2><blockquote><p>根因分析法</p></blockquote><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>根本原因分析的一种方法，所谓5why分析法，又称“5问法”，也就是对一个问题点连续以5个“为什么”来自问，以追究其根本原因。</p><p>虽为5个为什么，但使用时不限定只做“5次为什么的探讨”，主要是必须找到根本原因为止，有时可能只要3次，有时也许要10次，如古话所言：打破砂锅问到底。</p><p>5why法的关键所在：鼓励解决问题的人要努力避开主观或自负的假设和逻辑陷阱，从结果着手，沿着因果关系链条，顺藤摸瓜，直至找出原有问题的根本原因。</p><h3 id="实施"><a href="#实施" class="headerlink" title="实施"></a>实施</h3><p>5WHY从三个层面来实施：</p><p>一、为什么会发生？从“制造”的角度。</p><p>二、为什么没有发现？从“检验”的角度。</p><p>三、为什么没有从系统上预防事故？从“体系”或“流程”的角度。</p><p>每个层面连续5次或N次的询问，得出最终结论。只有以上三个层面的问题都探寻出来，才能发现根本问题，并寻求解决。</p><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>丰田汽车公司前副社长大野耐一曾举了一个例子来找出停机的真正原因</p><p>问题一：为什么机器停了？</p><p>答案一：因为机器超载，保险丝烧断了。</p><p>问题二：为什么机器会超载？</p><p>答案二：因为轴承的润滑不足。</p><p>问题三：为什么轴承会润滑不足？</p><p>答案三：因为润滑泵失灵了。</p><p>问题四：为什么润滑泵会失灵？</p><p>答案四：因为它的轮轴耗损了。</p><p>问题五：为什么润滑泵的轮轴会耗损？</p><p>答案五：因为杂质跑到里面去了。</p><p>经过连续五次不停地问“为什么”，才找到问题的真正原因和解决的方法，在润滑泵上加装滤网。</p><p>如果员工没有以这种追根究底的精神来发掘问题，他们很可能只是换根保险丝草草了事，真正的问题还是没有解决。</p><h2 id="5W1H-amp-5W2H"><a href="#5W1H-amp-5W2H" class="headerlink" title="5W1H&amp;5W2H"></a>5W1H&amp;5W2H</h2><blockquote><p>问题分析法</p></blockquote><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>5W+1H：也称<strong>六何分析法</strong>，是一种思考方法，也是一种创造技法。是对选定的项目、工序或操作，都要从原因（何因Why）、对象（何事What）、地点（何地Where）、时间（何时When）、人员（何人Who）、方法（何法How）等六个方面提出问题进行思考。</p><p>1、<strong>对象 （What）</strong>——什么事情</p><p>公司生产什么产品？车间生产什么零配件？为什么要生产这5W1H分析法思路个产品？能不能生产别的？我到底应该生产什么？例如:如果这个产品不挣钱，换个利润高点的好不好？</p><p>2、<strong>场所 （Where）</strong>——什么地点</p><p>生产是在哪里干的？为什么偏偏要在这个地方干？换个地方行不行？到底应该在什么地方干？这是选择工作场所应该考虑的。</p><p>3、<strong>时间和程序 （When）</strong>——什么时候</p><p>例如这个工序或者零部件是在什么时候干的？为什么要在这个时候干？能不能在其他时候干？把后工序提到前面行不行？到底应该在什么时间干？</p><p>4、<strong>人员 （Who）</strong>——责任人</p><p>这个事情是谁在干？为什么要让他干？如果他既不负责任，脾气又很大，是不是可以换个人？有时候换一个人，整个生产就有起色了。</p><p>5、<strong>为什么（Why）</strong>——原因</p><p>为什么采用这个技术参数？为什么不能有变动？为什么不能使用？为什么变成红色？为什么要做成这个形状？为什么采用机器代替人力？为什么非做不可？</p><p>6、<strong>方式 （How）</strong>——如何</p><p>手段也就是工艺方法，例如，我们是怎样干的？为什么用这种方法来干？有没有别的方法可以干？到底应该怎么干？有时候方法一改，全局就会改变。</p><h3 id="5W2H"><a href="#5W2H" class="headerlink" title="5W2H"></a>5W2H</h3><p>5W2H分析法又叫<strong>七问分析法</strong>，是二战中美国陆军兵器修理部首创。简单、方便，易于理解、使用，富有启发意义，广泛用于企业管理和技术活动，对于决策执行性的活动措施也非常有帮助，也有助于弥补考虑问题的疏漏。增加一项How much</p><h2 id="SWOT"><a href="#SWOT" class="headerlink" title="SWOT"></a>SWOT</h2><blockquote><p>战略分析法</p></blockquote><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p>SWOT分析法（也称TOWS分析法、道斯矩阵）即态势分析法，帮您清晰地把握全局，分析自己在资源方面的优势与劣势，把握环境提供的机会，防范可能存在的风险与威胁，对我们的成功有非常重要的意义</p><p>S （strengths）是优势、W （weaknesses）是劣势、O （opportunities）是机会、T （threats）是威胁</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>SWOT分析法是基于内外部竞争环境和竞争条件下的态势分析，就是将与研究对象密切相关的各种主要内部优势、劣势和外部的机会和威胁等，通过调查列举出来，并依照矩阵形式排列，然后用系统分析的思想，把各种因素相互匹配起来加以分析，从中得出一系列相应的结论，而结论通常带有一定的决策性。</p><p>运用这种方法，可以对研究对象所处的情景进行全面、系统、准确的研究，从而根据研究结果制定相应的发展战略、计划以及对策等。</p><h2 id="STAR"><a href="#STAR" class="headerlink" title="STAR"></a>STAR</h2><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h3><blockquote><p>STAR 法则最早用于面试，后来演变为 STARR，最后一个 R 是反思/Reflection</p><p>但 STARR 不仅适用于面试，也适用于工作小结，项目报告等各种场景</p></blockquote><p>所谓STAR原则，即Situation（情景）、Task（任务）、Action（行动）和Result（结果）四个英文单词的首字母组合，STARR则在STAR的基础上增加一个Reflection（反思）</p><h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><p>常见汇报场景使用。运用STAR法则进行工作的描述，可以让对方迅速了解你整个项目的前因后果，同时，也可以突出你在这个项目过程中的计划、组织、分析解决问题等方面的能力，这是一个十分优秀的汇报方式，需要在实际工作中好好理解运用。</p><p><strong>Situation</strong>：可以描述当时任务所处于的背景，任务类型是什么？为什么做这项任务？任务的紧迫程度怎么样？有多少人？项目排期多长等等，可以有效描述该任务的一些基本信息，使对方能够对项目有一个大致了解，方便继续进行沟通。</p><p><strong>Task：</strong>明确你在这个任务过程中所承担的职责，团队分工怎么样？你承担哪一块角色？可以使对方快速了解到你的工作内容。</p><p><strong>Action</strong>: 在具体的实施过程中，你采用了哪些手段，解决了哪些问题？可以使对方快速了解到你的业务能力以及工作难度等。</p><p><strong>Result：</strong>最终取得了什么样的结果。是你对该项任务的总结，这是一个可以量化的指标，用于度量工作成果。</p><h2 id="SMART"><a href="#SMART" class="headerlink" title="SMART"></a>SMART</h2><blockquote><p>目标管理</p></blockquote><h3 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h3><p>目标管理中需要遵循的原则，分别由Specific(具体的)、Measurable(可衡量)、Attainable（可达到）、Relevant（相关性）、Time－based（明确的截止期限）五个词组组成；</p><p>SMART通俗解读：把（什么对象），在（什么时间），通过（什么何种方法/手段），达到（什么状态）。</p><h3 id="具体介绍"><a href="#具体介绍" class="headerlink" title="具体介绍"></a>具体介绍</h3><ol><li>目标必须是具体的（Specific）stresses the need for a specific goal over and against a more general one. </li><li>目标必须是可以衡量的（Measurable）stresses the need for concrete criteria for measuring progress toward the attainment of the goal.</li><li>目标必须是可以达到的（Attainable）stresses the importance of goals that are realistic and attainable. </li><li>目标必须和总体目标具有相关性（Relevant）stresses the importance of choosing goals that matter. </li><li>目标必须具有明确的截止期限（Time-bound）stresses the importance of grounding goals within a time frame, giving them a target date.</li></ol><h3 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h3><p>SMART原则是一项制定合适目标的目标管理工具</p><p>人们在制定工作目标或者任务目标时，考虑一下目标与计划是不是SMART化的。只有具备SMART化的计划才是具有良好可实施性的，也才能指导保证计划得以实现</p><h2 id="PDCA"><a href="#PDCA" class="headerlink" title="PDCA"></a>PDCA</h2><blockquote><p>流程管理</p></blockquote><h3 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a>简介</h3><p><strong>PDCA（Plan-Do-Check-Adjust，中文为计划-执行-检核-调整）</strong>是一种循环式品质管理的过程，通过计划、执行、检核、调整四阶段来提高生产品质，改善生产过程，确保目标能够达成。这个概念是由美国现代产品品质控制的始祖爱德华兹·戴明（Edwards Deming）提出的，也被称为戴明环（Deming Wheel）。这个循环后续衍生了其他版本，如Plan-Do-Study-Act（PDSA）、Observation-Plan-Do-Study-Act（OPDCA）。</p><ul><li><strong>计划（Plan）：</strong>识别和理解当前的问题或机会，根据已有的信息和想法，建立一个明确的目标，并制定相关计划，确定必要的程序，进行组织分工，并确定好成功标准以及如何衡量执行结果与目标的差距。</li><li><strong>执行（Do）：</strong>先通过小规模试点进行安全测试，执行之前所制定的计划和程序，收集必要的信息来为下一步进行检验和调整提供依据。</li><li><strong>检核（Check）：</strong>研究上一步收集的信息，和预期的目标进行比较，通过列表或数据图显示出执行结果与预期结果的差距，并提出修改方案。</li><li><strong>调整（Adjust）：</strong>寻找适当的方法来缩减执行结果与计划目标之间的差距，有时会提出更详细的计划要求，来使得下一次重新执行循环时步骤更容易执行。</li></ul><h3 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h3><p>PDCA循环是一个持续改进模型，适用于日常工作和项目执行，生活中也适用</p><p>每一项工作，都是一个pdca循环，都需要计划、实施、检查结果，并进一步进行改进，同时进入下一个循环，只有在日积月累的渐进改善中，才可能会有质的飞跃，才可能取得完善每一项工作。</p><h2 id="SCQA"><a href="#SCQA" class="headerlink" title="SCQA"></a>SCQA</h2><blockquote><p>结构化表达</p></blockquote><h3 id="简介-6"><a href="#简介-6" class="headerlink" title="简介"></a>简介</h3><p>SCQA模型是一个“结构化表达”工具，是麦肯锡咨询顾问芭芭拉·明托在《金字塔原理》中提出的。</p><p><strong>S（Situation）情景</strong>——由大家都熟悉的情景、事实引入。<br><strong>C（Complication）冲突</strong>——实际情况往往和我们的要求有冲突。<br><strong>Q（Question）疑问</strong>——怎么办？<br><strong>A（Answer）回答</strong>——我们的解决方案是……</p><p>S情景陈述的通常是大家都熟悉的事，普遍认同的事，事情发生的背景。由此切入既不突兀又容易让大家产生共鸣，产生代入感，然后引出冲突C。Q是疑问，是根据前面的冲突从对方的角度提出他所关心的问题，最后A解答，是对Q的回答也是接下来我们要表达的中心思想。</p><p>整个结构其实是形成良好的沟通氛围，然后带出冲突和疑问，最后提供可行的解决方案。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li><p>常用于广告文案</p><p>得了灰指甲——陈述背景S<br>一个传染俩——在这个背景下发生了冲突C<br>问我怎么办？——站在对方的角度，提出疑惑Q<br>马上用亮甲！——给出解决方案A，这是文案要表达的重点</p><p>很多广告用的都是这个套路：用一个观众已经知道的“故事”来建立跟观众的链接（他们有这方面的背景经历和情感痛点），接着用冲突引起共鸣，最后用问题引出解决方案——快买我们的产品！</p></li><li><p>用于开场白、表达</p><table><thead><tr><th>用于开场白：</th><th></th></tr></thead><tbody><tr><td>S：situation（情景）</td><td>从我行实行企业业务专营模式以来，业务实现了快速增长，</td></tr><tr><td>C：complication（冲突）</td><td>但小企业客户资金自身平衡问题成了制约业务进一步发展的瓶颈</td></tr><tr><td>Q：question（疑问）</td><td>如何实现我行企业业务的可持续发展？</td></tr><tr><td>A：answer（回答）</td><td>我部计划面向客户推介xxx方案，实现业务联动、多方共赢。</td></tr></tbody></table></li><li><p>用于自我反思</p><table><thead><tr><th>用于自我反思：</th><th></th></tr></thead><tbody><tr><td>S：situation（情景）</td><td>我觉察到一天里只要我面对手机的时间偏长</td></tr><tr><td>C：complication（冲突）</td><td>就会出现效率底下，皮肤状态也不太好的情况。</td></tr><tr><td>Q：question（疑问）</td><td>手机就是一个黑洞，是一个浪费时间的坑，我该如何改变，避免掉入这样的坑呢？</td></tr><tr><td>A：answer（回答）</td><td>尽可能把零碎需要用手机的事情比如刷微博、逛淘宝、翻小红书、回微信、看闲鱼、查看手机短信……这类一打开手机就容易出现连锁反应不知不觉就浪费时间的APP都放在一个文件夹，然后集中在一个时间段查看，比如晚上泡脚的一小时里。其他时间有意识地觉察提醒自己不要翻看。</td></tr></tbody></table></li></ul><h2 id="RACI"><a href="#RACI" class="headerlink" title="RACI"></a>RACI</h2><blockquote><p>事情管理</p></blockquote><h3 id="简介-7"><a href="#简介-7" class="headerlink" title="简介"></a>简介</h3><p>在快速发展的过程中，会不时的冒出一些之前没有明确界定的事情，往往产生一些看似大家都在负责，事实上无人负责的事情。RACI模型对快速发展的我们的最重要的启发是：每件事都要尽早确定谁负责，也就是确定R。</p><p>RACI的一个扩展，RASCI，是更加全面及适用我们的情况的。</p><p><strong>谁负责（R = Responsible）</strong>：负责执行任务的角色，具体负责操控项目、解决问题。</p><p><strong>谁批准（A = Accountable）</strong>：对任务负全责的角色，只有经其同意或签署之后，项目才能得以进行。</p><p><strong>谁支持（S = Support）</strong>：参与具体任务，协助R完成工作的角色。</p><p><strong>咨询谁（C = Consulted）</strong>：在任务实施前或中提供指定性意见的人员。</p><p><strong>告知谁（I = Informed）</strong>：及时被通知结果的人员，不必向其咨询、征求意见。</p><h2 id="房子图"><a href="#房子图" class="headerlink" title="房子图"></a>房子图</h2><blockquote><p>战略卡片</p></blockquote><h3 id="简介-8"><a href="#简介-8" class="headerlink" title="简介"></a>简介</h3><p>战略卡片的样式即老板们常用的”房子图“</p><p>所谓房子图：其实是一种思维工具，通过从上向下的拆解，以负责人的视角分析手中的业务，最终解决“如何做”的问题。</p><p>做好一件事最重要的原则是做正确的事，而做正确的事最有效的方法之一，是从负责人的视角，通过完整的信息梳理，想清楚这件事的规划——这便是房子图的作用。</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>战略卡片包含4层结构，遵循金字塔原理逐层展开</p><ul><li><p>第一层：使命与愿景</p><p>所谓使命，就是你为什么要做这件事，或者说为什么要做这个产品。</p><p>所谓愿景，就是你期望中这件事/这个产品的理想状态是什么。</p><p>使命能让我们在做规划的时候，知道手头这件事的价值。明白了价值，才能从源头上产生驱动力。愿景能让我们知道目的地在哪里，知道了目的地，才能规划出一个合理的路径。</p></li><li><p>第二层：价值</p><p>价值又分成3个子卡片：客户价值；我们的核心能力/成功要素；如何评估我们提供了这些价值。</p></li><li><p>第三层：同业竞争</p><p>对比企业外部市场环境和内部能力现状</p></li><li><p>第四层：战略规划</p><p>战略规划与3年目标：以更长远的角度，凝练我们接下来一段时间的努力方向及目标；</p><p>复盘及1年目标：复盘上一阶段的目标、结果、原因、经验，提出未来1年我们的短期目标是什么，兼顾定量和定性；兼顾自评与他评；兼顾效率与效果</p><p>关键策略：将实现未来1年的目标的策略和路径进行提炼和规划</p></li></ul><p><strong>HR房子图：</strong></p><p><img src="/images/image-20221121113913810.png" alt="image-20221121113913810"></p><h2 id="海恩法则"><a href="#海恩法则" class="headerlink" title="海恩法则"></a>海恩法则</h2><h3 id="简介-9"><a href="#简介-9" class="headerlink" title="简介"></a>简介</h3><p>海恩法则：<strong>任何不安全事故都是可以预防的</strong>。</p><p>海恩法则是德国飞机涡轮机的发明者德国人帕布斯•海恩提出的一个在航空界关于飞行安全的法则。海恩法则指出: 每一起严重事故的背后，必然有29次轻微事故和300起未遂先兆以及1000起事故隐患。</p><p>虽然这一分析会随着飞行器的安全系数增加和飞行器的总量变化而发生变化，但它确实说明了飞行安全与事故隐患之间的必然联系。当然，这种联系不仅仅表现在飞行领域，在其他领域也同样发生着潜在的作用。</p><p>按照海恩法则分析，当一起重大事故发生后，我们在处理事故本身的同时，还要及时对同类问题的“事故征兆”和“事故苗头”进行排查处理，以此防止类似问题的重复发生，及时解决再次发生重大事故的隐患，把问题解决在萌芽状态。</p><h3 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h3><p>海恩法则强调两点：</p><p>一是事故的发生是量的积累的结果</p><p>二是再好的技术，再完美的规章，在实际操作层面，也无法取代人自身的素质和责任心 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;5WHY&quot;&gt;&lt;a href=&quot;#5WHY&quot; class=&quot;headerlink&quot; title=&quot;5WHY&quot;&gt;&lt;/a&gt;5WHY&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;根因分析法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot;</summary>
      
    
    
    
    <category term="方法论" scheme="http://yoursite.com/categories/%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
    
    <category term="方法论" scheme="http://yoursite.com/tags/%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>Java-Agent</title>
    <link href="http://yoursite.com/2022/11/12/Java-Agent/"/>
    <id>http://yoursite.com/2022/11/12/Java-Agent/</id>
    <published>2022-11-12T10:36:35.000Z</published>
    <updated>2022-11-25T08:21:53.471Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>Java Agent 直译过来叫做 Java 代理，但更多称叫做 Java 探针</p></blockquote><p>Java Agent是一种特殊的Java程序（Jar文件），与普通Java程序通过main方法启动不同，agent并不是一个可以单独启动的程序，而必须依附在一个Java应用程序（JVM）上，与它运行在同一个进程中，通过<code>Instrumentation API</code>与虚拟机交互</p><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="Instrumentation"><a href="#Instrumentation" class="headerlink" title="Instrumentation"></a>Instrumentation</h3><p><code>Instrumentation</code>是Java提供的一个来自JVM的接口，该接口提供了一系列查看和操作Java类定义的方法，例如修改类的字节码、向<code>classLoader</code>的<code>classpath</code>下加入jar文件等。使得开发者可以通过Java语言来操作和监控JVM内部的一些状态，进而实现Java程序的监控分析，甚至实现一些特殊功能（如AOP、热部署）</p><p>主流的JVM都提供了<code>Instrumentation</code>的实现，但是鉴于<code>Instrumentation</code>的特殊功能，并不适合直接提供在JDK的runtime里，而更适合出现在Java程序的外层，以上帝视角在合适的时机出现。因此如果想使用<code>Instrumentation</code>功能，<strong>「拿到Instrumentation实例，我们必须通过Java agent」</strong>，<code>Instrumentation</code>常用方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Instrumentation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//增加一个Class 文件的转换器，转换器用于改变 Class 二进制流的数据，参数 canRetransform 设置是否允许重新转换。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addTransformer</span><span class="params">(ClassFileTransformer transformer, <span class="keyword">boolean</span> canRetransform)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在类加载之前，重新定义 Class 文件，ClassDefinition 表示对一个类新的定义，</span></span><br><span class="line">    <span class="comment">//如果在类加载之后，需要使用 retransformClasses 方法重新定义。addTransformer方法配置之后，后续的类加载都会被Transformer拦截。</span></span><br><span class="line">    <span class="comment">//对于已经加载过的类，可以执行retransformClasses来重新触发这个Transformer的拦截。类加载的字节码被修改后，除非再次被retransform，否则不会恢复。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addTransformer</span><span class="params">(ClassFileTransformer transformer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除一个类转换器</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">removeTransformer</span><span class="params">(ClassFileTransformer transformer)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//是否允许对class retransform</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isRetransformClassesSupported</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在类加载之后，重新定义 Class。这个很重要，该方法是1.6 之后加入的，事实上，该方法是 update 了一个类。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">retransformClasses</span><span class="params">(Class&lt;?&gt;... classes)</span> <span class="keyword">throws</span> UnmodifiableClassException</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//是否允许对class重新定义</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isRedefineClassesSupported</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//此方法用于替换类的定义，而不引用现有的类文件字节，就像从源代码重新编译以进行修复和继续调试时所做的那样。</span></span><br><span class="line">    <span class="comment">//在要转换现有类文件字节的地方（例如在字节码插装中），应该使用retransformClasses。</span></span><br><span class="line">    <span class="comment">//该方法可以修改方法体、常量池和属性值，但不能新增、删除、重命名属性或方法，也不能修改方法的签名</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">redefineClasses</span><span class="params">(ClassDefinition... definitions)</span> <span class="keyword">throws</span>  ClassNotFoundException, UnmodifiableClassException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取已经被JVM加载的class，有className可能重复（可能存在多个classloader）</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span></span><br><span class="line">    Class[] getAllLoadedClasses();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中最常用的方法就是<code>addTransformer(ClassFileTransformer transformer)</code>了，这个方法可以在类加载时做拦截，对输入的类的字节码进行修改，其参数是一个<code>ClassFileTransformer</code>接口，定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 传入参数表示一个即将被加载的类，包括了classloader，classname和字节码byte[]</span></span><br><span class="line"><span class="comment"> * 返回值为需要被修改后的字节码byte[]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">byte</span>[] transform( ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, <span class="keyword">byte</span>[] classfileBuffer) <span class="keyword">throws</span> IllegalClassFormatException;</span><br></pre></td></tr></table></figure><p><code>addTransformer</code>方法配置之后，后续的类加载都会被<code>Transformer</code>拦截。对于已经加载过的类，可以执行<code>retransformClasses</code>来重新触发这个<code>Transformer</code>的拦截。类加载的字节码被修改后，除非再次被<code>retransform</code>，否则不会恢复</p><h3 id="Attach"><a href="#Attach" class="headerlink" title="Attach"></a>Attach</h3><p><code>Attach API</code>其实是跨JVM进程通讯的工具，能够将某种指令从一个JVM进程发送给另一个JVM进程</p><p><code>Attach</code>机制可以对目标进程收集很多信息，如内存<code>dump</code>，线程<code>dump</code>，类信息统计(比如加载的类及大小以及实例个数等)，动态加载agent，动态设置vm flag，打印vm flag，获取系统属性等等</p><h2 id="Java-Agent结构"><a href="#Java-Agent结构" class="headerlink" title="Java Agent结构"></a>Java Agent结构</h2><p>Java Agent 最终以 jar 包的形式存在。主要包含两个部分，一部分是实现代码，一部分是配置文件。配置文件放在 META-INF 目录下，文件名为 <code>MANIFEST.MF</code> </p><p>代码入口是<code>premain</code>或<code>agentmain</code>方法，具体选用哪个方法以及其中的内容根据应用场景决定</p><p>配置文件参数说明：</p><ul><li>Manifest-Version: 版本号</li><li>Created-By: 创作者</li><li>Agent-Class: agentmain方法所在类</li><li>Can-Redefine-Classes: 是否可以实现类的重定义</li><li>Can-Retransform-Classes: 是否可以实现字节码替换</li><li>Premain-Class: premain 方法所在类</li></ul><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>   Java Agent 技术有以下主要功能：</p><ul><li>在加载Java文件前拦截字节码并做修改</li><li>在运行期间变更已加载的类的字节码</li><li> 获取所有已经被加载过的类</li><li>获取所有已经被初始化过了的类</li><li>获取某个对象的大小</li></ul><p>基于这些功能，衍生出了很多常见工具，Java调式、热部署、线上诊断等工具都有依赖Java Agent：</p><ul><li><p>各个 Java IDE 的调试功能，例如 eclipse、IntelliJ </p></li><li><p>热部署功能，例如 JRebel、XRebel、spring-loaded</p></li><li><p>各种线上诊断工具，例如 Btrace、Greys，还有阿里的 Arthas</p></li><li><p>各种性能分析工具，例如 Visual VM、JConsole 等</p></li></ul><h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><p>Java Agent分为两种：静态<code>Agent</code>与动态<code>Agent</code></p><p><img src="/images/image-20221008202408373.png" alt="image-20221008202408373"></p><h2 id="静态Agent"><a href="#静态Agent" class="headerlink" title="静态Agent"></a>静态Agent</h2><p> 这种方式是使用<code>premain</code>作为<code>Agent</code>的入口方法，以JVM启动参数<code>-javaagent:xxx.jar</code>方式载入，在Java程序的<code>main</code>方法执行之前执行</p><ol><li><p>编写<code>premain</code>方法，应该包含以下两个方法中的一个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String args, Instrumentation inst)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String args)</span></span>;</span><br></pre></td></tr></table></figure><p>JVM 会优先加载带<code>Instrumentation</code>签名的方法1，加载成功忽略方法2，如果没有<code>Instrumentation</code>签名的方法，则加载方法2</p></li><li><p>定义一个<code>MANIFEST.MF</code>文件，其中必须包含Premain-Class选项</p></li><li><p>将包含<code>premain</code>的类与<code>MANIFEST.MF</code>配置文件打包成一个 jar 包</p></li><li><p>在JVM启动参数中添加<code>-javaagent:[path]</code>，其中的<code>path</code>为对应的<code>Agent</code>的jar包路径。这样则将<code>Agent</code>挂载成功，Java程序再执行<code>main</code>方法前执行</p></li></ol><h2 id="动态Agent"><a href="#动态Agent" class="headerlink" title="动态Agent"></a>动态Agent</h2><p> 与静态方式不同，动态<code>Agent</code>允许代理的目标程序的JVM先启动，再通过<code>attach</code>机制载入</p><ol><li><p>同样需要实现<code>agentmain</code>方法，加载优先级与<code>premain</code>相同，带<code>Instrumentation</code>签名的方法优先</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">agentmain</span><span class="params">(String args, Instrumentation inst)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">agentmain</span><span class="params">(String args)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>定义一个<code>MANIFEST.MF</code>文件，与静态<code>Agent</code>不同的是，此时必须包含Agent-Class选项</p></li><li><p>同样将包含<code>agentmain</code>的类与<code>MANIFEST.MF</code>配置文件打包成一个 jar 包</p></li><li><p>和<code>premain</code>模式不同，不再通过添加启动参数的方式来连接<code>agent</code>和主程序了，而使用<code>attach</code>方式来挂载。<code>attach</code>方式使用了<code>com.sun.tools.attach</code>包下的<code>VirtualMachine</code>工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取所有VM实例</span></span><br><span class="line">List&lt;VirtualMachineDescriptor&gt; list = VirtualMachine.list();</span><br><span class="line"><span class="comment">// attach对应VM</span></span><br><span class="line">VirtualMachine attach = VirtualMachine.attach(descriptor);</span><br><span class="line"><span class="comment">// 加载目标Agent</span></span><br><span class="line">attach.loadAgent(<span class="string">&quot;Java-Agent路径&quot;</span>);</span><br></pre></td></tr></table></figure></li></ol><h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><p>最常用<code>Instrumentation</code>的<code>addTransformer</code>方法对类加载做拦截，对输入的类的字节码进行修改、增强。依赖字节码修改，字节码修改技术主要有 Javassist、ASM，Javassist使用更简单，这里使用Javassist来进行字节码修改，引入相关maven包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javassist<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javassist<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.12.1.GA<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>Javassist</code> 使用可以参考下面文档：</p><p><a href="https://www.cnblogs.com/chiangchou/p/javassist.html">基于 Javassist 和 Javaagent 实现动态切面</a></p><p><a href="https://github.com/jboss-javassist/javassist/wiki">Javassist API</a></p><h2 id="实现极简的watch命令"><a href="#实现极简的watch命令" class="headerlink" title="实现极简的watch命令"></a>实现极简的watch命令</h2><blockquote><p>模拟Arthas的watch命令，来统计方法执行耗时</p></blockquote><h3 id="开发Agent"><a href="#开发Agent" class="headerlink" title="开发Agent"></a>开发Agent</h3><p><a href="https://github.com/ShadowTwj/sandbox/tree/master/agent/src/main/java/cn/tianwenjie/watch">https://github.com/ShadowTwj/sandbox/tree/master/agent/src/main/java/cn/tianwenjie/watch</a></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ol><li>Agent入口方法，包括<code>premain</code>和<code>agentmain</code>两个方法，后面会分别测试两个场景</li></ol><img src="/images/image-20221010202535725.png" alt="image-20221010202535725" style="zoom: 33%;" /><ol start="2"><li><p>实现类转换器，来对指定类和方法增强</p><img src="/images/image-20221010202839064.png" alt="image-20221010202839064" style="zoom:33%;" /></li></ol><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><p>配置<code>MANIFEST.MF</code>文件，指定<code>Premain-Class</code>和<code>Agent-Class</code>等属性，将配置文件与代码一同打包生成jar包</p><p>也可以使用maven的<code>maven-assembly-plugin</code>插件，来进行打包，参数可直接配置在pom文件中，打包的时候就会自动将配置信息生成 <code>MANIFEST.MF</code> 配置文件打进包里</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-assembly-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">archive</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">addClasspath</span>&gt;</span>true<span class="tag">&lt;/<span class="name">addClasspath</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">manifestEntries</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Built-By</span>&gt;</span>neo<span class="tag">&lt;/<span class="name">Built-By</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Premain-Class</span>&gt;</span>cn.tianwenjie.watch.WatchDemo<span class="tag">&lt;/<span class="name">Premain-Class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Agent-Class</span>&gt;</span>cn.tianwenjie.watch.WatchDemo<span class="tag">&lt;/<span class="name">Agent-Class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Main-Class</span>&gt;</span>cn.tianwenjie.watch.WatchDemo<span class="tag">&lt;/<span class="name">Main-Class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Can-Redefine-Classes</span>&gt;</span>true<span class="tag">&lt;/<span class="name">Can-Redefine-Classes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Can-Retransform-Classes</span>&gt;</span>true<span class="tag">&lt;/<span class="name">Can-Retransform-Classes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Can-Set-Native-Method-Prefix</span>&gt;</span>true<span class="tag">&lt;/<span class="name">Can-Set-Native-Method-Prefix</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">manifestEntries</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">descriptorRef</span>&gt;</span>jar-with-dependencies<span class="tag">&lt;/<span class="name">descriptorRef</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><blockquote><p>分别测试Agent的两种方式</p></blockquote><p><a href="https://github.com/ShadowTwj/sandbox/tree/master/agent-run/src/main/java/cn/tianwenjie/watch">https://github.com/ShadowTwj/sandbox/tree/master/agent-run/src/main/java/cn/tianwenjie/watch</a></p><h4 id="静态Agent测试"><a href="#静态Agent测试" class="headerlink" title="静态Agent测试"></a>静态Agent测试</h4><ul><li>打印控制台输入，统计打印方法耗时</li></ul><img src="/images/image-20221011110030840.png" alt="image-20221011110030840" style="zoom: 33%;" /><ul><li>添加<code>VM options</code>，指定<code>Agent</code> Jar包路径</li></ul><img src="/images/image-20221011110416104.png" alt="image-20221011110416104" style="zoom:33%;" /><ul><li><p>执行<code>main</code>方法，观察<code>print</code>方法耗时</p><img src="/images/image-20221011110730915.png" alt="image-20221011110730915" style="zoom:33%;" /></li></ul><h4 id="动态Agent测试"><a href="#动态Agent测试" class="headerlink" title="动态Agent测试"></a>动态Agent测试</h4><ul><li><p>测试方法如上，打印控制台输入，统计打印方法耗时</p></li><li><p>不需要添加<code>VM options</code>，直接执行<code>main</code>方法，观察未挂载<code>Agent</code>前控制台只打印了输入参数，没有打印方法耗时，该方法不要结束，等待下面<code>Attach</code></p><img src="/images/image-20221011111320354.png" alt="image-20221011111320354" style="zoom:33%;" /></li><li><p><code>Attach</code> VM，挂载<code>Agent</code> Jar包</p><img src="/images/image-20221011111737935.png" alt="image-20221011111737935" style="zoom:33%;" /></li><li><p><code>Attach</code>成功后，再执行测试类，观察到方法增强成功，打印控制台输入的同时打印方法耗时</p><img src="/images/image-20221011112040162.png" alt="image-20221011112040162" style="zoom:33%;" /></li></ul><h2 id="模拟热加载"><a href="#模拟热加载" class="headerlink" title="模拟热加载"></a>模拟热加载</h2><blockquote><p>模拟热加载，重新加载修改的类</p><p>与watch命令最大的区别是没有使用字节码修改技术，而是自定义编译器，将新的代码编译为字节码</p></blockquote><h3 id="开发Agent-1"><a href="#开发Agent-1" class="headerlink" title="开发Agent"></a>开发Agent</h3><p><a href="https://github.com/ShadowTwj/sandbox/tree/master/agent/src/main/java/cn/tianwenjie/hotdeploy">https://github.com/ShadowTwj/sandbox/tree/master/agent/src/main/java/cn/tianwenjie/hotdeploy</a></p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><ol><li><p>Agent入口方法，静态Agent对热加载无用，这里只实现动态Agent的<code>agentmain</code>方法</p><p>使用<code>retransform</code>和<code>redefineClasses</code>方法效果一样，这里使用<code>redefineClasses</code>方法，不在实现类转换器</p><img src="/images/image-20221112180722715.png" alt="image-20221112180722715" style="zoom:50%;" /></li><li><p>自定义编译器，因为热加载改动代码大多都不可预测，使用字节码修改技术并不方便，这里自定义编译器，来编译成字节码</p><p>具体代码：</p><p><a href="https://github.com/ShadowTwj/sandbox/blob/master/agent/src/main/java/cn/tianwenjie/hotdeploy/common/DynamicCompiler.java">https://github.com/ShadowTwj/sandbox/blob/master/agent/src/main/java/cn/tianwenjie/hotdeploy/common/DynamicCompiler.java</a></p></li></ol><h4 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h4><p>修改<code>maven-assembly-plugin</code>插件配置，打包生成配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-assembly-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">archive</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">addClasspath</span>&gt;</span>true<span class="tag">&lt;/<span class="name">addClasspath</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">manifestEntries</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Built-By</span>&gt;</span>neo<span class="tag">&lt;/<span class="name">Built-By</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Premain-Class</span>&gt;</span>cn.tianwenjie.hotdeploy.HotLoadingDemo<span class="tag">&lt;/<span class="name">Premain-Class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Agent-Class</span>&gt;</span>cn.tianwenjie.hotdeploy.HotLoadingDemo<span class="tag">&lt;/<span class="name">Agent-Class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Main-Class</span>&gt;</span>cn.tianwenjie.hotdeploy.HotLoadingDemo<span class="tag">&lt;/<span class="name">Main-Class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Can-Redefine-Classes</span>&gt;</span>true<span class="tag">&lt;/<span class="name">Can-Redefine-Classes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Can-Retransform-Classes</span>&gt;</span>true<span class="tag">&lt;/<span class="name">Can-Retransform-Classes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Can-Set-Native-Method-Prefix</span>&gt;</span>true<span class="tag">&lt;/<span class="name">Can-Set-Native-Method-Prefix</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">manifestEntries</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">descriptorRef</span>&gt;</span>jar-with-dependencies<span class="tag">&lt;/<span class="name">descriptorRef</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><p><a href="https://github.com/ShadowTwj/sandbox/tree/master/agent-run/src/main/java/cn/tianwenjie/hotdeploy">https://github.com/ShadowTwj/sandbox/tree/master/agent-run/src/main/java/cn/tianwenjie/hotdeploy</a></p><ul><li><p>测试方法同上watch命令，打印控制台输入</p><img src="/images/image-20221112182332843.png" alt="image-20221112182332843" style="zoom:50%;" /></li><li><p><code>Attach</code> VM，挂载<code>Agent</code> Jar包，热加载新类。如下图，继续打印控制台输入，可以看到热加载成功</p><img src="/images/image-20221112182533197.png" alt="image-20221112182533197" style="zoom:50%;" /></li></ul><h1 id="Java-Agent原理"><a href="#Java-Agent原理" class="headerlink" title="Java-Agent原理"></a>Java-Agent原理</h1><h2 id="静态Agent-1"><a href="#静态Agent-1" class="headerlink" title="静态Agent"></a>静态Agent</h2><h3 id="启动时加载过程"><a href="#启动时加载过程" class="headerlink" title="启动时加载过程"></a>启动时加载过程</h3><blockquote><p>JPLISAgent：作用是初始化所有通过Java Instrumentation API编写的Agent，并且也承担着通过JVMTI实现Java Instrumentation中暴露API的责任</p></blockquote><ol><li>创建并初始化 JPLISAgent；</li><li>监听 VMInit 事件，在 JVM 初始化完成之后做下面的事情：<ol><li>创建 InstrumentationImpl 对象 ；</li><li>监听 ClassFileLoadHook 事件 ；</li><li>调用 InstrumentationImpl 的loadClassAndCallPremain方法，在这个方法里会去调用 javaagent 中 MANIFEST.MF 里指定的Premain-Class 类的 premain 方法 ；</li></ol></li><li>解析 javaagent 中 MANIFEST.MF 文件的参数，并根据这些参数来设置 JPLISAgent 里的一些内容。</li></ol><img src="/images/1071038-20210112143707325-1984756789.png" /><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><ol><li><p>参数解析</p><p>JVM启动时解析对应参数，观察<code>hotspot/src/share/vm/runtime/arguments.cpp</code>中的<code>Arguments::parse_each_vm_init_arg</code>函数片段</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -agentlib and -agentpath</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">match_option</span>(option, <span class="string">&quot;-agentlib:&quot;</span>, &amp;tail) ||</span><br><span class="line">          (is_absolute_path = <span class="built_in">match_option</span>(option, <span class="string">&quot;-agentpath:&quot;</span>, &amp;tail))) &#123;</span><br><span class="line">      <span class="keyword">if</span>(tail != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* pos = <span class="built_in">strchr</span>(tail, <span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">        <span class="keyword">char</span>* name;</span><br><span class="line">        <span class="keyword">if</span> (pos == <span class="literal">NULL</span>) &#123;</span><br><span class="line">          name = os::<span class="built_in">strdup_check_oom</span>(tail, mtArguments);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">size_t</span> len = pos - tail;</span><br><span class="line">          name = <span class="built_in">NEW_C_HEAP_ARRAY</span>(<span class="keyword">char</span>, len + <span class="number">1</span>, mtArguments);</span><br><span class="line">          <span class="built_in">memcpy</span>(name, tail, len);</span><br><span class="line">          name[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> *options = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(pos != <span class="literal">NULL</span>) &#123;</span><br><span class="line">          options = os::<span class="built_in">strdup_check_oom</span>(pos + <span class="number">1</span>, mtArguments);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !INCLUDE_JVMTI</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">valid_jdwp_agent</span>(name, is_absolute_path)) &#123;</span><br><span class="line">          <span class="built_in">jio_fprintf</span>(defaultStream::<span class="built_in">error_stream</span>(),</span><br><span class="line">            <span class="string">&quot;Debugging agents are not supported in this VM\n&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span> JNI_ERR;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// !INCLUDE_JVMTI</span></span></span><br><span class="line">        <span class="comment">// 存储Agent解析结果</span></span><br><span class="line">        <span class="comment">// name:&quot;instrument&quot;，动态链接库</span></span><br><span class="line">        <span class="built_in">add_init_agent</span>(name, options, is_absolute_path);</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">// -javaagent</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">match_option</span>(option, <span class="string">&quot;-javaagent:&quot;</span>, &amp;tail)) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !INCLUDE_JVMTI</span></span><br><span class="line">      <span class="built_in">jio_fprintf</span>(defaultStream::<span class="built_in">error_stream</span>(),</span><br><span class="line">        <span class="string">&quot;Instrumentation agents are not supported in this VM\n&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> JNI_ERR;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">      <span class="keyword">if</span> (tail != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">size_t</span> length = <span class="built_in">strlen</span>(tail) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> *options = <span class="built_in">NEW_C_HEAP_ARRAY</span>(<span class="keyword">char</span>, length, mtArguments);</span><br><span class="line">        <span class="built_in">jio_snprintf</span>(options, length, <span class="string">&quot;%s&quot;</span>, tail);</span><br><span class="line">        <span class="built_in">add_instrument_agent</span>(<span class="string">&quot;instrument&quot;</span>, options, <span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// java agents need module java.instrument</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">create_numbered_module_property</span>(<span class="string">&quot;jdk.module.addmods&quot;</span>, <span class="string">&quot;java.instrument&quot;</span>, addmods_count++)) &#123;</span><br><span class="line">          <span class="keyword">return</span> JNI_ENOMEM;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// !INCLUDE_JVMTI</span></span></span><br></pre></td></tr></table></figure><p>这段逻辑用来解析需要加载的Agent路径，然后调用<code>add_init_agent</code>存储解析结果到<code>_agentList</code>中，<code>AgentLibraryList</code>是一个链表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -agentlib and -agentpath arguments</span></span><br><span class="line"><span class="keyword">static</span> AgentLibraryList _agentList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Arguments::add_init_agent</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">char</span>* options, <span class="keyword">bool</span> absolute_path)</span> </span>&#123;</span><br><span class="line">  _agentList.<span class="built_in">add</span>(<span class="keyword">new</span> <span class="built_in">AgentLibrary</span>(name, options, absolute_path, <span class="literal">NULL</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>加载Agent</p><p>观察<code>hotspot/src/share/vm/runtime/threads.cpp</code>中的<code>Threads::create_vm</code>函数，JVM在解析完参数后，判断<code>_agentList</code>是否为空，不为空加载<code>Agent</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Launch -agentlib/-agentpath and converted -Xrun agents</span></span><br><span class="line"><span class="comment">// 判断agent链表是否为空，不为空加载Agent</span></span><br><span class="line"><span class="keyword">if</span> (Arguments::<span class="built_in">init_agents_at_startup</span>()) &#123;</span><br><span class="line">  <span class="built_in">create_vm_init_agents</span>();</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">init_agents_at_startup</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> !_agentList.<span class="built_in">is_empty</span>(); &#125;</span><br></pre></td></tr></table></figure><p>分析<code>create_vm_init_agents</code>函数，遍历<code>Agent</code>逐个加载，解析对应的<code>Agent_Onload</code>函数，最终调用<code>premain</code>方法，执行<code>Agent_Onload</code>函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (agent = Arguments::<span class="built_in">agents</span>(); agent != <span class="literal">NULL</span>; agent = agent-&gt;<span class="built_in">next</span>()) &#123;</span><br><span class="line">  <span class="comment">// CDS dumping does not support native JVMTI agent.</span></span><br><span class="line">  <span class="comment">// CDS dumping supports Java agent if the AllowArchivingWithJavaAgent diagnostic option is specified.</span></span><br><span class="line">  <span class="keyword">if</span> (Arguments::<span class="built_in">is_dumping_archive</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!agent-&gt;<span class="built_in">is_instrument_lib</span>()) &#123;</span><br><span class="line">      <span class="built_in">vm_exit_during_cds_dumping</span>(<span class="string">&quot;CDS dumping does not support native JVMTI agent, name&quot;</span>, agent-&gt;<span class="built_in">name</span>());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!AllowArchivingWithJavaAgent) &#123;</span><br><span class="line">      <span class="built_in">vm_exit_during_cds_dumping</span>(</span><br><span class="line">        <span class="string">&quot;Must enable AllowArchivingWithJavaAgent in order to run Java agent during CDS dumping&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解析Agent_OnLoad函数，最终调用premain方法</span></span><br><span class="line">  OnLoadEntry_t  on_load_entry = <span class="built_in">lookup_agent_on_load</span>(agent);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (on_load_entry != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">// Invoke the Agent_OnLoad function</span></span><br><span class="line">    <span class="comment">// 执行Agent_OnLoad函数</span></span><br><span class="line">    jint err = (*on_load_entry)(&amp;main_vm, agent-&gt;<span class="built_in">options</span>(), <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (err != JNI_OK) &#123;</span><br><span class="line">      <span class="built_in">vm_exit_during_initialization</span>(<span class="string">&quot;agent library failed to init&quot;</span>, agent-&gt;<span class="built_in">name</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">vm_exit_during_initialization</span>(<span class="string">&quot;Could not find Agent_OnLoad function in the agent library&quot;</span>, agent-&gt;<span class="built_in">name</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Agent_OnLoad函数</p><blockquote><p>动态链接库<code>libinstrument</code>，用来支持使用Java Instrumentation API来编写Agent，在libinstrument中有一个非常重要的类称为：JPLISAgent（Java Programming Language Instrumentation Services Agent），它的作用是初始化所有通过Java Instrumentation API编写的Agent，并且也承担着通过JVMTI实现Java Instrumentation中暴露API的责任</p></blockquote><p>在动态链接库<code>libinstrument</code>中找到<code>Agent_OnLoad</code>函数，在<code>java.instrument/share/native/libinstrument/InvocationAdapter.c</code>中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">JNIEXPORT jint JNICALL</span><br><span class="line">DEF_Agent_OnLoad(JavaVM *vm, <span class="keyword">char</span> *tail, <span class="keyword">void</span> * reserved) &#123;</span><br><span class="line">    JPLISInitializationError initerror  = JPLIS_INIT_ERROR_NONE;</span><br><span class="line">    jint                     result     = JNI_OK;</span><br><span class="line">    JPLISAgent *             agent      = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 创建并初始化JPLISAgent</span></span><br><span class="line">    initerror = createNewJPLISAgent(vm, &amp;agent);</span><br><span class="line">   <span class="keyword">if</span> ( initerror == JPLIS_INIT_ERROR_NONE ) &#123;</span><br><span class="line">        <span class="keyword">int</span>             oldLen, newLen;</span><br><span class="line">        <span class="keyword">char</span> *          jarfile;</span><br><span class="line">        <span class="keyword">char</span> *          options;</span><br><span class="line">        jarAttribute*   attributes;</span><br><span class="line">        <span class="keyword">char</span> *          premainClass;</span><br><span class="line">        <span class="keyword">char</span> *          bootClassPath;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Parse &lt;jarfile&gt;[=options] into jarfile and options</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (parseArgumentTail(tail, &amp;jarfile, &amp;options) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;-javaagent: memory allocation failure.\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> JNI_ERR;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        attributes = readAttributes(jarfile);</span><br><span class="line">        </span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">        premainClass = getAttribute(attributes, <span class="string">&quot;Premain-Class&quot;</span>);</span><br><span class="line">        </span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Save the jarfile name */</span></span><br><span class="line">        agent-&gt;mJarfile = jarfile;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">      </span><br><span class="line">        bootClassPath = getAttribute(attributes, <span class="string">&quot;Boot-Class-Path&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Convert JAR attributes into agent capabilities</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        convertCapabilityAttributes(attributes, agent);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Track (record) the agent class name and options data</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        initerror = recordCommandLineData(agent, premainClass, options);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Clean-up</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (options != <span class="literal">NULL</span>) <span class="built_in">free</span>(options);</span><br><span class="line">        freeAttributes(attributes);</span><br><span class="line">        <span class="built_in">free</span>(premainClass);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到函数中调用<code>createNewJPLISAgent</code>方法，创建JPLISAgent，在<code>createNewJPLISAgent</code>函数中又调用<code>initializeJPLISAgent</code>函数进行初始化，<code>initializeJPLISAgent</code>函数中有设置VMInit时间回调函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.触发VMInit事件回调</span></span><br><span class="line">callbacks.VMInit = &amp;eventHandlerVMInit;</span><br></pre></td></tr></table></figure><p>看下<code>eventHandlerVMInit</code>函数实现，<code>eventHandlerVMInit</code> -&gt; <code>processJavaStart</code> -&gt; <code>startJavaAgent</code> -&gt; <code>invokeJavaAgentMainMethod</code>，最终<code>invokeJavaAgentMainMethod</code>函数则是调用<code>premain</code>方法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> JNICALL</span><br><span class="line">eventHandlerVMInit( jvmtiEnv *      jvmtienv,</span><br><span class="line">                    JNIEnv *        jnienv,</span><br><span class="line">                    jthread         thread) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  success = processJavaStart( environment-&gt;mAgent, jnienv);</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jboolean</span><br><span class="line">processJavaStart(   JPLISAgent *    agent,</span><br><span class="line">                    JNIEnv *        jnienv) &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *  Now make the InstrumentationImpl instance.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ( result ) &#123;</span><br><span class="line">        result = createInstrumentationImpl(jnienv, agent);</span><br><span class="line">        jplis_assert_msg(result, <span class="string">&quot;instrumentation instance creation failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *  Load the Java agent, and call the premain.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ( result ) &#123;</span><br><span class="line">        result = startJavaAgent(agent, jnienv,</span><br><span class="line">                                agent-&gt;mAgentClassName, agent-&gt;mOptionsString,</span><br><span class="line">                                agent-&gt;mPremainCaller);</span><br><span class="line">        jplis_assert_msg(result, <span class="string">&quot;agent load/premain call failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jboolean</span><br><span class="line">startJavaAgent( JPLISAgent *    agent,</span><br><span class="line">                JNIEnv *        jnienv,</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">char</span> *    classname,</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">char</span> *    optionsString,</span><br><span class="line">                jmethodID       agentMainMethod) &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 3.执行premain方法</span></span><br><span class="line">  success = invokeJavaAgentMainMethod(   jnienv,</span><br><span class="line">                                      agent-&gt;mInstrumentationImpl,</span><br><span class="line">                                      agentMainMethod,</span><br><span class="line">                                      classNameObject,</span><br><span class="line">                                      optionsStringObject);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="动态Agent-1"><a href="#动态Agent-1" class="headerlink" title="动态Agent"></a>动态Agent</h2><h3 id="运行时加载过程"><a href="#运行时加载过程" class="headerlink" title="运行时加载过程"></a>运行时加载过程</h3><p>通过 JVM 的attach机制来请求目标 JVM 加载对应的agent，过程大致如下：</p><ol><li>创建并初始化JPLISAgent；</li><li>解析 javaagent 里 MANIFEST.MF 里的参数；</li><li>创建 InstrumentationImpl 对象；</li><li>监听 ClassFileLoadHook 事件；</li><li>调用 InstrumentationImpl 的loadClassAndCallAgentmain方法，在这个方法里会去调用javaagent里 MANIFEST.MF 里指定的Agent-Class类的agentmain方法。</li></ol><img src="/images/1071038-20210112143615738-1489695442.png"/><h3 id="Attach-1"><a href="#Attach-1" class="headerlink" title="Attach"></a>Attach</h3><blockquote><p>动态Agent是通过Attach机制来加载，下面分析下Attach原理</p></blockquote><ol><li><p>AttachListener</p><p><code>Attach</code>机制通过<code>Attach Listener</code>线程来进行相关事务的处理，<code>AttachListener</code>初始化如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AttachListener::init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  EXCEPTION_MARK;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* name = <span class="string">&quot;Attach Listener&quot;</span>;</span><br><span class="line">  Handle thread_oop = JavaThread::<span class="built_in">create_system_thread_object</span>(name, <span class="literal">true</span> <span class="comment">/* visible */</span>, THREAD);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">has_init_error</span>(THREAD)) &#123;</span><br><span class="line">    <span class="built_in">set_state</span>(AL_NOT_INITIALIZED);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  JavaThread* thread = <span class="keyword">new</span> <span class="built_in">JavaThread</span>(&amp;attach_listener_thread_entry);</span><br><span class="line">  JavaThread::<span class="built_in">vm_exit_on_osthread_failure</span>(thread);</span><br><span class="line"></span><br><span class="line">  JavaThread::<span class="built_in">start_internal_daemon</span>(THREAD, thread, thread_oop, NoPriority);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>attach_listener_thread_entry</code>函数是线程入口，代码片段如下：</p><p>首先获取到<code>Attach</code>任务，然后查询匹配命令对应的函数，最后执行对应函数，funcs是命令对应的函数，其中”load”命令对应<code>load_agent</code>函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">attach_listener_thread_entry</span><span class="params">(JavaThread* thread, TRAPS)</span> </span>&#123;</span><br><span class="line">  AttachListener::<span class="built_in">set_initialized</span>();</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">// 1.获取Attach任务</span></span><br><span class="line">      AttachOperation* op = AttachListener::<span class="built_in">dequeue</span>();</span><br><span class="line">    </span><br><span class="line">      <span class="comment">// find the function to dispatch too</span></span><br><span class="line">    <span class="comment">// 2.查询匹配命令对应的函数，funcs是命令对应的函数，其中&quot;load&quot;命令对应load_agent函数</span></span><br><span class="line">      AttachOperationFunctionInfo* info = <span class="literal">NULL</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; funcs[i].name != <span class="literal">NULL</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* name = funcs[i].name;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(op-&gt;<span class="built_in">name</span>(), name) == <span class="number">0</span>) &#123;</span><br><span class="line">          info = &amp;(funcs[i]); <span class="keyword">break</span>;</span><br><span class="line">        &#125;&#125;</span><br><span class="line">    </span><br><span class="line">       <span class="comment">// dispatch to the function that implements this operation</span></span><br><span class="line">    <span class="comment">// 3.执行命令对应的函数</span></span><br><span class="line">        res = (info-&gt;func)(op, &amp;st);</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看<code>dequeue</code>函数，是如何获取任务的，<code>dequeue</code>函数不系统实现不同，windows系统是<code>Win32AttachListener::dequeue()</code>，Mac系统是<code>BsdAttachListener::dequeue()</code>，Linux系统是<code>LinuxAttachListener::dequeue()</code>。下面是Linux系统实现，等待客户端连接，通过<code>accept</code>来接收，然后将请求读出来，包装成<code>AttachOperation</code>对象，返回进行处理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinuxAttachOperation* <span class="title">LinuxAttachListener::dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">// wait for client to connect</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> <span class="title">addr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> len = <span class="built_in"><span class="keyword">sizeof</span></span>(addr);</span><br><span class="line">    <span class="comment">// 等待连接，通过accept来接收</span></span><br><span class="line">    <span class="built_in">RESTARTABLE</span>(::<span class="built_in">accept</span>(<span class="built_in">listener</span>(), &amp;addr, &amp;len), s);</span><br><span class="line">    <span class="comment">// get the credentials of the peer and check the effective uid/guid</span></span><br><span class="line">    <span class="comment">// - check with jeff on this.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ucred</span> <span class="title">cred_info</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> optlen = <span class="built_in"><span class="keyword">sizeof</span></span>(cred_info);</span><br><span class="line">    <span class="keyword">if</span> (::<span class="built_in">getsockopt</span>(s, SOL_SOCKET, SO_PEERCRED, (<span class="keyword">void</span>*)&amp;cred_info, &amp;optlen) == <span class="number">-1</span>) &#123;</span><br><span class="line">      ::<span class="built_in">close</span>(s);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// peer credential look okay so we read the request</span></span><br><span class="line">    <span class="comment">// 将请求读出来</span></span><br><span class="line">    LinuxAttachOperation* op = <span class="built_in">read_request</span>(s);</span><br><span class="line">    <span class="keyword">return</span> op;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>VirtualMachine.attach</code>方法</p><p>通过<code>com.sun.tools.attach.VirtualMachine#attach</code>方法来连接指定pid的JVM进程，查看源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> VirtualMachine <span class="title">attach</span><span class="params">(String var0)</span> <span class="keyword">throws</span> AttachNotSupportedException, IOException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (var0 == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;id cannot be null&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    List var1 = AttachProvider.providers();</span><br><span class="line">    <span class="keyword">if</span> (var1.size() == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> AttachNotSupportedException(<span class="string">&quot;no providers installed&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      AttachNotSupportedException var2 = <span class="keyword">null</span>;</span><br><span class="line">      Iterator var3 = var1.iterator();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span>(var3.hasNext()) &#123;</span><br><span class="line">        AttachProvider var4 = (AttachProvider)var3.next();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> var4.attachVirtualMachine(var0);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AttachNotSupportedException var6) &#123;</span><br><span class="line">          var2 = var6;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">throw</span> var2;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出最终调用<code>AttachProvider</code>的<code>attachVirtualMachine</code>方法，<code>AttachProvider</code>是抽象类，不同系统不同实现，在MacOS中实现类是<code>BsdAttachProvider</code>，其中<code>attachVirtualMachine</code>实现是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> VirtualMachine <span class="title">attachVirtualMachine</span><span class="params">(String var1)</span> <span class="keyword">throws</span> AttachNotSupportedException, IOException </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.checkAttachPermission();</span><br><span class="line">  <span class="keyword">this</span>.testAttachable(var1);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> BsdVirtualMachine(<span class="keyword">this</span>, var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看其构造方法，通过<code>findSocketFile</code>方法用来查询目标JVM上是否已经启动了<code>Attach Listener</code>，因为<code>Attach Listener</code>是懒加载，所以JVM启动也不一定加载。检查<code>/tmp/.java_pid&#123;pid&#125;</code>文件是否存在，如果存在，则说明目标JVM Attach机制已准备就绪，可以直接通过<code>connect</code>方法来连接到目标JVM，发送命令；如果不存在，则说明目标JVM的<code>Attach Listener</code>还没有初始化，这时通过<code>sendQuitTo</code>方法向目标JVM发送信号，让其初始化<code>Attach Listener</code>，并且循环等待<code>/tmp/.java_pid&#123;pid&#125;</code>文件的创建，之后再通过<code>connect</code>方法来连接到目标JVM，发送命令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">BsdVirtualMachine(AttachProvider var1, String var2) <span class="keyword">throws</span> AttachNotSupportedException, IOException &#123;</span><br><span class="line">  <span class="keyword">super</span>(var1, var2);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> var3;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    var3 = Integer.parseInt(var2);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (NumberFormatException var22) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> AttachNotSupportedException(<span class="string">&quot;Invalid process identifier&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// var3为pid，检查/tmp/.java_pid&#123;pid&#125;是否存在</span></span><br><span class="line">  <span class="keyword">this</span>.path = <span class="keyword">this</span>.findSocketFile(var3);</span><br><span class="line">  <span class="comment">// 如果存在，则说明目标JVM Attach机制已准备就绪，可以直接通过connect方法来连接到目标JVM，发送命令</span></span><br><span class="line">  <span class="comment">// 如果不存在，则说明目标JVM的Attach Listener还没有初始化</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.path == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 创建/tmp/.java_pid&#123;pid&#125;文件</span></span><br><span class="line">    File var4 = <span class="keyword">new</span> File(tmpdir, <span class="string">&quot;.attach_pid&quot;</span> + var3);</span><br><span class="line">    createAttachFile(var4.getPath());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 向目标JVM发送信号，让其初始化Attach Listener</span></span><br><span class="line">      sendQuitTo(var3);</span><br><span class="line">      <span class="keyword">int</span> var5 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">long</span> var6 = <span class="number">200L</span>;</span><br><span class="line">      <span class="keyword">int</span> var8 = (<span class="keyword">int</span>)(<span class="keyword">this</span>.attachTimeout() / var6);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 循环等待/tmp/.java_pid&#123;pid&#125;文件的创建，之后再通过connect方法来连接到目标JVM，发送命令</span></span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          Thread.sleep(var6);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException var21) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.path = <span class="keyword">this</span>.findSocketFile(var3);</span><br><span class="line">        ++var5;</span><br><span class="line">      &#125; <span class="keyword">while</span>(var5 &lt;= var8 &amp;&amp; <span class="keyword">this</span>.path == <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.path == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AttachNotSupportedException(<span class="string">&quot;Unable to open socket file: target process not responding or HotSpot VM not loaded&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      var4.delete();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  checkPermissions(<span class="keyword">this</span>.path);</span><br><span class="line">  <span class="keyword">int</span> var24 = socket();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    connect(var24, <span class="keyword">this</span>.path);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    close(var24);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>loadAgent方法</code></p><p>通过<code>attach</code>方法，连接上目标JVM后，通过<code>loadAgent</code>方法来加载<code>Agent</code>，其本质是向目标JVM发送<code>load</code>命令，这里不再展开</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadAgentLibrary</span><span class="params">(String var1, <span class="keyword">boolean</span> var2, String var3)</span> <span class="keyword">throws</span> AgentLoadException, AgentInitializationException, IOException </span>&#123;</span><br><span class="line">  InputStream var4 = <span class="keyword">this</span>.execute(<span class="string">&quot;load&quot;</span>, var1, var2 ? <span class="string">&quot;true&quot;</span> : <span class="string">&quot;false&quot;</span>, var3);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> var5 = <span class="keyword">this</span>.readInt(var4);</span><br><span class="line">    <span class="keyword">if</span> (var5 != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> AgentInitializationException(<span class="string">&quot;Agent_OnAttach failed&quot;</span>, var5);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    var4.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看下JVM中<code>load</code>命令的实现，上面<code>Agtach Listener</code>的<code>attach_listener_thread_entry</code>函数中，会查询匹配命令对应的函数，然后执行对应的函数，<code>funcs</code>则是一个命令函数表，查看<code>load</code>命令对应的函数，发现是<code>load_agent</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// names must be of length &lt;= AttachOperation::name_length_max</span></span><br><span class="line"><span class="keyword">static</span> AttachOperationFunctionInfo funcs[] = &#123;</span><br><span class="line">  &#123; <span class="string">&quot;agentProperties&quot;</span>,  get_agent_properties &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;datadump&quot;</span>,         data_dump &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;dumpheap&quot;</span>,         dump_heap &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;load&quot;</span>,             load_agent &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;properties&quot;</span>,       get_system_properties &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;threaddump&quot;</span>,       thread_dump &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;inspectheap&quot;</span>,      heap_inspection &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;setflag&quot;</span>,          set_flag &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;printflag&quot;</span>,        print_flag &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;jcmd&quot;</span>,             jcmd &#125;,</span><br><span class="line">  &#123; <span class="literal">NULL</span>,               <span class="literal">NULL</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再查看<code>load_agent</code>函数实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Implementation of &quot;load&quot; command.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> jint <span class="title">load_agent</span><span class="params">(AttachOperation* op, outputStream* out)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// get agent name and options</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* agent = op-&gt;<span class="built_in">arg</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* absParam = op-&gt;<span class="built_in">arg</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* options = op-&gt;<span class="built_in">arg</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If loading a java agent then need to ensure that the java.instrument module is loaded</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strcmp</span>(agent, <span class="string">&quot;instrument&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">    JavaThread* THREAD = JavaThread::<span class="built_in">current</span>(); <span class="comment">// For exception macros.</span></span><br><span class="line">    <span class="function">ResourceMark <span class="title">rm</span><span class="params">(THREAD)</span></span>;</span><br><span class="line">    <span class="function">HandleMark <span class="title">hm</span><span class="params">(THREAD)</span></span>;</span><br><span class="line">    <span class="function">JavaValue <span class="title">result</span><span class="params">(T_OBJECT)</span></span>;</span><br><span class="line">    Handle h_module_name = java_lang_String::<span class="built_in">create_from_str</span>(<span class="string">&quot;java.instrument&quot;</span>, THREAD);</span><br><span class="line">    JavaCalls::<span class="built_in">call_static</span>(&amp;result,</span><br><span class="line">                           vmClasses::<span class="built_in">module_Modules_klass</span>(),</span><br><span class="line">                           vmSymbols::<span class="built_in">loadModule_name</span>(),</span><br><span class="line">                           vmSymbols::<span class="built_in">loadModule_signature</span>(),</span><br><span class="line">                           h_module_name,</span><br><span class="line">                           THREAD);</span><br><span class="line">    <span class="keyword">if</span> (HAS_PENDING_EXCEPTION) &#123;</span><br><span class="line">      java_lang_Throwable::<span class="built_in">print</span>(PENDING_EXCEPTION, out);</span><br><span class="line">      CLEAR_PENDING_EXCEPTION;</span><br><span class="line">      <span class="keyword">return</span> JNI_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> JvmtiExport::<span class="built_in">load_agent_library</span>(agent, absParam, options, out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要作用是加载<code>Agent</code>动态链接库，如果是通过<code>Java instrument API</code>实现的Agent，则加载的是<code>libinstrument</code>动态链接库。然后通过动态链接库中的<code>Agent_OnAttach</code>函数来创建<code>JPLISAgent</code>，从而调用<code>agentmain</code>方法。这一部分内容和<code>libinstrument</code>中的<code>Agent_OnLoad</code>函数来创建<code>JPLISAgent</code>，调用<code>premain</code>方法的逻辑相似</p></li></ol><h1 id="相关开源项目"><a href="#相关开源项目" class="headerlink" title="相关开源项目"></a>相关开源项目</h1><p>很多开源项目都用到了<code>Java-Agent</code>，下面列举两个项目，有兴趣可以阅读一下</p><h2 id="Arthas"><a href="#Arthas" class="headerlink" title="Arthas"></a>Arthas</h2><p>Arthas用到非常重要的技术就是Java-Agent，以及相关的字节码增强等技术，从启动方式就能看出来使用的是动态Agent的方式</p><p>代码地址：<a href="https://github.com/alibaba/arthas">https://github.com/alibaba/arthas</a></p><h2 id="ja-netfilter"><a href="#ja-netfilter" class="headerlink" title="ja-netfilter"></a>ja-netfilter</h2><p>一个Java Instrumentation框架，也是通过Java-Agent实现的，支持插件化。使用的是静态Agent方式</p><p>相关文章：<a href="https://zhile.io/2021/11/29/ja-netfilter-javaagent-lib.html">https://zhile.io/2021/11/29/ja-netfilter-javaagent-lib.html</a></p><p>代码地址：<a href="https://gitee.com/ja-netfilter/ja-netfilter">https://gitee.com/ja-netfilter/ja-netfilter</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.51cto.com/alex4dream/3247542">https://blog.51cto.com/alex4dream/3247542</a></p><p><a href="https://tech.meituan.com/2019/11/07/java-dynamic-debugging-technology.html">https://tech.meituan.com/2019/11/07/java-dynamic-debugging-technology.html</a></p><p><a href="https://tech.meituan.com/2022/03/17/java-hotswap-sonic.html">https://tech.meituan.com/2022/03/17/java-hotswap-sonic.html</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzkyMjIzOTQ3NA==&amp;mid=2247484609&amp;idx=1&amp;sn=8bd852871d656f5a5dcb216f810a273f&amp;source=41#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MzkyMjIzOTQ3NA==&amp;mid=2247484609&amp;idx=1&amp;sn=8bd852871d656f5a5dcb216f810a273f&amp;source=41#wechat_redirect</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Java Agent 直译过来叫做 Java 代理，但更多称叫做 Java 探针&lt;/p&gt;
&lt;/blockquote</summary>
      
    
    
    
    <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
    <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>PostgreSQL介绍</title>
    <link href="http://yoursite.com/2021/11/26/PostgreSQL%E4%BB%8B%E7%BB%8D/"/>
    <id>http://yoursite.com/2021/11/26/PostgreSQL%E4%BB%8B%E7%BB%8D/</id>
    <published>2021-11-26T05:59:37.000Z</published>
    <updated>2022-03-13T06:11:47.742Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/postgresql0.png"></p><h1 id="关于PostgreSQL"><a href="#关于PostgreSQL" class="headerlink" title="关于PostgreSQL"></a>关于PostgreSQL</h1><p><code>PostgreSQL</code> 是一个强大的开源对象关系数据库系统，它使用并扩展了 SQL 语言，并结合了许多安全存储和扩展最复杂数据工作负载的功能。</p><p><code>PostgreSQL</code> 是以加州大学伯克利分校计算机系开发的<a href="https://dsf.berkeley.edu/postgres.html">POSTGRES， 版本 4.2</a>为基础的对象关系型数据库系统</p><p><code>PostgreSQL</code>，也称为 <code>Postgres</code>，简称<strong>PG</strong>(以下都简称PG)</p><p>PG 号称是“世界上最先进的开源关系型数据库”，和“世界上最好的语言”不同，PG的自吹自擂并没有受到大家的调侃</p><p>PG 不属于任何一家公司，它背后的控制机构是——<strong>PostgreSQL全球开发小组</strong>，是一个松散的组织</p><p>其核心成员来自全球各地的不同公司，如果感兴趣，可以在PG<a href="https://www.postgresql.org/community/contributors/">官网</a>查询到这个组织的成员列表</p><p>可以这么说，没有任何一个公司享有对 PG 的绝对控制权，PG永远是属于社区</p><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><blockquote><p>开源大家都不陌生，但是开源并不等于免费，下面是几种协议的区别</p></blockquote><p><img src="/images/postgresql1.png"></p><ul><li><p>GPL 协议：</p><p>GPL 是一种传染协议，如果修改了源码，也必须使用 GPL 协议</p><p>GPL 是一种“非商业”友好协议，如果是商业项目，那一定要注意 GPL 的可能带来的问题</p><p>Linux 内核 使用的就是 GPL 协议，免费的 MySQL 社区版使用的也是 GPL 协议</p></li><li><p>BSD 协议：</p><p>BSD 是一个给予使用者很大自由的协议</p><p>基本上使用者可以“为所欲为”可以自由的使用,修改源代码,也可以将修改后的代码作为开源或者专有软件再发布</p></li></ul><p>PG 早期使用的就是 BSD 协议，后面换成了自有协议——<strong>PostgreSQL License</strong>，虽然换了自由协议，但并没有多少改变，依然属于最为友好的协议类型</p><p>不论是自用还是商用，都是完全没有问题，修改代码并且用来盈利也是毫无商业风险的</p><h2 id="PG影响力"><a href="#PG影响力" class="headerlink" title="PG影响力"></a>PG影响力</h2><ul><li><p>在行业中的应用(几年前的图)</p><p><img src="/images/postgresql2.png"></p></li><li><p><a href="https://db-engines.com/en/ranking_trend">DB-Engines 排名</a></p><p><img src="/images/postgresql3.png"></p></li><li><p>Stack Overflow 问卷调查</p><p><a href="https://insights.stackoverflow.com/survey/2021#section-most-loved-dreaded-and-wanted-databases">2021最受欢迎数据库排名</a></p><p><img src="/images/postgresql4.png"></p><p><a href="https://insights.stackoverflow.com/survey/2021#section-most-loved-dreaded-and-wanted-databases">2021使用数据库排名</a></p><p><img src="/images/postgresql5.png"></p></li></ul><h1 id="PG功能"><a href="#PG功能" class="headerlink" title="PG功能"></a>PG功能</h1><h2 id="SQL标准"><a href="#SQL标准" class="headerlink" title="SQL标准"></a>SQL标准</h2><p>最新的 SQL 标准是 SQL:2016</p><p>SQL:2016 标准中的核心标准中的<strong>179</strong>项特性，而 PG 至少实现了<strong>170</strong>项，在数据库中也算名列前茅的</p><h2 id="Schema"><a href="#Schema" class="headerlink" title="Schema"></a>Schema</h2><h3 id="Schema定义"><a href="#Schema定义" class="headerlink" title="Schema定义"></a>Schema定义</h3><p>一个 PG 集群可以包含多个数据库，一个数据库包含一个或多个命名<em>模式</em>，模式中包含着表</p><p><code>schema</code> 还包含其他类型的命名对象，包括数据类型、函数和操作符。相同的对象名称可以被用于不同的模式中而不会出现冲突，例如 schema1 和 myschema 都可以包含名为 mytable 的表</p><p>下面是一些使用 <code>schema</code> 的原因：</p><ul><li>允许多个用户使用一个数据库并且不会互相干扰</li><li>将数据库对象组织成逻辑组以便更容易管理</li><li>第三方应用的对象可以放在独立的模式中，这样它们就不会与其他对象的名称发生冲突</li></ul><p><code>schema</code> 类似于操作系统层的目录，但是 <code>schema</code> 不能嵌套</p><img src="/images/postgresql6.png" style="zoom:50%;" /><p>默认情况下，新创建的数据库有一个 <code>public</code> 的模式，但可以添加任何其他模式，并且 <code>public</code> 模式不是必需的</p><h3 id="Schema使用"><a href="#Schema使用" class="headerlink" title="Schema使用"></a>Schema使用</h3><p>在 SQL 中需要在表名前添加 <code>schema</code> 前缀，如不添加则默认是 <code>public</code> 模式，或使用 <code>search_path</code> 指定 <code>schema</code></p><img src="/images/postgresql7.png" style="zoom: 50%;" /><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>PG 支持非常丰富的数据类型，下面是普通数据类型，同时下面所有普通数据类型都支持数组类型</p><table><thead><tr><th align="left">名字</th><th align="left">别名(曾经使用过)</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">bigint</td><td align="left">int8</td><td align="left">有符号的8字节整数</td></tr><tr><td align="left">bigserial</td><td align="left">serial8</td><td align="left">自动增长的8字节整数</td></tr><tr><td align="left">bit [ (<em><strong>n</strong></em>) ]</td><td align="left"></td><td align="left">定长位串</td></tr><tr><td align="left">bit varying [ (<em><strong>n</strong></em>) ]</td><td align="left">varbit [ (<em><strong>n</strong></em>) ]</td><td align="left">变长位串</td></tr><tr><td align="left">boolean</td><td align="left">bool</td><td align="left">逻辑布尔值（真/假）</td></tr><tr><td align="left">box</td><td align="left"></td><td align="left">平面上的普通方框</td></tr><tr><td align="left">bytea</td><td align="left"></td><td align="left">二进制数据（“字节数组”）</td></tr><tr><td align="left">character [ (<em><strong>n</strong></em>) ]</td><td align="left">char [ (<em><strong>n</strong></em>) ]</td><td align="left">定长字符串</td></tr><tr><td align="left">character varying [ (<em><strong>n</strong></em>) ]</td><td align="left">varchar [ (<em><strong>n</strong></em>) ]</td><td align="left">变长字符串</td></tr><tr><td align="left">cidr</td><td align="left"></td><td align="left">IPv4或IPv6网络地址</td></tr><tr><td align="left">circle</td><td align="left"></td><td align="left">平面上的圆</td></tr><tr><td align="left">date</td><td align="left"></td><td align="left">日历日期（年、月、日）</td></tr><tr><td align="left">double precision</td><td align="left">float8</td><td align="left">双精度浮点数（8字节）</td></tr><tr><td align="left">inet</td><td align="left"></td><td align="left">IPv4或IPv6主机地址</td></tr><tr><td align="left">integer</td><td align="left">int, int4</td><td align="left">有符号4字节整数</td></tr><tr><td align="left">interval [ <em><strong>fields</strong></em> ] [ (<em><strong>p</strong></em>) ]</td><td align="left"></td><td align="left">时间段</td></tr><tr><td align="left">json</td><td align="left"></td><td align="left">文本 JSON 数据</td></tr><tr><td align="left">jsonb</td><td align="left"></td><td align="left">二进制 JSON 数据，已分解</td></tr><tr><td align="left">line</td><td align="left"></td><td align="left">平面上的无限长的线</td></tr><tr><td align="left">lseg</td><td align="left"></td><td align="left">平面上的线段</td></tr><tr><td align="left">macaddr</td><td align="left"></td><td align="left">MAC（Media Access Control）地址</td></tr><tr><td align="left">macaddr8</td><td align="left"></td><td align="left">MAC（Media Access Control）地址（EUI-64格式）</td></tr><tr><td align="left">money</td><td align="left"></td><td align="left">货币数量</td></tr><tr><td align="left">numeric [ (<em><strong>p</strong></em>, <em><strong>s</strong></em>) ]</td><td align="left">decimal [ (<em><strong>p</strong></em>, <em><strong>s</strong></em>) ]</td><td align="left">可选择精度的精确数字</td></tr><tr><td align="left">path</td><td align="left"></td><td align="left">平面上的几何路径</td></tr><tr><td align="left">pg_lsn</td><td align="left"></td><td align="left">PostgreSQL日志序列号</td></tr><tr><td align="left">pg_snapshot</td><td align="left"></td><td align="left">用户级事务ID快照</td></tr><tr><td align="left">point</td><td align="left"></td><td align="left">平面上的几何点</td></tr><tr><td align="left">polygon</td><td align="left"></td><td align="left">平面上的封闭几何路径</td></tr><tr><td align="left">real</td><td align="left">float4</td><td align="left">单精度浮点数（4字节）</td></tr><tr><td align="left">smallint</td><td align="left">int2</td><td align="left">有符号2字节整数</td></tr><tr><td align="left">smallserial</td><td align="left">serial2</td><td align="left">自动增长的2字节整数</td></tr><tr><td align="left">serial</td><td align="left">serial4</td><td align="left">自动增长的4字节整数</td></tr><tr><td align="left">text</td><td align="left"></td><td align="left">变长字符串</td></tr><tr><td align="left">time [ (<em><strong>p</strong></em>) ] [ without time zone ]</td><td align="left"></td><td align="left">一天中的时间（无时区）</td></tr><tr><td align="left">time [ (<em><strong>p</strong></em>) ] with time zone</td><td align="left">timetz</td><td align="left">一天中的时间，包括时区</td></tr><tr><td align="left">timestamp [ (<em><strong>p</strong></em>) ] [ without time zone ]</td><td align="left"></td><td align="left">日期和时间（无时区）</td></tr><tr><td align="left">timestamp [ (<em><strong>p</strong></em>) ] with time zone</td><td align="left">timestamptz</td><td align="left">日期和时间，包括时区</td></tr><tr><td align="left">tsquery</td><td align="left"></td><td align="left">文本搜索查询</td></tr><tr><td align="left">tsvector</td><td align="left"></td><td align="left">文本搜索文档</td></tr><tr><td align="left">txid_snapshot</td><td align="left"></td><td align="left">用户级别事务ID快照(废弃; 参见 pg_snapshot)</td></tr><tr><td align="left">uuid</td><td align="left"></td><td align="left">通用唯一标识码</td></tr><tr><td align="left">xml</td><td align="left"></td><td align="left">XML数据</td></tr></tbody></table><p>PG 还可以自定义数据类型，用户可以使用<a href="http://www.postgres.cn/docs/13/sql-createtype.html">CREATE TYPE</a>命令为 <code>PostgreSQL</code>增加新的数据类型</p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h3><p>PG 提供了多种索引类型： <code>B-tree</code>、<code>Hash</code>、<code>GiST</code>、<code>SP-GiST</code> 、<code>GIN</code> 和 <code>BRIN</code></p><ul><li><p><code>B-tree</code> 可以在可排序数据上的处理等值和范围查询</p></li><li><p><code>Hash</code> 索引只能处理简单等值比较</p></li><li><p><code>GiST</code> 索引并不是一种单独的索引，是一个通用的索引接口</p></li><li><p><code>SP-GiST</code> 类似 <code>GiST</code>，是一个通用的索引接口，但是 <code>SP-GIST</code> 使用了空间分区的方法，使得 <code>SP-GiST</code> 可以更好的支持非平衡数据结构，例如四叉树、k-d树和radix树</p></li><li><p><code>GIN</code> 索引是“倒排索引”，它适合于包含多个组成值的数据值，例如数组</p></li><li><p><code>BRIN</code> 索引是块级索引，有别于 <code>B-TREE</code> 等索引，BRIN 记录并不是以行号为单位记录索引明细，而是记录每个数据块或者每段连续的数据块的统计信息</p><p>因此 <code>BRIN</code> 索引空间占用特别的小，对数据写入、更新、删除的影响也很小</p><p>被索引列的值与物理存储相关性很强时，BRIN 索引的效果非常的好。例如时序数据，在时间或序列字段创建 <code>BRIN</code> 索引，进行等值、范围查询时效果很棒</p></li></ul><p>用户可以通过索引接口自定义索引</p><p>所以除上面的内置索引外，还有许多自定义索引，可以根据需求安装其他索引</p><h3 id="部分索引"><a href="#部分索引" class="headerlink" title="部分索引"></a>部分索引</h3><p>部分索引 又习惯称 <code>条件索引</code></p><p>一个条件索引是建立在表的一个子集上，而该子集则由一个条件表达式定义</p><p>而索引中只包含那些符合条件表达式的行。条件索引是一种专门的特性，但在很多种情况下它们也很有用</p><p>使用场景：</p><p>多租户的场景下，数据存在一个表中，不同租户存储的数据不同，使用场景不同，可以根据不同租户场景建立条件索引</p><h3 id="表达式索引"><a href="#表达式索引" class="headerlink" title="表达式索引"></a>表达式索引</h3><p>部分索引 又习惯称 <code>函数索引</code></p><p>一个索引列并不一定是底层表的一个列，也可以是从表的一列或多列计算而来的一个函数或者标量表达式</p><h2 id="过程语言"><a href="#过程语言" class="headerlink" title="过程语言"></a>过程语言</h2><blockquote><p>Procedural Language（过程语言）简称 PL</p></blockquote><p>几乎每个关系型数据库都有自己的PL实现，比如 Oracle 的 PL/SQL、SQL Server 的 T-SQL，而在 PG 中，提供的就是 PL/pgSQL</p><p>但是 PG 的 PL 支持多种语言，如下：</p><ul><li>PL/Java</li><li>PL/PHP</li><li>PL/Perl</li><li>PL/Python</li><li>PL/V8(JavaScript)</li></ul><h2 id="PostGIS"><a href="#PostGIS" class="headerlink" title="PostGIS"></a>PostGIS</h2><blockquote><p>官网：<a href="https://postgis.net/">https://postgis.net/</a></p></blockquote><h3 id="PostGIS介绍"><a href="#PostGIS介绍" class="headerlink" title="PostGIS介绍"></a>PostGIS介绍</h3><p><code>PostGIS</code> 是 PG 的一个空间对象扩展模块</p><p><code>PostGIS</code> 通过向 PG 添加对空间数据类型、空间索引和空间函数的支持，使其成为一个真正的大型空间数据库</p><p><code>PostGIS</code> 使 PG 目前成为开源空间信息软件领域性能最优的数据库</p><h3 id="PostGIS特性与功能"><a href="#PostGIS特性与功能" class="headerlink" title="PostGIS特性与功能"></a>PostGIS特性与功能</h3><ul><li><p><code>PostGIS</code> 支持所有的空间数据类型</p><p>这些类型包括：点（POINT）、线（LINESTRING）、多边形（POLYGON）、多点 （MULTIPOINT）、多线（MULTILINESTRING）、多多边形（MULTIPOLYGON）和集合对象集 （GEOMETRYCOLLECTION）等</p></li><li><p><code>PostGIS</code> 支持所有的对象表达方法</p><p>比如WKT和WKB。</p></li><li><p><code>PostGIS</code> 支持所有的数据存取和构造方法</p><p>如GeomFromText()、AsBinary()，以及GeometryN()等</p></li><li><p><code>PostGIS</code> 提供简单的空间分析函数</p><p>如Area和Length</p><p>同时也提供其他一些具有复杂分析功能的函数</p><p>比如Distance。</p></li><li><p><code>PostGIS</code> 提供了对于元数据的支持</p><p>如GEOMETRY_COLUMNS和SPATIAL_REF_SYS</p><p>同时，PostGIS也提供了相应的支持函数</p><p>如AddGeometryColumn和DropGeometryColumn。</p></li><li><p><code>PostGIS</code> 提供了一系列的二元谓词（如Contains、Within、Overlaps和Touches）用于检测空间对象之间的空间关系，同时返回布尔值来表征对象之间符合这个关系</p></li><li><p><code>PostGIS</code> 提供了空间操作符（如Union和Difference）用于空间数据操作</p><p>比如，Union操作符融合多边形之间的边界。两个交迭的多边形通过Union运算就会形成一个新的多边形，这个新的多边形的边界为两个多边形中最大边界</p></li><li><p>数据库坐标变换</p></li><li><p>球体长度运算</p></li><li><p>三维的几何类型</p></li><li><p>空间聚集函数</p></li><li><p>栅格数据类型</p></li><li><p>……</p></li></ul><p>PostGIS 的功能非常强大，PG 有目前的影响力 PostGIS 功不可没~</p><h1 id="PG的特殊能力"><a href="#PG的特殊能力" class="headerlink" title="PG的特殊能力"></a>PG的特殊能力</h1><h2 id="用户自定义对象"><a href="#用户自定义对象" class="headerlink" title="用户自定义对象"></a>用户自定义对象</h2><p>用户可以创建数据库中几乎所有对象的新类型，包括但不限于：</p><ul><li>自定义数据类型</li><li>自定义类型转换</li><li>自定义操作符</li><li>自定义函数，包括聚合函数和窗口函数</li><li>自定义索引</li><li>自定义过程语言</li></ul><h2 id="窗口函数"><a href="#窗口函数" class="headerlink" title="窗口函数"></a>窗口函数</h2><p>一个窗口函数在一系列与当前行有某种关联的表行上执行一种计算。这与一个聚集函数所完成的计算有可比之处。但是窗口函数并不会使多行被聚集成一个单独的输出行，这与通常的非窗口聚集函数不同。取而代之，行保留它们独立的标识。在这些现象背后，窗口函数可以访问的不仅仅是查询结果的当前行。</p><ol><li>可以访问与当前记录相关的多行记录；</li><li>不会使多行聚集成一行， 与聚集函数的区别；</li></ol><p>例如结合窗口函数得到总行数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">select * from testtable;</span><br><span class="line"> id | value</span><br><span class="line">----+-------</span><br><span class="line"> <span class="number">1</span> | <span class="number">1</span></span><br><span class="line"> <span class="number">2</span> | <span class="number">2</span></span><br><span class="line"> <span class="number">3</span> | <span class="number">3</span></span><br><span class="line"> <span class="number">4</span> | <span class="number">4</span></span><br><span class="line"> <span class="number">5</span> | <span class="number">5</span></span><br><span class="line"> <span class="number">6</span> | <span class="number">6</span></span><br><span class="line"> <span class="number">7</span> | <span class="number">7</span></span><br><span class="line"> <span class="number">8</span> | <span class="number">8</span></span><br><span class="line"> <span class="number">9</span> | <span class="number">9</span></span><br><span class="line"> <span class="number">10</span> | <span class="number">10</span></span><br><span class="line">(<span class="number">10</span> rows)</span><br><span class="line">select id,count(*) over () from testtable where id &lt; <span class="number">9</span> limit <span class="number">3</span>;</span><br><span class="line"> id | count</span><br><span class="line">----+-------</span><br><span class="line"> <span class="number">1</span> | <span class="number">8</span></span><br><span class="line"> <span class="number">2</span> | <span class="number">8</span></span><br><span class="line"> <span class="number">3</span> | <span class="number">8</span></span><br><span class="line">即，count over会在limit 和 offset之前计算，结果就是总行数。</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2><blockquote><p>PG 还有许多特殊的能力，只有想不到的，没有做不到的</p></blockquote><ul><li><p>表继承</p></li><li><p>触发器不光可以拦截 DML 还可以拦截 DDL 语句</p></li><li><p>时序数据支持</p></li><li><p>分区表</p></li><li><p>外部数据源FDW，PG 中可以引用多种外部数据，包括MySQL、Oracle等主流关系型数据库，甚至还支持Redis、MongoDB等非关系型数据库</p></li><li><p>……</p></li></ul><h1 id="PG、MySQL对比"><a href="#PG、MySQL对比" class="headerlink" title="PG、MySQL对比"></a>PG、MySQL对比</h1><h2 id="数据表存储结构对比"><a href="#数据表存储结构对比" class="headerlink" title="数据表存储结构对比"></a>数据表存储结构对比</h2><p>堆表(heap table）和索引组织表（Index Oragnization Table，简称IOT)是两种数据表的存储结构</p><p><strong>PG 中的表是堆表。MySQL Innodb引擎中的表是索引组织表</strong></p><ul><li><p>堆表</p><p>堆表的特点就是索引和数据分开存储</p><p>表数据行在堆中存储，没有任何特定顺序，向一个全新的没有做过更新和删除的堆中插入一行时候，总是 append 到堆表文件的最后一页当中。因为不用考虑排序，所以插入速度会比较快。</p><p>索引存储在索引里，所有索引都是二级索引，或叫辅助索引。所以主键索引也是二级索引，没有完整记录，区别只有唯一或非唯一</p><p><strong>优点：</strong>写入速度快、辅助索引查询较快、全表扫描快</p><p><strong>缺点：</strong>磁盘空间消耗较大、主键查询较慢，需要先按主键索引找到数据的物理位置、</p></li><li><p>索引组织表</p><p>索引组织表特点是数据和主键索引一起存储</p><p>数据存储在聚簇索引中，或者说，数据按照主键的顺序来组织数据，两者合二为一。主键索引，叶子节点存放整行数据。其他索引称为辅助索引(二级索引），叶子节点存放键值和主键值</p><p><strong>优点：</strong>主键查询比较快、比较节约磁盘、更新效率更高</p><p><strong>缺点：</strong>二级索引查询慢，需要回表</p></li></ul><h2 id="MVCC对比"><a href="#MVCC对比" class="headerlink" title="MVCC对比"></a>MVCC对比</h2><p>MVCC的两种实现方法：</p><ol><li><p>当写入新数据时，把原有数据转移到一个单独的地方，如undo段中，其他人读数据时，会读取undo中的旧数据</p></li><li><p>当写入新数据时，原有数据不删除，而是把新数据插入，在不同版本的原有数据不需要时，垃圾回收器将回收这些过期的数据</p></li></ol><p>MySQL：</p><p>MySQL采用的就是第一种方式，详细不在说明</p><p>PG：</p><p>PG 采用的第二种方式，数据文件中存放着每一逻辑行的多个版本，问题随之而来，表空间会非常容易膨胀</p><p>为了解决表空间膨胀的问题，PG 采用 <a href="http://postgres.cn/docs/13/sql-vacuum.html">VACUUM</a> 方式，来回收历史数据，且需要定期手动进行 VACUUM</p><h2 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h2><p>任何系统都有它的性能极限，在高并发读写，负载逼近极限下，PG的性能指标仍可以维持双曲线甚至对数曲线，到顶峰之后不再下降，而 MySQL 明显出现一个波峰后下滑（5.5版本之后，在企业级版本中有个插件可以改善很多，不过需要付费）</p><h2 id="其他对比"><a href="#其他对比" class="headerlink" title="其他对比"></a>其他对比</h2><table><thead><tr><th align="left">特性</th><th align="left">PG</th><th align="left">MySQL</th></tr></thead><tbody><tr><td align="left">口号性特点</td><td align="left">最先进的开源数据库</td><td align="left">最流行的开源数据库</td></tr><tr><td align="left">SQL编程能力</td><td align="left">强大的SQL能力，包括丰富的统计函数和统计分析，对BI 有很好的支持</td><td align="left">没有强大的统计功能支持</td></tr><tr><td align="left">数据类型</td><td align="left">丰富的数据类型支持，包括地理信息、几何图形、 json、数组等，json也可以建立索引</td><td align="left">在地理信息支持度上不如PG，不支持几何图形等数据 类型</td></tr><tr><td align="left">事务能力</td><td align="left">完整的ACID事务支持</td><td align="left">不是完整的支持ACID事务特性</td></tr><tr><td align="left">join</td><td align="left">支持nested-loop, sort-merge, hash三种类型</td><td align="left">只支持nested-loop</td></tr><tr><td align="left">Text类型</td><td align="left">没有长度限制，可以直接访问，可以索引，可以全文索 引</td><td align="left">有长度限制</td></tr><tr><td align="left">复杂查询</td><td align="left">支持窗口函数，支持递归，支持with语句</td><td align="left">不支持窗口函数、递归等</td></tr><tr><td align="left">索引</td><td align="left">多种索引类型，包括b-tree，hash，gin，gist等，可以 对模糊查询、正则表达式、地理信息系统等建立索引</td><td align="left">主要是b-tree索引</td></tr><tr><td align="left">数据复制</td><td align="left">同步，异步，半同步复制，以及基于日志逻辑复制，可以实现表级别的订阅和发布</td><td align="left">只支持异步复制</td></tr><tr><td align="left">查询优化器</td><td align="left">功能更强大，对子查询的支持更高效</td><td align="left">子查询效率不高</td></tr><tr><td align="left">7*24</td><td align="left">隔一段时间需要进行VACUUM</td><td align="left">适用7*24</td></tr><tr><td align="left">性能和适用场景</td><td align="left">复杂查询</td><td align="left">简单业务场景，更高的TPS</td></tr><tr><td align="left">大小写</td><td align="left">大小写敏感</td><td align="left">大小写不敏感</td></tr><tr><td align="left">行大小限制</td><td align="left">无限制</td><td align="left">65535</td></tr></tbody></table><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><p>官方文档</p><p><a href="https://www.postgresql.org/">https://www.postgresql.org/</a></p></li><li><p>PG中文社区</p><p><a href="http://www.postgres.cn/v2/home">http://www.postgres.cn/v2/home</a></p></li><li><p>PG官方客户端工具</p><p><a href="https://www.pgadmin.org/">https://www.pgadmin.org/</a></p></li><li><p>PG相关高质量博客</p><p><a href="https://postgres.fun/">https://postgres.fun/</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/postgresql0.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;关于PostgreSQL&quot;&gt;&lt;a href=&quot;#关于PostgreSQL&quot; class=&quot;headerlink&quot; title=&quot;关于PostgreSQL&quot;&gt;&lt;/a&gt;关于Postg</summary>
      
    
    
    
    <category term="DB" scheme="http://yoursite.com/categories/DB/"/>
    
    
    <category term="DB" scheme="http://yoursite.com/tags/DB/"/>
    
    <category term="PostgreSQL" scheme="http://yoursite.com/tags/PostgreSQL/"/>
    
  </entry>
  
  <entry>
    <title>金字塔原理</title>
    <link href="http://yoursite.com/2021/09/24/%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2021/09/24/%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%86/</id>
    <published>2021-09-24T08:22:37.000Z</published>
    <updated>2021-11-06T05:32:56.327Z</updated>
    
    <content type="html"><![CDATA[<h2 id="结构思考力三层次模型"><a href="#结构思考力三层次模型" class="headerlink" title="结构思考力三层次模型"></a>结构思考力三层次模型</h2><h3 id="三层模型"><a href="#三层模型" class="headerlink" title="三层模型"></a>三层模型</h3><p>理解 -&gt; 重构 -&gt; 呈现</p><p><img src="/images/%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%860.png"></p><h3 id="模型目标"><a href="#模型目标" class="headerlink" title="模型目标"></a>模型目标</h3><p>隐形思维显性化 -&gt; 显性思维结构化 -&gt; 结构思维形象化</p><ul><li>隐形思维显性化：要提高自己的思考，首先要看到它</li><li>显性思维结构化：看到之后发现不清晰，需要结构化</li><li>结构思维形象化：结构化之后还需要把它传递出去，需要形象化的表达</li></ul><h3 id="金字塔结构"><a href="#金字塔结构" class="headerlink" title="金字塔结构"></a>金字塔结构</h3><p><img src="/images/%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%861.png"></p><blockquote><p>结构化思维是一种“从无序到有序”的思考过程</p><p>需要建立一个“先总后分”的思维方式。先找到解决问题的关键要点，然后再深入分析</p></blockquote><h2 id="理解：隐形思维显性化"><a href="#理解：隐形思维显性化" class="headerlink" title="理解：隐形思维显性化"></a>理解：隐形思维显性化</h2><h3 id="概况全文的“万能公式”"><a href="#概况全文的“万能公式”" class="headerlink" title="概况全文的“万能公式”"></a>概况全文的“万能公式”</h3><blockquote><p><code>在___的基础上，</code></p><p><code>从__，__，__N个方面，</code></p><p><code>说明了_____________。</code></p></blockquote><h3 id="结构思考力识别概况技术"><a href="#结构思考力识别概况技术" class="headerlink" title="结构思考力识别概况技术"></a>结构思考力识别概况技术</h3><blockquote><p>识别 -&gt; 判断 -&gt; 概况</p></blockquote><p><img src="/images/%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%862.png"></p><h3 id="隐形思维显性化前提"><a href="#隐形思维显性化前提" class="headerlink" title="隐形思维显性化前提"></a>隐形思维显性化前提</h3><p>隐形思维显性化的前提———有审视问题的坐标系</p><p><img src="/images/%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%863.png"></p><ul><li>审视问题的坐标系：<blockquote><p>这个事情有没有证据和理由支撑？</p><p>这个理由/逻辑是否能够推出结论？</p><p>其中的证据/事实是否能有效支撑理由？</p><p>是否存在隐藏或模糊不利的证据/事实？</p></blockquote></li></ul><h2 id="重构：显性思维结构化"><a href="#重构：显性思维结构化" class="headerlink" title="重构：显性思维结构化"></a>重构：显性思维结构化</h2><h3 id="重构四原则"><a href="#重构四原则" class="headerlink" title="重构四原则"></a>重构四原则</h3><ul><li><p>论-结论先行</p><blockquote><p>一段表达有一个核心观点，最好放在开头</p></blockquote></li><li><p>证-以上统下</p><blockquote><p>任何一层的论点，是下一层思想的概括</p></blockquote></li><li><p>类-归类分组</p><blockquote><p>每一组思想属于同一个范畴</p></blockquote></li><li><p>比-逻辑递进</p><blockquote><p>每一组思想按照一定的逻辑顺序排列</p></blockquote></li></ul><h3 id="论-结论先行"><a href="#论-结论先行" class="headerlink" title="论-结论先行"></a>论-结论先行</h3><p>结论先行可以提升我们的表达效率，让人快速理解你的核心意思。结论先行的难点不是先行，而是如何得出结论，需要反复联系</p><p><img src="/images/%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%864.png"></p><h3 id="证-以上统下"><a href="#证-以上统下" class="headerlink" title="证-以上统下"></a>证-以上统下</h3><p>上有结论，下有理由，结论概括理由，理由支撑结论，上下对应</p><p><img src="/images/%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%865.png"></p><h3 id="类-归类分组"><a href="#类-归类分组" class="headerlink" title="类-归类分组"></a>类-归类分组</h3><blockquote><p>人类大脑一次性接收的信息量是有范围的，这个范围有两个说法：5+-2 和 7+-2，不管是哪个说法，7都是一个临界值，当超过7时都会对记忆造成负担，所以在写方案时最好不要超过7条</p></blockquote><blockquote><p>而很多领导讲话都喜欢讲3点，理由有</p><ol><li>好记</li><li>对方更容易倾听</li><li>具有说服力；同时在物理结构中，3是稳定结构</li></ol><p>但是3点要能把事情说轻，说全，而这依赖 归类分组</p></blockquote><h4 id="MECE原则"><a href="#MECE原则" class="headerlink" title="MECE原则"></a>MECE原则</h4><blockquote><p>归类分组标准采用 MECE原则</p></blockquote><p>相互独立、完全穷尽</p><p>分类时不能有交叉、更不能有遗漏，不重不漏</p><p><img src="/images/%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%866.png"></p><h3 id="比-逻辑递进"><a href="#比-逻辑递进" class="headerlink" title="比-逻辑递进"></a>比-逻辑递进</h3><p>三种顺序</p><ul><li>时间顺序</li><li>结构顺序</li><li>重要性顺序</li></ul><p><strong>在同一个层级、同一个分支，必须使用同一种逻辑顺序</strong></p><p><img src="/images/%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%867.png"></p><h2 id="呈现：结构思维形象化"><a href="#呈现：结构思维形象化" class="headerlink" title="呈现：结构思维形象化"></a>呈现：结构思维形象化</h2><blockquote><p>形象化表达是结构化思考最有力的输出方式，结构化思考是形象化表达的基础</p></blockquote><h3 id="结构罗盘"><a href="#结构罗盘" class="headerlink" title="结构罗盘"></a>结构罗盘</h3><blockquote><p>形象化表达工具——结构罗盘</p></blockquote><blockquote><p>“配”关系 -&gt; “得”图示 -&gt; “上”包装</p></blockquote><p><img src="/images/%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%868.png"></p><ul><li>配关系：确定关系结构图下的一个分支的要素之间是什么关系</li><li>得图示：根据关系选择不同图示</li><li>上包装：对观点进行高度浓缩提炼，变得更加简洁、明了、容易记忆，及所谓“卖点包装”</li></ul><h3 id="配关系"><a href="#配关系" class="headerlink" title="配关系"></a>配关系</h3><p>四种模式，十六种关系</p><p>根据关系分支下的要素判断属于哪一种模式中的哪一种关系</p><p><img src="/images/%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%869.png"></p><h3 id="得图示"><a href="#得图示" class="headerlink" title="得图示"></a>得图示</h3><h3 id="上包装"><a href="#上包装" class="headerlink" title="上包装"></a>上包装</h3><p>可以把观点凝练成一句口诀，既好记，又有高度，这种方法为“卖点包装”</p><p>可以根据四种包装方法来进行包装</p><ul><li>简化</li><li>类比</li><li>整合</li><li>引用</li></ul><p><img src="/images/%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%8610.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;结构思考力三层次模型&quot;&gt;&lt;a href=&quot;#结构思考力三层次模型&quot; class=&quot;headerlink&quot; title=&quot;结构思考力三层次模型&quot;&gt;&lt;/a&gt;结构思考力三层次模型&lt;/h2&gt;&lt;h3 id=&quot;三层模型&quot;&gt;&lt;a href=&quot;#三层模型&quot; class=&quot;head</summary>
      
    
    
    
    <category term="通用能力" scheme="http://yoursite.com/categories/%E9%80%9A%E7%94%A8%E8%83%BD%E5%8A%9B/"/>
    
    
    <category term="通用能力" scheme="http://yoursite.com/tags/%E9%80%9A%E7%94%A8%E8%83%BD%E5%8A%9B/"/>
    
  </entry>
  
  <entry>
    <title>单元测试-Spock</title>
    <link href="http://yoursite.com/2021/08/25/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-Spock/"/>
    <id>http://yoursite.com/2021/08/25/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-Spock/</id>
    <published>2021-08-25T03:22:37.000Z</published>
    <updated>2021-11-06T06:04:57.001Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>单元测试的重要性不言而喻，但在实际开发中单元测试往往都是缺失的，原因有很多，其中比较重要的一点是工期短、写单测耗时长</p><p>针对这种问题，为了提高写单测的效率，推荐 Spock 测试框架，改善单测体验、解放生产力~</p><h1 id="Spock是什么"><a href="#Spock是什么" class="headerlink" title="Spock是什么"></a>Spock是什么</h1><p>官网：<a href="https://spockframework.org/">https://spockframework.org/</a></p><h2 id="Spock简介"><a href="#Spock简介" class="headerlink" title="Spock简介"></a>Spock简介</h2><p>官方介绍：</p><blockquote><p>Spock is a testing and specification framework for Java and Groovy applications. What makes it stand out from the crowd is its beautiful and highly expressive specification language. Thanks to its JUnit runner, Spock is compatible with most IDEs, build tools, and continuous integration servers. Spock is inspired from JUnit, jMock, RSpec, Groovy, Scala, Vulcans, and other fascinating life forms.</p></blockquote><p>简单来说，<code>Spock</code> 是一个测试框架，有以下几个核心特点：</p><ul><li>可以应用于 <code>java</code> 或 <code>groovy</code> 应用的单元测试框架。</li><li>测试代码使用基于 <code>groovy</code> 语言扩展而成的规范说明语言（<code>specification language</code>）。</li><li>遵从 BDD（行为驱动开发）模式，有助于提升代码的质量。</li><li>通过 <code>junit runner</code> 调用测试，兼容绝大部分 <code>junit</code> 的运行场景（ide，构建工具，持续集成等）。</li><li>框架的设计思路参考了 <code>JUnit</code>，<code>jMock</code>，<code>RSpec</code>，<code>Groovy</code>，<code>Scala</code>，<code>Vulcans</code>……</li></ul><h2 id="与其他框架对比"><a href="#与其他框架对比" class="headerlink" title="与其他框架对比"></a>与其他框架对比</h2><p><img src="/images/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-Spock0.jpeg"></p><p><code>Spock</code> = 传统测试框架 + <code>Mock</code>+ <code>BDD</code> + 文档化</p><blockquote><p>代码规范化，结构层次清晰</p><p>简单易读、可维护性强</p><p>基于 <code>Groovy</code> 更快的写单侧</p><p>漂亮的参数化测试和异常测试<br><img src="/images/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-Spock1.png"></p></blockquote><p>缺点：</p><blockquote><p>偶尔有坑（版本不兼容等）</p><p>需要了解 <code>Groovy</code> 语言</p><p>与其它 java 测试框架风格相差比较大，需要适应</p></blockquote><p>而这些理由比起 <code>Spock</code> 提供的易于开发和维护的单元测试代码来说，是可以忽略的。。。</p><h1 id="Groovy"><a href="#Groovy" class="headerlink" title="Groovy"></a>Groovy</h1><p>使用 <code>Spock</code> 前先了解下 <code>Groovy</code></p><p>维基百科介绍：</p><blockquote><p>Groovy是Java平台上设计的面向对象编程语言。这门动态语言拥有类似Python、Ruby和Smalltalk中的一些特性，可以作为Java平台的脚本语言使用。</p></blockquote><p><code>Groovy</code> 的语法与 <code>Java</code> 非常相似，以至于多数的 <code>Java</code> 代码也是正确的 <code>Groovy</code> 代码。<code>Groovy</code> 代码动态的被编译器转换成 <code>Java</code> 字节码。由于其运行在JVM上的特性，<code>Groovy</code> 可以使用其他 <code>Java</code> 语言编写的库。</p><p>虽然需要了解 <code>Groovy</code>，但不用担心，<code>Groovy</code> 是一门比较轻量，学习门槛也比较低的语言，而且最重要的是 <code>Groovy</code> 支持 <code>Java</code> 语法，所以理论上使用纯 <code>Java</code> 写 <code>Groovy</code> 也是可以的~</p><p>而且熟悉使用 <code>Spock</code> 后，不仅提升了写单测的速度，还多学了一门脚本语言，两全其美~~</p><h2 id="Groovy-语法糖"><a href="#Groovy-语法糖" class="headerlink" title="Groovy 语法糖"></a>Groovy 语法糖</h2><p><img src="/images/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-Spock2.png"><br><img src="/images/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-Spock3.png"><br><img src="/images/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-Spock4.png"></p><blockquote><p>不用分号</p><p>可选择性使用 <code>return</code></p><p>默认采用 <code>public</code> 修饰符</p><p><code>==</code> 与 <code>equals</code></p></blockquote><p>更多语法参考推荐文档。。。</p><h2 id="Groovy-推荐文档"><a href="#Groovy-推荐文档" class="headerlink" title="Groovy 推荐文档"></a>Groovy 推荐文档</h2><p><a href="https://groovy-lang.org/documentation.html">https://groovy-lang.org/documentation.html</a></p><p><a href="https://sysgears.com/articles/groovy-differences-java/">https://sysgears.com/articles/groovy-differences-java/</a></p><p><a href="https://wiki.jikexueyuan.com/project/groovy-introduction/differences-with-java.html">https://wiki.jikexueyuan.com/project/groovy-introduction/differences-with-java.html</a></p><h1 id="使用Spock"><a href="#使用Spock" class="headerlink" title="使用Spock"></a>使用Spock</h1><blockquote><p>Spock Web Console</p><p><a href="https://meetspock.appspot.com/">https://meetspock.appspot.com/</a></p></blockquote><h2 id="使用姿势"><a href="#使用姿势" class="headerlink" title="使用姿势"></a>使用姿势</h2><ul><li><p>安装 IDE 插件</p><p><img src="/images/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-Spock5.png"></p></li><li><p>maven 引用</p><blockquote><p>建议使用 1.3-groovy-2.4 版本，其他版本可能与其他包有兼容问题</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.spockframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spock-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3-groovy-2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.spockframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spock-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3-groovy-2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建 Groovy 测试目录</p><p><img src="/images/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-Spock6.png"></p></li><li><p>编写测试代码</p><p><img src="/images/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-Spock7.png"></p></li></ul><p>创建测试类时可以这俩个，<code>Spock Specification</code> 会自动继承 <code>Specification</code>，<code>Groovy Class</code> 需要自己继承</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> spock.lang.Specification</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpockDemo</span> <span class="keyword">extends</span> <span class="title">Specification</span> </span>&#123; </span><br><span class="line">    def <span class="string">&quot;test&quot;</span>() &#123;</span><br><span class="line">        given: <span class="string">&quot;数据准备&quot;</span></span><br><span class="line">      def list = []</span><br><span class="line">        </span><br><span class="line">        when: <span class="string">&quot;执行需要测试的代码&quot;</span></span><br><span class="line">        list.add(<span class="string">&quot;test&quot;</span>)</span><br><span class="line"></span><br><span class="line">        then: <span class="string">&quot;验证执行结果&quot;</span></span><br><span class="line">        !list.empty </span><br><span class="line">        stack.size() == <span class="number">1</span>   </span><br><span class="line">    &#125;   </span><br><span class="line">    </span><br><span class="line">    def <span class="string">&quot;测试&quot;</span>() &#123;</span><br><span class="line">        expect:</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="集成-Spring"><a href="#集成-Spring" class="headerlink" title="集成 Spring"></a>集成 Spring</h2><p>和 Junit 集成的方式一样</p><ul><li><p>Spring</p><p><code>@ContextConfiguration(locations = &quot;classpath:spring-context.xml&quot;)</code></p></li><li><p>SpringBoot</p><p><code>@SpringBootTest</code></p></li></ul><h2 id="Spock中的概念"><a href="#Spock中的概念" class="headerlink" title="Spock中的概念"></a>Spock中的概念</h2><ul><li><p>Specification</p><p>在 <code>Spock</code> 中，待测系统的行为是由规格(specification) 所定义的。在使用 <code>Spock</code> 框架编写测试时，测试类需要继承自 <code>Specification</code> 类。</p></li><li><p>模板方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def setup() &#123;&#125;          &#x2F;&#x2F; run before every feature method</span><br><span class="line">def cleanup() &#123;&#125;        &#x2F;&#x2F; run after every feature method</span><br><span class="line">def setupSpec() &#123;&#125;     &#x2F;&#x2F; run before the first feature method</span><br><span class="line">def cleanupSpec() &#123;&#125;   &#x2F;&#x2F; run after the last feature method</span><br></pre></td></tr></table></figure><p>和 Junit 对比：</p><table><thead><tr><th>Spock</th><th>Junit</th></tr></thead><tbody><tr><td>setup()</td><td>@Before</td></tr><tr><td>cleanup()</td><td>@After</td></tr><tr><td>setupSpec()</td><td>@BeforeClass</td></tr><tr><td>cleanupSpec()</td><td>@AfterClass</td></tr></tbody></table></li><li><p>Feature methods</p><p>就是测试类中的测试方法，方法名可以是中文</p></li><li><p>blocks</p><p>每个测试方法又被划分为不同的 <code>block</code>，不同的 <code>block</code> 处于测试执行的不同阶段，在测试运行时，各个 <code>block</code> 按照不同的顺序和规则被执行，如下图：</p><p><img src="/images/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-Spock8.png"></p><blockquote><p><code>Spock</code> 定义了多种标签，去描述代码“应该做什么”，“输入条件是什么”，“输出是否符合预期”，从语义层面规范了代码的编写</p></blockquote><p><strong>setup</strong>：也可以写成 <code>given</code>，在这个 <code>block</code> 中会放置与这个测试方法相关的初始化程序，可选</p><p><strong>given</strong>：输入条件（前置参数），一般会在这个 <code>block</code> 中定义局部变量，<code>mock</code> 等，可选</p><p><strong>when</strong>、<code>then</code>：<code>when</code> 与 <code>then</code> 需要搭配使用，一起出现，在 <code>when</code> 中执行待测试的函数，在 <code>then</code> 中判断是否符合预期</p><p><strong>expect</strong>：可以看做精简版的 when+then</p><p><strong>and</strong>：衔接上个标签，补充的作用</p><p><strong>cleanup</strong>：退出前做一些清理工作，如关闭资源等</p><p><strong>where</strong>：做测试时最复杂的事情之一就是准备测试数据，尤其是要测试边界条件、测试异常分支等，这些都需要在测试之前规划好数据。但是传统的测试框架很难轻松的制造数据，要么依赖反复调用，要么使用其他丑陋的方式；在 <code>Spock</code> 中 <code>where</code> 完美解决了这个问题，<code>where</code> 可以说是 <code>Spock</code> 的核心，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* where 有两种写法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpockDemo</span> <span class="keyword">extends</span> <span class="title">Specification</span> </span>&#123;</span><br><span class="line">    def <span class="string">&quot;max&quot;</span>() &#123;</span><br><span class="line">        expect:</span><br><span class="line">        Math.max(a, b) == c</span><br><span class="line"></span><br><span class="line">        where: <span class="string">&quot;多个列使用 | 单竖线隔开，|| 双竖线区分输入和输出变量，即左边是输入值，右边是输出值&quot;</span></span><br><span class="line">        a | b || c</span><br><span class="line">        <span class="number">3</span> | <span class="number">5</span> || <span class="number">5</span></span><br><span class="line">        <span class="number">7</span> | <span class="number">0</span> || <span class="number">7</span></span><br><span class="line">        <span class="number">0</span> | <span class="number">0</span> || <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpockDemo</span> <span class="keyword">extends</span> <span class="title">Specification</span> </span>&#123;</span><br><span class="line">    def <span class="string">&quot;max&quot;</span>() &#123;</span><br><span class="line">        expect:</span><br><span class="line">        Math.max(a, b) == c</span><br><span class="line"></span><br><span class="line">        where:</span><br><span class="line">        a &lt;&lt; [<span class="number">3</span>, <span class="number">7</span>, <span class="number">0</span>]</span><br><span class="line">        b &lt;&lt; [<span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">        c &lt;&lt; [<span class="number">5</span>, <span class="number">7</span>, <span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><p>在 <code>then</code> 或 <code>expect</code> 中会默认 <code>assert</code> 所有返回值是 <code>boolean</code> 型的语句，所以在 <code>then</code> 和 <code>expect</code> 语句块中不需要写 <code>assert</code></p><p>如果要在其它地方增加断言，需要显式增加 <code>assert</code> 关键字，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  stack = <span class="keyword">new</span> Stack()</span><br><span class="line">  <span class="keyword">assert</span> stack.empty</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="with"><a href="#with" class="headerlink" title="with"></a>with</h3><p><code>with</code> 语句可以验证对象内部的多个属性是否符合预期值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">expect:</span><br><span class="line">with(response) &#123;</span><br><span class="line">  code == <span class="number">0</span></span><br><span class="line">  message == <span class="string">&quot;成功&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异常断言"><a href="#异常断言" class="headerlink" title="异常断言"></a>异常断言</h3><p>验证有没有抛出异常，可以用 <code>thrown()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def <span class="string">&quot;test&quot;</span>() &#123;</span><br><span class="line">  given:</span><br><span class="line">  def str = <span class="keyword">null</span></span><br><span class="line"></span><br><span class="line">  when:</span><br><span class="line">  str.add(<span class="string">&quot;test&quot;</span>)</span><br><span class="line"></span><br><span class="line">  then:</span><br><span class="line">  thrown(NullPointerException)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>要验证没有抛出某种异常，可以用 <code>notThrown()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def <span class="string">&quot;test&quot;</span>() &#123;</span><br><span class="line">  given:</span><br><span class="line">  def str = []</span><br><span class="line"></span><br><span class="line">  when:</span><br><span class="line">  str.add(<span class="string">&quot;test&quot;</span>)</span><br><span class="line"></span><br><span class="line">  then:</span><br><span class="line">  notThrown(NullPointerException)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Annotation"><a href="#Annotation" class="headerlink" title="Annotation"></a>Annotation</h2><table><thead><tr><th>注解</th><th>用途</th><th>样例</th></tr></thead><tbody><tr><td>Shared</td><td>在多个测试间共享变量</td><td>@Shared def h2 = new H2Database()</td></tr><tr><td>AutoCleanUp</td><td>测试结束后回收资源，不管是否发生异常等</td><td>@AutoCleanup(“shutdown”) def executor = new Executor()</td></tr><tr><td>Ignore</td><td>忽略这个测试</td><td></td></tr><tr><td>IgnoreIf</td><td>忽略满足条件的测试</td><td>@IgnoreIf(os.isWindows())</td></tr><tr><td>IgnoreRest</td><td>只运行这个测试</td><td></td></tr><tr><td>Requries</td><td>满足设定的条件才运行这个测试</td><td>@Requires({env.containsKey(“HASH_KEY_TO_AUTHENTICATE”)})</td></tr><tr><td>Unroll</td><td>配合数据表的时候，每行运行一个测试</td><td></td></tr><tr><td>FailsWith</td><td>运行测试必然抛出某个异常</td><td></td></tr><tr><td>Issue</td><td>指明这个测试对应某个issue</td><td>@Issue(“<a href="http://redmine.example.com/issues/2554&quot;">http://redmine.example.com/issues/2554&quot;</a>)</td></tr><tr><td>Timeout</td><td>如果运行时间超过某个阈值，则判定为失败</td><td>@Timeout(value = 5000, unit = TimeUnit.MILLISECONDS)</td></tr><tr><td>Title</td><td>设定一个更容易理解的标题名</td><td>@Title(”测试在》繁忙情况下》发红包”)</td></tr></tbody></table><h1 id="Mock"><a href="#Mock" class="headerlink" title="Mock"></a>Mock</h1><blockquote><p><code>Spock</code> 自带 <code>Mock</code> 功能，使用简单方便，同时也支持扩展第三方 <code>Mock</code> 框架，比如 <code>PowerMock</code></p></blockquote><h2 id="SpockMock"><a href="#SpockMock" class="headerlink" title="SpockMock"></a>SpockMock</h2><h3 id="Mock-1"><a href="#Mock-1" class="headerlink" title="Mock"></a>Mock</h3><p>创建一个假对象，验证是否执行了某些操作(在 <code>then</code> 或 <code>expect</code> 语句块中)</p><ul><li><p>创建一个 <code>Mock</code> 对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PublisherSpec</span> <span class="keyword">extends</span> <span class="title">Specification</span> </span>&#123;</span><br><span class="line">    Publisher publisher = <span class="keyword">new</span> Publisher()</span><br><span class="line">    <span class="comment">// def subscriber = Mock(Subscriber)</span></span><br><span class="line">    Subscriber subscriber = Mock()</span><br><span class="line">    <span class="comment">// def subscriber2 = Mock(Subscriber)</span></span><br><span class="line">    Subscriber subscriber2 = Mock()</span><br><span class="line"></span><br><span class="line">    <span class="function">def <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        publisher.subscribers.add(subscriber)</span><br><span class="line">        publisher.subscribers.add(subscriber2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>交互验证</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def <span class="string">&quot;should send messages to all subscribers&quot;</span>() &#123;</span><br><span class="line">    when:</span><br><span class="line">    publisher.send(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"></span><br><span class="line">    then:</span><br><span class="line">    <span class="number">1</span> * subscriber.receive(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">    <span class="number">1</span> * subscriber2.receive(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 publisher 调用 send 时，两个 subscriber 都应该被调用一次 receive(“hello”)</p></li><li><p>示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> * subscriber.receive(<span class="string">&quot;hello&quot;</span>)      <span class="comment">// exactly one call</span></span><br><span class="line"><span class="number">0</span> * subscriber.receive(<span class="string">&quot;hello&quot;</span>)      <span class="comment">// zero calls</span></span><br><span class="line">(<span class="number">1.</span><span class="number">.3</span>) * subscriber.receive(<span class="string">&quot;hello&quot;</span>) <span class="comment">// between one and three calls (inclusive)</span></span><br><span class="line">(<span class="number">1.</span>._) * subscriber.receive(<span class="string">&quot;hello&quot;</span>) <span class="comment">// at least one call</span></span><br><span class="line">(_.<span class="number">.3</span>) * subscriber.receive(<span class="string">&quot;hello&quot;</span>) <span class="comment">// at most three calls</span></span><br><span class="line">_ * subscriber.receive(<span class="string">&quot;hello&quot;</span>)      <span class="comment">// any number of calls, including zero</span></span><br><span class="line"><span class="number">1</span> * subscriber.receive(<span class="string">&quot;hello&quot;</span>)     <span class="comment">// an argument that is equal to the String &quot;hello&quot;</span></span><br><span class="line"><span class="number">1</span> * subscriber.receive(!<span class="string">&quot;hello&quot;</span>)    <span class="comment">// an argument that is unequal to the String &quot;hello&quot;</span></span><br><span class="line"><span class="number">1</span> * subscriber.receive()            <span class="comment">// the empty argument list (would never match in our example)</span></span><br><span class="line"><span class="number">1</span> * subscriber.receive(_)           <span class="comment">// any single argument (including null)</span></span><br><span class="line"><span class="number">1</span> * subscriber.receive(*_)          <span class="comment">// any argument list (including the empty argument list)</span></span><br><span class="line"><span class="number">1</span> * subscriber.receive(!<span class="keyword">null</span>)       <span class="comment">// any non-null argument</span></span><br><span class="line"><span class="number">1</span> * subscriber.receive(_ as String) <span class="comment">// any non-null argument that is-a String</span></span><br><span class="line"><span class="number">1</span> * subscriber.receive(&#123; it.size() &gt; <span class="number">3</span> &#125;) <span class="comment">// an argument that satisfies the given predicate</span></span><br><span class="line">                                          <span class="comment">// (here: message length is greater than 3)</span></span><br><span class="line"><span class="number">1</span> * subscriber._(*_)     <span class="comment">// any method on subscriber, with any argument list</span></span><br><span class="line"><span class="number">1</span> * subscriber._         <span class="comment">// shortcut for and preferred over the above</span></span><br><span class="line"><span class="number">1</span> * _._                  <span class="comment">// any method call on any mock object</span></span><br><span class="line"><span class="number">1</span> * _                    <span class="comment">// shortcut for and preferred over the above</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Stubbing"><a href="#Stubbing" class="headerlink" title="Stubbing"></a>Stubbing</h3><p>调用 <code>Mock</code> 对象的某个方法时返回特定的值</p><ul><li><p>调用返回指定值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subscriber.receive(_) &gt;&gt; <span class="string">&quot;ok&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>调用多次返回不同的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">subscriber.receive(_) &gt;&gt;&gt; [<span class="string">&quot;ok&quot;</span>, <span class="string">&quot;error&quot;</span>, <span class="string">&quot;error&quot;</span>, <span class="string">&quot;ok&quot;</span>]</span><br><span class="line">subscriber.receive(_) &gt;&gt; <span class="string">&quot;ok&quot;</span> &gt;&gt; <span class="string">&quot;error&quot;</span> &gt;&gt; <span class="string">&quot;error&quot;</span> &gt;&gt; <span class="string">&quot;ok&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>希望抛出异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subscriber.receive(_) &gt;&gt; &#123; <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">&quot;ouch&quot;</span>) &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Mock、Stubbing结合"><a href="#Mock、Stubbing结合" class="headerlink" title="Mock、Stubbing结合"></a>Mock、Stubbing结合</h3><p>如果既要判断某个 <code>mock</code> 对象的交互，又希望它返回值的话，可以结合 <code>mock</code> 和 <code>stub</code>，可以这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">then:</span><br><span class="line"><span class="number">1</span> * subscriber.receive(<span class="string">&quot;message1&quot;</span>) &gt;&gt; <span class="string">&quot;ok&quot;</span></span><br><span class="line"><span class="number">1</span> * subscriber.receive(<span class="string">&quot;message2&quot;</span>) &gt;&gt; <span class="string">&quot;fail&quot;</span></span><br></pre></td></tr></table></figure><p>一般使用 <code>Spock</code> 自带的 <code>Mock</code> 就够了，但是 <code>Spock</code> 的 <code>Mock</code> 也有着常见缺陷，既不能 <code>Mock</code> 私有方法和静态方法</p><p>针对这种情况，业界之前常见的是使用 <code>PowerMock</code> 来 <code>Mock</code>，但是 <code>PowerMock</code> 上手难度较高、且使用复杂</p><p>相比 <code>Spock</code> + <code>PowerMock</code>，推荐 <code>Spock</code> + <code>TestableMock</code> 来 <code>Mock</code>，快速上手、使用简单</p><h2 id="TestableMock"><a href="#TestableMock" class="headerlink" title="TestableMock"></a>TestableMock</h2><p><code>TestableMock</code>，阿里新一代测试工具，一款特立独行的轻量Mock工具。</p><p>官网：<a href="https://alibaba.github.io/testable-mock/#/">https://alibaba.github.io/testable-mock/#/</a></p><p>常见 Mock 工具对比：</p><table><thead><tr><th>工具</th><th>原理</th><th>最小Mock单元</th><th>对被Mock方法的限制</th><th>上手难度</th><th>IDE支持</th></tr></thead><tbody><tr><td>Mockito</td><td>动态代理</td><td>类</td><td>不能Mock私有/静态和构造方法</td><td>较容易</td><td>很好</td></tr><tr><td>Spock</td><td>动态代理</td><td>类</td><td>不能Mock私有/静态和构造方法</td><td>较复杂</td><td>一般</td></tr><tr><td>PowerMock</td><td>自定义类加载器</td><td>类</td><td>任何方法皆可</td><td>较复杂</td><td>较好</td></tr><tr><td>JMockit</td><td>运行时字节码修改</td><td>类</td><td>不能Mock构造方法(new操作符)</td><td>较复杂</td><td>一般</td></tr><tr><td>TestableMock</td><td>运行时字节码修改</td><td>方法</td><td>任何方法皆可</td><td>很容易</td><td>一般</td></tr></tbody></table><p>TestableMock 功能：</p><ul><li><a href="https://alibaba.github.io/testable-mock/#/zh-cn/doc/use-mock">快速Mock任意调用</a>：使被测类的任意方法调用快速替换为Mock方法，实现”指哪换哪”，解决传统Mock工具使用繁琐的问题</li><li><a href="https://alibaba.github.io/testable-mock/#/zh-cn/doc/private-accessor">访问被测类私有成员</a>：使单元测试能直接调用和访问被测类的私有成员，解决私有成员初始化和私有方法测试的问题</li><li><a href="https://alibaba.github.io/testable-mock/#/zh-cn/doc/omni-constructor">快速构造参数对象</a>：生成任意复杂嵌套的对象实例，并简化其内部成员赋值方式，解决被测方法参数初始化代码冗长的问题</li><li><a href="https://alibaba.github.io/testable-mock/#/zh-cn/doc/test-void-method">辅助测试void方法</a>：利用Mock校验器对方法的内部逻辑进行检查，解决无返回值方法难以实施单元测试的问题</li></ul><p>不足：</p><p>当前 <code>TestableMock</code> 的主要不足在于，编写 <code>Mock</code> 方法时 IDE 无法即时提示方法参数是否正确匹配。若发现匹配效果不符合预期，需要通过<a href="https://alibaba.github.io/testable-mock/#/zh-cn/doc/troubleshooting">自助问题排查</a>文档提供的方法在运行期进行校验</p><h1 id="推荐文档"><a href="#推荐文档" class="headerlink" title="推荐文档"></a>推荐文档</h1><ul><li><p>官方文档<br><a href="https://spockframework.org/spock/docs/2.0/all_in_one.html">https://spockframework.org/spock/docs/2.0/all_in_one.html</a></p></li><li><p>美团技术博客<br><a href="https://tech.meituan.com/2021/08/06/spock-practice-in-meituan.html">https://tech.meituan.com/2021/08/06/spock-practice-in-meituan.html</a></p></li><li><p>其他技术博客<br><a href="https://javakk.com/category/spock">https://javakk.com/category/spock</a></p></li><li><p>Java Testing with Spock<br><a href="https://github.com/kkapelon/java-testing-with-spock">https://github.com/kkapelon/java-testing-with-spock</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;单元测试的重要性不言而喻，但在实际开发中单元测试往往都是缺失的，原因有很多，其中比较重要的一点是工期短、写单测耗时长&lt;/p&gt;
&lt;p&gt;针对这种</summary>
      
    
    
    
    <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Code Review</title>
    <link href="http://yoursite.com/2021/06/19/Code%20Review/"/>
    <id>http://yoursite.com/2021/06/19/Code%20Review/</id>
    <published>2021-06-19T03:22:37.000Z</published>
    <updated>2021-11-06T06:03:09.657Z</updated>
    
    <content type="html"><![CDATA[<h2 id="认识-Code-Review"><a href="#认识-Code-Review" class="headerlink" title="认识 Code Review"></a>认识 Code Review</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>Code Review是一种用来确认方案设计和代码实现的质量保证机制，通过这个机制对代码、测试过程和注释进行检查，确保整体代码运行状况随着时间的推移而得到改善。</p><h3 id="目的和意义"><a href="#目的和意义" class="headerlink" title="目的和意义"></a>目的和意义</h3><ul><li>目的：代码质量、知识共享、团队规范</li><li>意义：<ul><li>查找系统和代码的缺陷，把控风险</li><li>保证代码整体健康度不会随时间的推移而降低</li><li>提高开发者自身水平</li></ul></li></ul><h3 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h3><p>常见的 Code Review 有下面几种方式</p><blockquote><p>结对编程(瞬时评审)</p></blockquote><ul><li>一对一的共同编程</li><li>场景：复杂的业务问题、或紧急问题的修复</li></ul><blockquote><p>即时代码评审(同步评审)</p></blockquote><ul><li>提交人给审核人讲解任务详情、改动等</li><li>场景：不清楚任务目标、或高级指导低级</li></ul><blockquote><p>工具支持的代码评审(异步评审)</p></blockquote><ul><li>和开发流集成，只有 Review 通过才能合并</li><li>默认的方式，也是最常用的</li></ul><blockquote><p>基于会议的代码评审(偶尔评审)</p></blockquote><ul><li>组织会议，团队多人共同评审</li><li>场景：大型、比较复杂的项目；有一定风险的项目；为了提高整体水平</li></ul><h3 id="不做-Code-Review-的典型场景"><a href="#不做-Code-Review-的典型场景" class="headerlink" title="不做 Code Review 的典型场景"></a>不做 Code Review 的典型场景</h3><ul><li>不认同，团队整体意识不到位</li><li>需求多，时间紧，疲于应付需求</li><li>技术水平不足，无法给出有效意见</li></ul><h3 id="Code-Review-常见问题"><a href="#Code-Review-常见问题" class="headerlink" title="Code Review 常见问题"></a>Code Review 常见问题</h3><blockquote><p>提交人</p></blockquote><ul><li>提交大量代码评审</li><li>发起评审前没有进行自测</li><li>不进行评审，直接上线</li><li>没有给评审人留够充裕的时间</li></ul><blockquote><p>评审人</p></blockquote><ul><li>Review 不仔细，产生低级的问题</li><li>对业务不熟悉，无法判断影响面</li><li>反馈时机长，不及时处理提交人提交的 Code Review</li></ul><blockquote><p>全体</p></blockquote><ul><li>没有规范的 Code Review 机制和自测机制</li></ul><h2 id="如何做好-Code-Review"><a href="#如何做好-Code-Review" class="headerlink" title="如何做好 Code Review"></a>如何做好 Code Review</h2><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>要避免 Code Review 流于形式，而避免流于形式的关键点则是 <strong>大家都有主观意愿，并且客观条件允许</strong></p><p>要有代码规范、Check list、总结优化、激励机制</p><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+-------+      +---------+      +---------+      +---------+      +-----+      +------------+</span><br><span class="line">| 定标准 | +--&gt; | 全员学习 | +--&gt; | 需求梳理  | +--&gt; | 代码评审 | +--&gt; | 讨论 | +--&gt; | 评审结果落地 |</span><br><span class="line">+-------+      +---------+      +---------+      +---------+      +-----+      +------------+ </span><br></pre></td></tr></table></figure><ol><li>定标准<ul><li>目的：有法可依、团队一致</li><li>内容：<ul><li>共识标准：权利责任标准、冲突处理标准、特例紧急case处理标准、检查单标准</li><li>提交人标准：发起时机标准、选择评审人标准、Commit 标准、代码标准、合并分支标准、处理评论标准</li><li>评审人标准：检查内容标准、可通过标准、评论标准、反馈周期标准</li></ul></li></ul></li><li>全员学习<ul><li>目的：统一思想、确认标准可落地</li></ul></li><li>需求梳理<ul><li>统一对需求理解，设计评审有理可依</li><li>内容：<ul><li>提交人要有基于需求的代码改动设计方案</li><li>评审人要有基于需求理解之下的代码改造意见</li></ul></li></ul></li><li>代码评审<ul><li>目的：实现正确的业务需求，代码长期的可维护性</li><li>内容：参照检查单（功能拆解；架构设计；代码逻辑；库表设计；编码风格；性能；等等）</li><li>工具：<a href="http://www.sonar.org.cn/">Sonar</a>、<a href="https://www.gerritcodereview.com/">Gerrit</a> 等工具</li></ul></li><li>讨论<ul><li>目的：达成共识，求同存异</li></ul></li><li>评审结果落地<ul><li>总结归纳，持续优化标准</li></ul></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Code Review 是提高代码质量、把控项目风险的一剂良药，同时也是提高个人水平的一个重要渠道。而长期维持良好的 Code Review 并不容易，但是良好的 Code Review 是个人和团队成功不可或缺的一环。</p><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><p>GoogleCR机制（原文）：<a href="https://google.github.io/eng-practices/review/reviewer/">https://google.github.io/eng-practices/review/reviewer/</a></p><p>GoogleCR机制（翻译版）：<a href="https://cloud.tencent.com/developer/article/1514271">https://cloud.tencent.com/developer/article/1514271</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;认识-Code-Review&quot;&gt;&lt;a href=&quot;#认识-Code-Review&quot; class=&quot;headerlink&quot; title=&quot;认识 Code Review&quot;&gt;&lt;/a&gt;认识 Code Review&lt;/h2&gt;&lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot;</summary>
      
    
    
    
    <category term="规范" scheme="http://yoursite.com/categories/%E8%A7%84%E8%8C%83/"/>
    
    
    <category term="规范" scheme="http://yoursite.com/tags/%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>Netty-BetyBuf</title>
    <link href="http://yoursite.com/2021/06/11/Netty-BetyBuf/"/>
    <id>http://yoursite.com/2021/06/11/Netty-BetyBuf/</id>
    <published>2021-06-11T07:55:37.000Z</published>
    <updated>2021-06-21T02:17:02.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>ByteBuf 是 Netty 中的数据交互单位，本质是一个 Byte 数组的缓冲区，有不同实现机制，首先看 ByteBuf 的数据结构</p></blockquote><h3 id="ByteBuf结构"><a href="#ByteBuf结构" class="headerlink" title="ByteBuf结构"></a>ByteBuf结构</h3><pre><code>+-------------------+------------------+------------------+| discardable bytes |  readable bytes  |  writable bytes  ||                   |     (CONTENT)    |                  |+-------------------+------------------+------------------+|                   |                  |                  |0      &lt;=      readerIndex   &lt;=   writerIndex    &lt;=    capacity</code></pre><p>ByteBuf 包括三部分，丢弃字节、可读字节、可写字节</p><p>通过两个指针，读指针（readerIndex）和写指针（writerIndex）来分成三部分，当 readerIndex = writerIndex 时不可读，当 writerIndex = capacity 时不可写。还有个参数 maxCapacity，当写入数据容量不足时会自动扩容，扩容的最大容量为 maxCapacity 值</p><h3 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h3><h4 id="容量API"><a href="#容量API" class="headerlink" title="容量API"></a>容量API</h4><ul><li><p><code>capacity()</code></p><p>表示 ByteBuf 的占用字节内存，包括丢弃字节、可读字节、可写字节，不同的底层实现机制有不同的计算方式</p></li><li><p><code>maxCapacity()</code>  </p><p>表示 ByteBuf 最大能够占用多少字节的内存</p></li><li><p><code>readableBytes()</code></p><p>ByteBuf 当前可读的字节数，它的值等于 writerIndex-readerIndex</p></li><li><p><code>isReadable()</code></p><p>返回是否可读，writerIndex = readerIndex 则不可读，返回 <code>false</code></p></li><li><p><code>writableBytes()</code></p><p>ByteBuf 当前可写的字节数，它的值等于 capacity-writerIndex</p></li><li><p><code>isWritable()</code></p><p>返回是否可写，capacity = writerIndex 则不可写</p></li><li><p><code>maxWritableBytes()</code></p><p>ByteBuf 可写的最大字节数，它的值等于 maxCapacity-writerIndex</p></li></ul><h4 id="指针相关API"><a href="#指针相关API" class="headerlink" title="指针相关API"></a>指针相关API</h4><ul><li><p><code>readerIndex()</code></p><p>返回当前读指针的 readerIndex</p></li><li><p><code>readerIndex(int)</code></p><p>设置读指针</p></li><li><p><code>writeIndex()</code></p><p>返回当前写指针的 writerIndex</p></li><li><p><code>writeIndex(int)</code></p><p>设置读指针</p></li><li><p><code>markReaderIndex()</code>、<code>markWriterIndex()</code></p><p>把当前的读、写指针保存起来</p></li><li><p><code>resetReaderIndex()</code>、<code>resetWriterIndex()</code></p><p>把当前的读、写指针恢复到之前保存的值</p></li></ul><h4 id="读写API"><a href="#读写API" class="headerlink" title="读写API"></a>读写API</h4><ul><li><p><code>writeBytes(byte[] src)</code></p><p>把字节数组 src 里面的数据全部写到 ByteBuf，src 字节数组大小的长度通常小于等于 <code>writableBytes()</code></p></li><li><p><code>readBytes(byte[] dst)</code></p><p>把 ByteBuf 里面的数据全部读取到 dst，这里 dst 字节数组的大小通常等于 <code>readableBytes()</code></p></li><li><p><code>writeByte(byte b)</code></p><p>表示往 ByteBuf 中写一个字节，类似还有 <code>writeBoolean()</code>、<code>writeChar()</code>、<code>writeShort()</code>、<code>writeInt()</code>、<code>writeLong()</code>、<code>writeFloat()</code>、<code>writeDouble()</code> </p></li><li><p><code>readByte()</code></p><p>表示从 ByteBuf 中读取一个字节，类似还有  <code>readBoolean()</code>、<code>readChar()</code>、<code>readShort()</code>、<code>readInt()</code>、<code>readLong()</code>、<code>readFloat()</code>、<code>readDouble()</code></p></li><li><p><code>setBytes()</code>、<code>setByte()</code></p><p>和 <code>writeBytes()</code> 等方法类似，但是 set 不会改变读写指针，而 write 会改变写指针</p></li><li><p><code>getBytes</code>、<code>getByte()</code></p><p>和 <code>readBytes()</code> 等方法类似，同样 get 不会改变读写指针，而 read 会改变读指针</p></li><li><p><code>retain()</code></p><p>将 BetyBuf 的引用计数加一</p></li><li><p><code>release()</code></p><p>将 ByteBuf 的引用计数减一，减完之后如果发现引用计数为0，则直接回收 ByteBuf 底层的内存</p></li></ul><blockquote><p>由于 Netty 使用了堆外内存，而堆外内存是不被 jvm 直接管理的，也就是说申请到的内存无法被垃圾回收器直接回收，所以需要我们手动回收。有点类似于c语言里面，申请到的内存必须手工释放，否则会造成内存泄漏。</p><p>Netty 的 ByteBuf 是通过引用计数的方式管理的，如果一个 ByteBuf 没有地方被引用到，需要回收底层内存。默认情况下，当创建完一个 ByteBuf，它的引用为1</p></blockquote><ul><li><p><code>slice()</code></p><p>从原始 ByteBuf 中截取一段，这段数据是从 readerIndex 到 writeIndex，同时，返回的新的 ByteBuf 的最大容量 maxCapacity 为原始 ByteBuf 的 <code>readableBytes()</code>；底层内存以及引用计数与原始的 ByteBuf 共享</p></li><li><p><code>duplicate()</code></p><p>把整个 ByteBuf 都截取出来，包括所有的指针信息。底层内存以及引用计数与原始的 ByteBuf 共享</p></li><li><p><code>copy()</code></p><p>从原始的 ByteBuf 中拷贝所有的信息，包括读写指针以及底层对应的数据，底层内存以及引用计数都独立，操作 ByteBuf 中的数据不会影响到原始的 ByteBuf </p></li></ul><blockquote><p>三个方法都会返回新的 ByteBuf 对象</p><p><code>slice()</code> 与 <code>duplicate()</code> 的相同点是：<strong>底层内存以及引用计数与原始的 ByteBuf 共享</strong>，也就是说经过 <code>slice()</code> 或者 <code>duplicate()</code> 返回的 ByteBuf 调用 write 系列方法都会影响到原始的 ByteBuf，但是它们都维持着与原始 ByteBuf 相同的内存引用计数和不同的读写指针 </p><p><code>slice()</code> 与 <code>duplicate()</code> 的不同点是：<code>slice()</code> 只截取从 readerIndex 到 writerIndex 之间的数据，它返回的 ByteBuf 的最大容量被限制到 原始 ByteBuf 的 <code>readableBytes()</code>, 而 <code>duplicate()</code> 是把整个 ByteBuf 都与原始的 ByteBuf 共享 </p><p><code>slice()</code> 和 <code>duplicate()</code> 不会改变 ByteBuf 的引用计数，所以原始的 ByteBuf 调用 <code>release()</code> 之后发现引用计数为零，就开始释放内存，调用这两个方法返回的 ByteBuf 也会被释放，这个时候如果再对它们进行读写，就会报错。因此，我们可以通过调用一次 <code>retain()</code> 方法 来增加引用，表示它们对应的底层的内存多了一次引用，引用计数为2，在释放内存的时候，需要调用两次 <code>release()</code> 方法，将引用计数降到零，才会释放内存</p><p><code>slice()</code> 、<code>duplicate()</code>、<code>copy()</code> 三个方法均维护着自己的读写指针，与原始的 ByteBuf 的读写指针无关，相互之间不受影响</p></blockquote><ul><li><p><code>retainedSlice()</code></p><p>截取内存片段的同时，增加内存的引用计数，等价于 <code>slice().retain()</code></p></li><li><p><code>retainedDuplicate()</code></p><p>也是截取内存片段的同时，增加内存的引用计数，等价于 <code>duplicate().retain()</code></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;ByteBuf 是 Netty 中的数据交互单位，本质是一个 Byte 数组的缓冲区，有不同实现机制，首先看 ByteBuf 的数据结构&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;ByteBuf结构&quot;&gt;&lt;a href=&quot;#ByteBuf结</summary>
      
    
    
    
    <category term="Netty" scheme="http://yoursite.com/categories/Netty/"/>
    
    
    <category term="Netty" scheme="http://yoursite.com/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot自动配置</title>
    <link href="http://yoursite.com/2021/06/04/SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2021/06/04/SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/</id>
    <published>2021-06-04T07:20:28.000Z</published>
    <updated>2021-06-06T11:38:59.292Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>SpringBoot的一个很重要的特性就是自动配置，使用注解，让服务不再需要xml等各种配置文件<br>然后使用main方法一键启动</p></blockquote><h2 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h2><p><code>@SpringBootApplication</code> 注解是 SpringBoot 的源头，一切都要从该注解开始说起</p><p>标注在类上时，表示该类是 SpringBoot 的主配置类，并从该类中的 <code>main</code> 方法来启动 SpringBoot 应用</p><p>注解源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(excludeFilters = &#123;</span></span><br><span class="line"><span class="meta">@Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span></span><br><span class="line"><span class="meta">@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br></pre></td></tr></table></figure><p>可以看出主要包含了三个注解：</p><ul><li><code>@SpringBootConfiguration</code></li><li><code>@ComponentScan</code></li><li><code>@EnableAutoConfiguration</code></li></ul><h3 id="SpringBootConfiguration"><a href="#SpringBootConfiguration" class="headerlink" title="@SpringBootConfiguration"></a>@SpringBootConfiguration</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootConfiguration &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看 <code>@SpringBootConfiguration</code> 的源码发现其实就是一个 <code>@Configuration</code> 注解，表示这是一个 SpringBoot 的配置类</p><h3 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h3><p><code>@ComponentScan</code> 表示开启组件扫描</p><p>默认是扫描<strong>当前类</strong>下的package。将 <code>@Controller/@Service/@Component/@Repository</code> 等注解加载到IOC容器中</p><h3 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h3><p><code>@EnableAutoConfiguration</code> 表示开启自动配置，SpringBoot 自动配置的原理都在这个注解中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(AutoConfigurationImportSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br></pre></td></tr></table></figure><p><code>@EnableAutoConfiguration</code> 又主要包含 <code>@Import</code>、<code>@AutoConfigurationPackage</code> 俩个注解，先看下重点 <code>@Import</code> 这个注解</p><h4 id="Import"><a href="#Import" class="headerlink" title="@Import"></a>@Import</h4><p><code>@Import</code> 注解是用来导入配置类或者一些需要前置加载的类，可以将多个配置类融合成一个配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Import &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Configuration&#125;, &#123;<span class="doctag">@link</span> ImportSelector&#125;, &#123;<span class="doctag">@link</span> ImportBeanDefinitionRegistrar&#125;</span></span><br><span class="line"><span class="comment"> * or regular component classes to import.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Class&lt;?&gt;[] value();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看代码可以看出，有三种使用方式：</p><ul><li>导入普通 Java 类，导入的类会被加载为 Bean</li><li>导入 <code>ImportSelector</code> 接口实现</li><li>导入 <code>ImportBeanDefinitionRegistrar</code> 接口实现</li></ul><ol><li><p>ImportSelector</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Select and return the names of which class(es) should be imported based on</span></span><br><span class="line"><span class="comment">* the &#123;<span class="doctag">@link</span> AnnotationMetadata&#125; of the importing @&#123;<span class="doctag">@link</span> Configuration&#125; class.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">String[] selectImports(AnnotationMetadata importingClassMetadata);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 接口中只有一个 <code>selectImports</code> 方法，用于返回全类名数组，会把返回数组中的类全部导入</p></li><li><p>ImportBeanDefinitionRegistrar</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Register bean definitions as necessary based on the given annotation metadata of</span></span><br><span class="line"><span class="comment">* the importing &#123;<span class="doctag">@code</span> <span class="doctag">@Configuration</span>&#125; class.</span></span><br><span class="line"><span class="comment">* &lt;p&gt;Note that &#123;<span class="doctag">@link</span> BeanDefinitionRegistryPostProcessor&#125; types may &lt;em&gt;not&lt;/em&gt; be</span></span><br><span class="line"><span class="comment">* registered here, due to lifecycle constraints related to &#123;<span class="doctag">@code</span> <span class="doctag">@Configuration</span>&#125;</span></span><br><span class="line"><span class="comment">* class processing.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> importingClassMetadata annotation metadata of the importing class</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> registry current bean definition registry</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>registerBeanDefinitions</code> 它可以手动注册bean到容器中</p></li></ol><h4 id="AutoConfigurationImportSelector-class"><a href="#AutoConfigurationImportSelector-class" class="headerlink" title="AutoConfigurationImportSelector.class"></a>AutoConfigurationImportSelector.class</h4><p><code>AutoConfigurationImportSelector.class</code> 类实现了 <code>ImportSelector</code> 接口，其中的核心方法是 <code>selectImports</code>，来返回需要导入的组件的全类名数组</p><ul><li><p><code>selectImports</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line"><span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line"><span class="keyword">return</span> NO_IMPORTS;</span><br><span class="line">&#125;</span><br><span class="line">AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader</span><br><span class="line">.loadMetadata(<span class="keyword">this</span>.beanClassLoader);</span><br><span class="line">AnnotationAttributes attributes = getAttributes(annotationMetadata);</span><br><span class="line"><span class="comment">//获取全类名数组</span></span><br><span class="line">List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata,</span><br><span class="line">attributes);</span><br><span class="line">configurations = removeDuplicates(configurations);</span><br><span class="line">Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);</span><br><span class="line">checkExcludedClasses(configurations, exclusions);</span><br><span class="line">configurations.removeAll(exclusions);</span><br><span class="line">configurations = filter(configurations, autoConfigurationMetadata);</span><br><span class="line">fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line"><span class="keyword">return</span> StringUtils.toStringArray(configurations);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>getCandidateConfigurations</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata,</span></span></span><br><span class="line"><span class="function"><span class="params">AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line"><span class="comment">//获取EnableAutoConfiguration.class对应的全类名数组</span></span><br><span class="line">List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(</span><br><span class="line">getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader());</span><br><span class="line">Assert.notEmpty(configurations,</span><br><span class="line"><span class="string">&quot;No auto configuration classes found in META-INF/spring.factories. If you &quot;</span></span><br><span class="line">+ <span class="string">&quot;are using a custom packaging, make sure that file is correct.&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> configurations;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; getSpringFactoriesLoaderFactoryClass() &#123;</span><br><span class="line"><span class="keyword">return</span> EnableAutoConfiguration.class;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>loadFactoryNames</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">loadFactoryNames</span><span class="params">(Class&lt;?&gt; factoryClass, <span class="meta">@Nullable</span> ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">String factoryClassName = factoryClass.getName();</span><br><span class="line"><span class="comment">//返回 META-INF/spring.factories 文件下 EnableAutoConfiguration.class 对应的所有值</span></span><br><span class="line"><span class="keyword">return</span> loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>loadSpringFactories</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从当前项目的类路径中获取所有 META-INF/spring.factories 这个文件下的信息。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(<span class="meta">@Nullable</span> ClassLoader classLoader) &#123;</span><br><span class="line">MultiValueMap&lt;String, String&gt; result = cache.get(classLoader);</span><br><span class="line"><span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//FACTORIES_RESOURCE_LOCATION:META-INF/spring.factories</span></span><br><span class="line">Enumeration&lt;URL&gt; urls = (classLoader != <span class="keyword">null</span> ?</span><br><span class="line">classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :</span><br><span class="line">ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));</span><br><span class="line">result = <span class="keyword">new</span> LinkedMultiValueMap&lt;&gt;();</span><br><span class="line"><span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">URL url = urls.nextElement();</span><br><span class="line">UrlResource resource = <span class="keyword">new</span> UrlResource(url);</span><br><span class="line">Properties properties = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">String factoryClassName = ((String) entry.getKey()).trim();</span><br><span class="line"><span class="keyword">for</span> (String factoryName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) &#123;</span><br><span class="line">result.add(factoryClassName, factoryName.trim());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cache.put(classLoader, result);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Unable to load factories from location [&quot;</span> +</span><br><span class="line">FACTORIES_RESOURCE_LOCATION + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="META-INF-spring-factories"><a href="#META-INF-spring-factories" class="headerlink" title="META-INF/spring.factories"></a>META-INF/spring.factories</h4><p><code>META-INF/spring.factories</code> 在很多第三方依赖中都会有这个文件，第三方依赖通过这个文件并配置 <code>EnableAutoConfiguration</code> 参数，然后自动配置会把这个参数下面的所有类都配置到 Spring 容器中，如图</p><p><img src="/images/SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE0.jpg" alt="image"></p><h4 id="AutoConfigurationPackage"><a href="#AutoConfigurationPackage" class="headerlink" title="@AutoConfigurationPackage"></a>@AutoConfigurationPackage</h4><p><code>@EnableAutoConfiguration</code> 注解中的另一个注解 <code>@AutoConfigurationPackage</code>，是用来自动配置包的，将主配置类 <code>@SpringBootConfiguration</code> 标注的类，所在包及下面所有子包里面的所有组件扫描到 Spring 容器中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Import(AutoConfigurationPackages.Registrar.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AutoConfigurationPackage &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>AutoConfigurationPackage</code> 注解依然使用了 <code>import</code> 注解，不过使用的是 <code>ImportBeanDefinitionRegistrar</code> 接口实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Registrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span>, <span class="title">DeterminableImports</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="comment">//把所在包及其子包里边的组件扫描注册到Spring容器中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata,</span></span></span><br><span class="line"><span class="function"><span class="params">BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">register(registry, <span class="keyword">new</span> PackageImport(metadata).getPackageName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;Object&gt; <span class="title">determineImports</span><span class="params">(AnnotationMetadata metadata)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> Collections.singleton(<span class="keyword">new</span> PackageImport(metadata));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p> SpringBoot的自动装配是由 <code>@EnableAutoConfiguration</code> 注解来实现的，而 <code>@EnableAutoConfiguration</code> 注解又是通过 <code>@AutoConfigurationPackage</code> 和 <code>@Import(AutoConfigurationImportSelector.class)</code> 来实现服务自身的自动配置和第三方依赖的自动配置</p><p>注解关系如图：</p><p> <img src="/images/SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE1.png" alt="image"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;SpringBoot的一个很重要的特性就是自动配置，使用注解，让服务不再需要xml等各种配置文件&lt;br&gt;然后使用main方法一键启动&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;SpringBootApplication&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
    <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Web fragments</title>
    <link href="http://yoursite.com/2021/02/19/Web%20fragments/"/>
    <id>http://yoursite.com/2021/02/19/Web%20fragments/</id>
    <published>2021-02-19T10:23:07.000Z</published>
    <updated>2021-02-19T11:28:12.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p><code>Web fragments</code>是<code>servlet 3.0</code>开始支持的一个特性(可插性支持)，通过插件的方式很方便的扩充已有<code>Web</code>应用的功能，而不需要修改原有的应用</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><blockquote><p>Servlet 3.0 的部署描述文件 web.xml 的顶层标签 有一个 metadata-complete 属性，该属性指定当前的部署描述文件是否是完全的。如果设置为 true，则容器在部署时将只依赖部署描述文件，忽略所有的注解（同时也会跳过 web-fragment.xml 的扫描，亦即禁用可插性支持，具体请看后文关于 <a href="https://www.ibm.com/developerworks/cn/java/j-lo-servlet30/#major4">可插性支持</a> 的讲解）；如果不配置该属性，或者将其设置为 false，则表示启用注解支持（和可插性支持）。</p></blockquote><h3 id="Web-fragments语法和规则"><a href="#Web-fragments语法和规则" class="headerlink" title="Web fragments语法和规则"></a>Web fragments语法和规则</h3><ol><li><code>Web fragments</code> 需要有 <code>web-fragment.xml</code> 的部署描述文件，该文件必须存放在 <code>JAR</code> 文件的 <code>META-INF</code> 目录下，该部署描述文件可以包含一切可以在 <code>web.xml</code> 中定义的内容(过滤器、监听器与<code>Servlet</code>)</li><li>包含 <code>web-fragment.xml</code> 的 <code>JAR</code> 应该部署到 <code>Web</code> 应用程序的 <code>WEBINF/lib</code> 目录中</li><li><code>web-fragment.xml</code> 的根元素是 <code>&lt;web-fragment&gt;</code>，它可以包含 <code>DD(web.xml)</code> 中 <code>&lt;web-app&gt;</code> 元素的任何子元素。</li><li>每个 <code>web-fragment.xml</code> 都可以包含一个 <code>name</code> 元素。<code>name</code> 元素在所有 <code>Web</code> 片段中应该是唯一的，并且不应有任何循环引用或循环，否则容器将因有意义的错误中止应用程序部署。该名称将用于 <code>Web</code> 片段的任何排序。</li><li>可以使用元素 <code>&lt;absolute-ordering&gt;</code> 从 <code>web.xml</code> 中指定 <code>Web</code> 片段的顺序。也可以使用元素 <code>&lt;ordering&gt;</code> 从 <code>Web</code> 片段本身内部指定 <code>Web</code> 片段的顺序。在 <code>web.xml</code> 或 <code>Web</code> 片段中，元素按照声明的顺序加载。</li><li>并且如果 <code>web-fragment.xml</code> 和 <code>web.xml</code> 之间存在冲突，则 <code>web.xml</code> 将具有优先权。但是，如果两个片段之间存在冲突，则会引发错误。</li></ol><h3 id="配置内容"><a href="#配置内容" class="headerlink" title="配置内容"></a>配置内容</h3><blockquote><p>servlet、filter、listener三个可以定义任何一个，也可以全部定义</p></blockquote><ul><li><p>web-fragment.xml:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-fragment</span> <span class="attr">id</span>=<span class="string">&quot;WebFragment_ID&quot;</span> <span class="attr">version</span>=<span class="string">&quot;3.1&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-fragment_3_1.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Test<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- servlet --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>servletTest<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.xxx.xxx.servlets.ServletTest<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>servletTest<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- filter --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filterTest<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.xxx.xxx.FilterTest<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">async-supported</span>&gt;</span>true<span class="tag">&lt;/<span class="name">async-supported</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filterTest<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- listener --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>com.xxx.xxx.ListenerTest<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ordering</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 表示在项目所有之前进行初始化 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">before</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">others</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">before</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 表示在项目所有之后进行初始化 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">after</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">others</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">after</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ordering</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">web-fragment</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>Servlet:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletTest</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.service(req, resp);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.destroy();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Filter:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.Filter;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.FilterChain;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.FilterConfig;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterTest</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Listener:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.ServletRequestEvent;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletRequestListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListenerTest</span> <span class="keyword">implements</span> <span class="title">ServletRequestListener</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestDestroyed</span><span class="params">(ServletRequestEvent servletRequestEvent)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestInitialized</span><span class="params">(ServletRequestEvent servletRequestEvent)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Web fragments&lt;/code&gt;是&lt;code&gt;servlet 3.0&lt;/code&gt;开始支持的一个特性(可插性支持)，通过</summary>
      
    
    
    
    <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>服务缓存优化</title>
    <link href="http://yoursite.com/2021/02/03/%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2021/02/03/%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%96/</id>
    <published>2021-02-03T08:36:35.000Z</published>
    <updated>2021-03-04T09:22:10.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="服务介绍"><a href="#服务介绍" class="headerlink" title="服务介绍"></a>服务介绍</h3><p><code>bizconf</code>服务是公司所有业务的通用配置服务，用来保存所有企业、以及用户的业务配置。分为三个级别的配置，系统级、租户级和用户级。</p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>之前就有发现<code>bizconf</code>调用量比较大，需要优化缓存来降低调用，而最初现状是只在<code>server</code>端有<code>Redis</code>缓存</p><p>问题爆发点：元旦前最后几天，数据库负载高，导致<code>bizconf</code>服务调用耗时从几毫米升高到 20~30 毫秒，这时客户反馈系统库卡顿、反应慢，经过排查发现调用耗时长的请求和<code>bizconf</code>耗时曲线一致，各个业务都用调用<code>bizconf</code>，还有的业务调用多次，<code>bizconf</code>耗时上涨导致整个系统卡顿</p><h3 id="优化目标"><a href="#优化目标" class="headerlink" title="优化目标"></a>优化目标</h3><p>在<code>client</code>添加<code>jvm cahce</code>来降低调用，从而做到服务降级，前后共经过俩次优化，第一次优化因为缓存穿透的原因效果不明显，第二次优化后效果显著</p><p>优化前调用量：<br><img src="/images/%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%960.png"></p><h3 id="第一次优化"><a href="#第一次优化" class="headerlink" title="第一次优化"></a>第一次优化</h3><p>优化范围：在<code>server</code>和<code>client</code>中添加<code>jvm cache</code></p><p>使用缓存：使用<code>caffeine cache</code>，分级缓存，在<code>server</code>和<code>client</code>中分别添加两个<code>cache</code>，企业级和用户级的<code>cache</code></p><p>缓存设置：</p><ul><li>size：<code>server</code>中<code>cache size</code>为50000，<code>client</code>中<code>cache size</code>为5000，</li><li>过期时间：一个小时</li><li>过期策略：<code>expireAfterAccess(long, TimeUnit)</code>按最后访问时间计时</li><li>基于引用：<code>softValues()</code>设置为软引用</li></ul><p>优化后观察：<br>观察发现虽然添加了<code>jvm cache</code>，但是调用量降低的效果不明显，甚至可以说无效果</p><p>又观察<code>Redis</code>调用量和<code>db</code>调用量，发现<code>db</code>调用量和<code>Redis</code>调用量差不多，少的很有限，这时觉得这种情况不对，怀疑发生了缓存穿透，缓存没有生效</p><p><code>Redis</code>和<code>db</code>调用量：<br><img src="/images/%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%961.png"></p><p>经过排查发现一些数据多次的访问数据库，询问对应业务，是在判断企业的某些状态，如果返回<code>false</code>或不存在则认为没有，至此问题定位，缓存穿透导致大量访问数据库，从而解释了为什么优化的效果不明显</p><p>针对缓存穿透有了下面的第二次的优化</p><h3 id="第二次优化"><a href="#第二次优化" class="headerlink" title="第二次优化"></a>第二次优化</h3><p>针对缓存穿透一般有两种处理方式：使用布隆过滤器和缓存空值</p><h4 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h4><p>布隆过滤器具体可以参考<a href="https://blog.csdn.net/yuanlong122716/article/details/104402602">https://blog.csdn.net/yuanlong122716/article/details/104402602</a></p><p>布隆过滤器有两个非常重要的缺点：</p><ol><li>存在误算率，虽然不会错判但是会误判，什么意思呢，返回不存在则一定不存在，返回存在但是并不能判断一定存在</li><li>不可以删除</li></ol><p>如果使用布隆过滤器则有两个场景，保存白名单和黑名单：</p><ul><li>白名单：如果保存白名单，需要把数据库中所有的数据(表示存在的逻辑true)都保存起来，并且新增时需要同步的维护布隆过滤器数据，但因为是分布式服务需要保证所有服务都同步的维护布隆过滤器，难度比较大；同时布隆过滤器不支持删除，所以不考虑使用白名单</li><li>黑名单：如果保存黑名单，把不存在的数据保存起来，但因为会有误判，可能会把存在的数据认为不存在从而返回了空，从而使数据错误，所以不可取</li></ul><p>分析考虑，不采用布隆过滤器，采用缓存空值的方法更为有效和简单</p><h4 id="缓存空值"><a href="#缓存空值" class="headerlink" title="缓存空值"></a>缓存空值</h4><p>优化目标：<br><img src="/images/fs-paas-bizconf%E9%87%8D%E6%9E%84.png"></p><p>优化范围：在<code>client</code>中添加<code>jvm cache</code>，在<code>server</code>中只使用<code>Redis cache</code></p><p>使用缓存：第一次优化时<code>client</code>端缓存的数据有限，这次决定使用<code>ehcache</code>，可以缓存更大的数据量，同样也是分级缓存</p><p>缓存设置：</p><ul><li>size：每个<code>cache</code>堆内存5000条、堆外内存1MB、磁盘50MB</li><li>过期时间：<code>client</code>的<code>jvm cache</code>5小时；<code>server</code>的<code>redis</code>存在的数据24小时，不存在的空值半小时(防止大量不存在的数据把<code>Redis</code>搞崩，还可以更短一些)</li><li>过期策略：<code>ExpiryPolicyBuilder.timeToLiveExpiration(Duration timeToLive)</code> 按创建时间计时</li></ul><p>优化后观察：<br>这次优化后效果显著，调用量就下降了90%，预计所有业务方改完后调用量还会进一步下降</p><p>优化前后对比：<br><img src="/images/%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%962.png"></p><h3 id="审计日志优化"><a href="#审计日志优化" class="headerlink" title="审计日志优化"></a>审计日志优化</h3><p>优化缓存的同时，增加了审计日志，可以用来分析业务方的不合理调用</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;服务介绍&quot;&gt;&lt;a href=&quot;#服务介绍&quot; class=&quot;headerlink&quot; title=&quot;服务介绍&quot;&gt;&lt;/a&gt;服务介绍&lt;/h3&gt;&lt;p&gt;&lt;code&gt;bizconf&lt;/code&gt;服务是公司所有业务的通用配置服务，用来保存所有企业、以及用户的业务配置。分为三个级别</summary>
      
    
    
    
    <category term="优化" scheme="http://yoursite.com/categories/%E4%BC%98%E5%8C%96/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
    <category term="Cache" scheme="http://yoursite.com/tags/Cache/"/>
    
    <category term="优化" scheme="http://yoursite.com/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>服务日志优化</title>
    <link href="http://yoursite.com/2021/01/04/%E6%9C%8D%E5%8A%A1%E6%97%A5%E5%BF%97%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2021/01/04/%E6%9C%8D%E5%8A%A1%E6%97%A5%E5%BF%97%E4%BC%98%E5%8C%96/</id>
    <published>2021-01-04T09:20:59.000Z</published>
    <updated>2021-03-04T10:10:56.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><blockquote><p>功能权限服务之前经手的人比较多，不同人日志打印比较乱，并且服务日志打印量很大，但当需要排查问题时，大日志量 <code>grep</code> 困难、关键信息打印不全或没有打印等问题很痛苦，决定对日志方面进行统一的优化</p></blockquote><h3 id="优化目标"><a href="#优化目标" class="headerlink" title="优化目标"></a>优化目标</h3><ol><li>对服务日志量大、关键信息不全、代码中侵入式打印日志乱等问题进行优化</li><li>人员角色模块，经常有用户、业务不知道什么时候人员角色发生了变化，针对这个模块增加审计日志，便于观察分析调用、排查问题，给出证据</li><li>日志上报日志中心，使得服务发布后日志不丢失</li></ol><h3 id="优化记录"><a href="#优化记录" class="headerlink" title="优化记录"></a>优化记录</h3><h4 id="服务日志优化"><a href="#服务日志优化" class="headerlink" title="服务日志优化"></a>服务日志优化</h4><ul><li><p>日志级别<br><img src="/images/%E6%9C%8D%E5%8A%A1%E6%97%A5%E5%BF%97%E4%BC%98%E5%8C%960.png"></p></li><li><p>日志内容<br><code>traceId</code>，方法名，方法调用链路，每个方法耗时，入参，出参，异常堆栈</p></li><li><p>相关类<br>使用 <code>Spring AOP</code>、<code>ThreadLocal</code>、<code>Spring StopWatch</code>、<code>Annotation</code> 注解<br>支持两种日志打印方式，<code>AOP</code> 打印和手动调用<br><img src="/images/%E6%9C%8D%E5%8A%A1%E6%97%A5%E5%BF%97%E4%BC%98%E5%8C%961.png"></p></li><li><p>使用方式  </p></li></ul><ol><li>新建切面类，继承 <code>TraceLogAop</code> 抽象类</li><li>编写切点，使用环绕通知，切在需要打印日志的地方</li><li>通知中调用父类的 <code>around</code> 方法，传入 <code>ProceedingJoinPoint</code> 和打印耗时日志阈值</li><li>如需要特殊处理异常，则重写 <code>exceptionHandler</code> 方法<br><img src="/images/%E6%9C%8D%E5%8A%A1%E6%97%A5%E5%BF%97%E4%BC%98%E5%8C%962.png"></li><li>在需要打印 <code>info</code> 日志的方法上添加 <code>@InOutLog(&quot;info&quot;)</code> 注解，<code>debug</code> 级别不用添加，默认就是 <code>debug</code> 级别<br><img src="/images/%E6%9C%8D%E5%8A%A1%E6%97%A5%E5%BF%97%E4%BC%98%E5%8C%963.png"></li><li>也可以修改 <code>logback.xml</code> 文件，添加一个 <code>logger</code> 把日志打印到独立的文件中<br><img src="/images/%E6%9C%8D%E5%8A%A1%E6%97%A5%E5%BF%97%E4%BC%98%E5%8C%964.png"></li></ol><ul><li>优化效果<br>入参、出参效果<br><img src="/images/%E6%9C%8D%E5%8A%A1%E6%97%A5%E5%BF%97%E4%BC%98%E5%8C%965.jpg"><br>方法调用链路、耗时效果<br><img src="/images/%E6%9C%8D%E5%8A%A1%E6%97%A5%E5%BF%97%E4%BC%98%E5%8C%966.jpg"><br>根据详细的入参、出参可以快速、准确的排查问题；根据调用链路和耗时可以来分析耗时长的接口，以及耗时的占比，找到最耗时的方法，从而进行优化</li></ul><h4 id="添加审计日志"><a href="#添加审计日志" class="headerlink" title="添加审计日志"></a>添加审计日志</h4><blockquote><p>人员角色模块增加审计日志，上报ES，使用 kibana 展示，便于观察分析调用、排查问题，给出证据</p></blockquote><p><img src="/images/%E6%9C%8D%E5%8A%A1%E6%97%A5%E5%BF%97%E4%BC%98%E5%8C%967.jpg"></p><h4 id="上报日志中心"><a href="#上报日志中心" class="headerlink" title="上报日志中心"></a>上报日志中心</h4><p>有时查问题前一天晚上有过发版，日志信息丢失，导致查询问题困难，针对这种情况把日志上报到日志中心的 Grafana Explore中</p><hr><p>把日志整体优化后，再也没有了以前的苦恼，有什么问题一目了然(<em>^▽^</em>)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;功能权限服务之前经手的人比较多，不同人日志打印比较乱，并且服务日志打印量很大，但当需要排查问题时，大日志量 &lt;co</summary>
      
    
    
    
    <category term="优化" scheme="http://yoursite.com/categories/%E4%BC%98%E5%8C%96/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
    <category term="优化" scheme="http://yoursite.com/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Spring-AOP</title>
    <link href="http://yoursite.com/2020/12/02/Spring-AOP/"/>
    <id>http://yoursite.com/2020/12/02/Spring-AOP/</id>
    <published>2020-12-02T03:22:37.000Z</published>
    <updated>2020-12-07T11:48:02.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>面向切面编程(AOP)可以实现横切关注点与它们所影响对象之间的解耦，对业务逻辑没有任何侵入<br>使用场景有很多，如：日志、异常、声明式事物、安全、缓存等，包括但不限于这些场景<br>常见的AOP实现有<code>Spring-AOP</code>和<code>AspectJ</code>，<code>Spring-AOP</code>基于动态代理实现，主要总结一下<code>Spring-AOP</code></p></blockquote><p><img src="/images/Spring-AOP0.png"></p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="切面-Aspect"><a href="#切面-Aspect" class="headerlink" title="切面(Aspect)"></a>切面(Aspect)</h4><p>切面是通知和切点的结合，通知和切点共同定义了切面的全面内容————是什么，在何时和何处完成其功能</p><h5 id="通知-Advice"><a href="#通知-Advice" class="headerlink" title="通知(Advice)"></a>通知(Advice)</h5><p>切面的具体功能被称为通知，同时通知不仅定义了切面功能，还定义了切面何时使用，而根据使用时机可以分为5种类型的通知：</p><ul><li>前置通知(Before)：在目标方法被调用之前调用通知功能</li><li>后置通知(After)：在目标方法完成之后调用通知，此时不会关心方法的输出是什么</li><li>返回通知(After-returning)：在目标方法成功执行之后调用通知</li><li>异常通知(After-throwing)：在目标方法抛出异常后调用通知</li><li>环绕通知(Around)：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。环绕通知是最强大的通知类型</li></ul><blockquote><p>在 <code>Spring-AOP</code> 中的环绕通知必须有 <code>ProceedingJoinPoint</code> 这个对象参数，通过它的 <code>proceed()</code> 方法来调用被通知的方法</p></blockquote><h5 id="切点-Poincut"><a href="#切点-Poincut" class="headerlink" title="切点(Poincut)"></a>切点(Poincut)</h5><p>通知定义了切面的 “什么” 和 “何时” ，切点则是定义了切面的 ”何处“</p><p>切点定义了通知被应用的具体位置(在哪些连接点)</p><h4 id="连接点-Join-point"><a href="#连接点-Join-point" class="headerlink" title="连接点(Join point)"></a>连接点(Join point)</h4><p>连接点是在应用执行过程中能够应用通知的 ”所有点“</p><p>连接点可以是调用方法时、抛出异常时、甚至修改一个字段时，但因为<code>Spring-AOP</code>基于动态代理，所以<code>Spring</code>只支持方法的连接点，而<code>AspectJ</code>和<code>JBoss</code>的AOP框架还提供了字段和构造器接入点。</p><p>但是方法拦截则满足了大部分的需求，如果需要方法拦截之外的连接点可以利用<code>AspectJ</code>来补充<code>Spring-AOP</code>的功能</p><h4 id="引入-Introduction"><a href="#引入-Introduction" class="headerlink" title="引入(Introduction)"></a>引入(Introduction)</h4><p>添加方法或字段到被通知的类</p><h4 id="织入-Weaving"><a href="#织入-Weaving" class="headerlink" title="织入(Weaving)"></a>织入(Weaving)</h4><p>织入是把切面应用到目标对象并创建新的代理对象的过程</p><p>织入可以在对象生命周期的多个点织入：</p><ul><li>编译期：切面在目标类编译期被织入。这种需要特殊的编译器。<code>AspectJ</code>的织入编译器就是以这种方式织入</li><li>类加载期：切面在目标类加载到JVM时被织入。这种方式需要特殊的类加载器，可以在目标类被引入应用之前增强该目标类的字节码。<code>AspectJ 5</code>的加载时织入就支持这种方式织入</li><li>运行期：切面在应用运行的某个时刻被织入。在织入时，AOP容器会为目标对象动态地创建一个代理对象。**<code>Spring-AOP</code>就是以这种方式织入切面的**</li></ul><h3 id="定义切点"><a href="#定义切点" class="headerlink" title="定义切点"></a>定义切点</h3><blockquote><p>切点用来定位使用通知的地方，在<code>Spring-AOP</code>中使用的是<code>AspectJ</code>的切点表达式语言来定义切点，但是<code>Spring</code>仅支持<code>AspectJ</code>切点指示器的一个子集</p></blockquote><h4 id="切点表达式"><a href="#切点表达式" class="headerlink" title="切点表达式"></a>切点表达式</h4><h5 id="切点指示器"><a href="#切点指示器" class="headerlink" title="切点指示器"></a>切点指示器</h5><p><code>Spring-AOP</code>所支持的<code>AspectJ</code>的切点指示器</p><table><thead><tr><th>AspectJ 指示器</th><th>描述</th></tr></thead><tbody><tr><td>arg()</td><td>限制连接点匹配参数为指定类型的执行方法</td></tr><tr><td>@args()</td><td>限制连接点匹配参数由指定注解标注的执行方法</td></tr><tr><td>execution()</td><td>用于匹配是连接点的执行方法</td></tr><tr><td>this()</td><td>限制连接点匹配AOP代理的bean引用为指定类型的类</td></tr><tr><td>target</td><td>限制连接点匹配目标对象为指定类型的类</td></tr><tr><td>@target()</td><td>限制连接点匹配特定的执行对象，这些对象对应的类要具有指定类 型的注解</td></tr><tr><td>within()</td><td>限制连接点匹配指定的类型</td></tr><tr><td>@within()</td><td>限制连接点匹配指定注解所标注的类型（当使用Spring AOP时，方 法定义在由指定的注解所标注的类里）</td></tr><tr><td>@annotation</td><td>限定匹配带有指定注解的连接点</td></tr></tbody></table><p><strong>只有<code>execution</code>指示器是实际执行匹配的，而其他的指示器都是用来限制匹配的</strong></p><h5 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h5><p>支持<code>and</code>、<code>or</code>、<code>not</code>关系来连接指示器</p><p>在POJO中使用<code>&amp;&amp;</code>、<code>||</code>、<code>!</code>分别代表<code>and</code>、<code>or</code>、<code>not</code>关系</p><p>在XML中直接使用<code>and</code>、<code>or</code>、<code>not</code>来连接指示器</p><p><img src="/images/Spring-AOP1.jpg"></p><h4 id="bean指示器"><a href="#bean指示器" class="headerlink" title="bean指示器"></a>bean指示器</h4><p>除去<code>AspectJ</code>指示器外，<code>Spring</code>还引入了一个新的<code>bean()</code>指示器，用来在切点表达式中使用bean的ID来标识bean。<code>bean()</code>使用<code>bean Id</code>或<code>bean名称</code>作为参数来限制切点只匹配特定的<code>bean</code></p><h3 id="注解创建切面"><a href="#注解创建切面" class="headerlink" title="注解创建切面"></a>注解创建切面</h3><blockquote><p><code>AspectJ 5</code>支持使用注解来创建切面，使用少量的注解就可以把任意类转变为切面</p></blockquote><blockquote><p><code>Spring</code>同时支持<code>AspectJ</code>注解驱动的切面</p></blockquote><h4 id="AOP配置注解"><a href="#AOP配置注解" class="headerlink" title="AOP配置注解"></a>AOP配置注解</h4><h5 id="Aspect"><a href="#Aspect" class="headerlink" title="@Aspect"></a>@Aspect</h5><p>表明该类不仅仅是个POJO，还是一个切面</p><h5 id="通知注解"><a href="#通知注解" class="headerlink" title="通知注解"></a>通知注解</h5><blockquote><p>通知注解对应五种通知类型，来声明通知方法</p></blockquote><table><thead><tr><th>注解</th><th>通知</th></tr></thead><tbody><tr><td>@After</td><td>通知方法会在目标方法返回或抛出异常后调用</td></tr><tr><td>@AfterReturning</td><td>通知方法会在目标方法返回后调用</td></tr><tr><td>@AfterThrowing</td><td>通知方法会在目标方法抛出异常后调用</td></tr><tr><td>@Around</td><td>通知方法会将目标方法封装起来</td></tr><tr><td>@Before</td><td>通知方法会在目标方法调用之前执行</td></tr></tbody></table><h5 id="Pointcut"><a href="#Pointcut" class="headerlink" title="@Pointcut"></a>@Pointcut</h5><p><code>@Pointcut</code>注解可以在一个<code>@AspectJ</code>切面内定义可重用的切点</p><p>E.g.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Audience</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Pointcut(&quot;execution(** concert.Performance.perform(..))&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performce</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Before(&quot;performce()&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">silenceCellPhones</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Silencing cell phones&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Around(&quot;performce()&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takeSeats</span><span class="params">(ProceedingJoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">joinPoint.proceed(joinPoint.getArgs())</span><br><span class="line">    System.out.println(<span class="string">&quot;Taking seats&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@AfterReturning(&quot;performce()&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">applause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;CLAP CLAP CLAP!!!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@AfterThrowing(&quot;performce()&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demandRefund</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Demanding a refund&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过在 <code>performance()</code> 方法上添加 <code>@Pointcut</code> 注解，这样就可以在任何的切点表达式中使用 <code>performance()</code> 了</p><p><code>performance()</code> 方法的实际内容并不重要，在这里它实际上应该是空的。其实该方法本身只是一个标识，供 <code>@Pointcut</code> 注解依附。</p><h4 id="通过注解引入新功能"><a href="#通过注解引入新功能" class="headerlink" title="通过注解引入新功能"></a>通过注解引入新功能</h4><blockquote><p>类似<code>Groovy</code>不直接修改对象或类的定义就能为对象或类增加新的方法，虽然Java不是动态语言，但是通过<code>AOP</code>引用新的接口则可以实现其功能</p></blockquote><blockquote><p>但是当引入接口的方法被调用时，代理会把此调用委托给实现了新接口的某个其他对象。实际上，<strong>一个<code>bean</code>的实现被拆分到了多个类中</strong></p></blockquote><p>通过<code>@DeclareParents</code>注解可以将新的接口引入到<code>bean</code>中</p><p>定义新的接口:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> concert;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Encoreable</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">performEncore</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建切面引入接口:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> concert;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.DeclareParents;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EncodeableIntroducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@DeclareParents(value=&quot;concert.Performce+&quot;,</span></span><br><span class="line"><span class="meta">                  defaultImpl=DefaultEncoreable.class)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Encoreable encoreable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@DeclareParents</code> 注解由三部分组成：</p><ul><li><code>value</code> 属性指定了哪种类型的 <code>bean</code> 要引入该接口。在本例中，也就是所有实现 <code>Performance</code> 的类型。（标记符后面的加号表示是 <code>Performance</code> 的所有子类型，而不是 Performance 本身。）</li><li><code>defaultImpl</code> 属性指定了为引入功能提供实现的类。在这里，我们指定的是 <code>DefaultEncoreable</code> 提供实现。</li><li><code>@DeclareParents</code> 注解所标注的静态属性指明了要引入了接口。在这里，我们所引入的是 Encoreable 接口。</li></ul><h3 id="XML中声明切面"><a href="#XML中声明切面" class="headerlink" title="XML中声明切面"></a>XML中声明切面</h3><h4 id="AOP配置元素"><a href="#AOP配置元素" class="headerlink" title="AOP配置元素"></a>AOP配置元素</h4><p>在 Spring 的 aop 命名空间中，提供了多个元素用来在 XML 中声明切面</p><table><thead><tr><th>AOP 配置元素</th><th>用途</th></tr></thead><tbody><tr><td>&lt;aop:advisor&gt;</td><td>定义 AOP 通知器</td></tr><tr><td>&lt;aop:after&gt;</td><td>定义 AOP 后置通知（不管被通知的方法是否执行成功）</td></tr><tr><td>&lt;aop:after-returning&gt;</td><td>定义 AOP 返回通知</td></tr><tr><td>&lt;aop:after-throwing&gt;</td><td>定义 AOP 异常通知</td></tr><tr><td>&lt;aop:around&gt;</td><td>定义 AOP 环绕通知</td></tr><tr><td>&lt;aop:aspect&gt;</td><td>定义一个切面</td></tr><tr><td>&lt;aop:aspectj-autoproxy&gt;</td><td>启用 @AspectJ 注解驱动的切面</td></tr><tr><td>&lt;aop:before&gt;</td><td>定义一个 AOP 前置通知</td></tr><tr><td>&lt;aop:config&gt;</td><td>顶层的 AOP 配置元素。大多数的元素必须包含在元素内</td></tr><tr><td>&lt;aop:declare-parents&gt;</td><td>以透明的方式为被通知的对象引入额外的接口</td></tr><tr><td>&lt;aop:pointcut&gt;</td><td>定义一个切点</td></tr></tbody></table><p>E.g.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;audience&quot;</span>&gt;</span></span><br><span class="line">    &lt;aop:pointcut</span><br><span class="line">      id=&quot;performance&quot;</span><br><span class="line">      expressions=&quot;execution(** concert.Performance.perform(..))&quot; /&gt;</span><br><span class="line">  </span><br><span class="line">    &lt;aop:before</span><br><span class="line">      pointcut-ref=&quot;performance&quot;</span><br><span class="line">      method=&quot;silenceCellPhones&quot; /&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;aop:around</span><br><span class="line">      pointcut-ref=&quot;performance&quot;</span><br><span class="line">      method=&quot;takeSeats&quot; /&gt;</span><br><span class="line">      </span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:after-returning</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">pointcut</span>=<span class="string">&quot;execution(** concert.Performance.perform(..))&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">method</span>=<span class="string">&quot;applause&quot;</span> /&gt;</span></span><br><span class="line">      </span><br><span class="line">    &lt;aop:after-throwing</span><br><span class="line">      pointcut-ref=&quot;performance&quot;</span><br><span class="line">      method=&quot;demandRefund&quot; /&gt;</span><br><span class="line">      </span><br><span class="line">  <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="通过切面引入新功能"><a href="#通过切面引入新功能" class="headerlink" title="通过切面引入新功能"></a>通过切面引入新功能</h4><p>使用 <code>@DeclareParents</code> 注解可以为被通知的方法引入新的方法，使用 <code>Spring aop</code> 命名空间中的 <code>&lt;aop:declare-parents&gt;</code> 元素，可以实现相同的功能</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">  &lt;aop:delate-parents</span><br><span class="line">    types-matching=&quot;concert.Performance+&quot;</span><br><span class="line">    implement-interface=&quot;concert.Encoreable&quot;</span><br><span class="line">    default-impl=&quot;concert.DefaultEncoreable&quot; /&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>types-matching</code>类型匹配，匹配为哪些<code>bean</code>引入接口</li><li><code>implement-interface</code>指定新加的接口</li><li><code>default-impl</code>用全限定类名来显式指定新加接口的实现</li><li><code>delegate-ref</code>还支持引用了一个<code>Spring bean</code>作为引入接口的实现</li></ul><h3 id="启用AspectJ自动代理"><a href="#启用AspectJ自动代理" class="headerlink" title="启用AspectJ自动代理"></a>启用AspectJ自动代理</h3><p><strong>无论是注解创建、还是XML声明切面，都需要启用自动代理，来创建切面的代理，否则切面不会生效</strong></p><p>启用自动代理有两种方式：</p><ul><li><p>在<code>JavaConfig</code>中启用</p><blockquote><p>配置类的类级别上通过使用 <code>@EnableAspectJAutoProxy</code> 注解启用自动代理功能</p></blockquote></li><li><p> 在<code>XML</code>中启用</p><blockquote><p>使用 Spring aop 命名空间中的 <code>&lt;aop:aspectj-autoproxy/&gt;</code> 元素</p></blockquote></li></ul><h3 id="注入AspectJ切面"><a href="#注入AspectJ切面" class="headerlink" title="注入AspectJ切面"></a>注入AspectJ切面</h3><blockquote><p>虽然 <code>Spring AOP</code> 能够满足许多应用的切面需求，但是与 <code>AspectJ</code> 相比，<code>Spring AOP</code> 是一个功能比较弱的 <code>AOP</code> 解决方案。<code>AspectJ</code> 提供了 <code>Spring AOP</code> 所不能支持的许多类型的切点</p></blockquote><p><code>AspectJ</code> 可以织入到任意的Java应用程序中，而我们可以借助 <code>Spring</code> 的依赖注入把 <code>bean</code> 装配进 <code>AspectJ</code> 切面中，这样更为方便</p><h4 id="用AspectJ实现切面"><a href="#用AspectJ实现切面" class="headerlink" title="用AspectJ实现切面"></a>用AspectJ实现切面</h4><p>创建 <code>AspectJ</code> 的切面需要使用扩展的Java语言</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.aspect.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> aspect AspectInject &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AspectInject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Pointcut（切入点）：定义了相应Advice要发生的地方。</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 定义切入点的常用的两种方式：</span></span><br><span class="line"><span class="comment">     * 1、使用正则表达式。</span></span><br><span class="line"><span class="comment">     * 2、使用AspectJ表达式（Https://www.iteye.com/blog/jinnianshilongnian-1415606）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">pointcut <span class="title">printInfo</span><span class="params">()</span>:<span class="title">execution</span><span class="params">(* xxx.xxx.xxx.xxx.printInfo(..)</span>)</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造器切点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">pointcut <span class="title">constructEntity</span><span class="params">()</span>:<span class="title">execution</span><span class="params">(xxx.xxx.xxx.xxx.User.new()</span>)</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Advice定义了在Pointcut（切入点）具体要做的操作。</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 切入点在AOP中有多种类型，但在Spring中只有方法类型。</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * before advice, 前置。</span></span><br><span class="line"><span class="comment">     * after return advice, 后置（出错不执行）。</span></span><br><span class="line"><span class="comment">     * after throwing advice, 后置（出错才执行）。</span></span><br><span class="line"><span class="comment">     * after(final) advice, 后置（怎么都执行）。</span></span><br><span class="line"><span class="comment">     * around advice, 环绕（前后都执行）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"> </span><br><span class="line">    before():printInfo()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------printInfo()方法的前置------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    after():printInfo()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------printInfo()的后置------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    before():constructEntity()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------new User()时候的前置------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    after():constructEntity()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-------new User()时候的后置------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用aspectOf-方法注入"><a href="#使用aspectOf-方法注入" class="headerlink" title="使用aspectOf()方法注入"></a>使用aspectOf()方法注入</h4><p><code>Spring bean</code> 由 <code>Spring</code> 容器初始化，但是 <code>AspectJ</code> 切面是由 <code>AspectJ</code> 在运行期创建的。等到 <code>Spring</code> 有机会为 <code>AspectJ</code> 切面注入 <code>bean</code> 时，切面已经被实例化了。</p><p>所有的 <code>AspectJ</code> 切面都提供了一个静态的 <code>aspectOf()</code> 方法，该方法返回切面的一个单例。所以为了获得切面的实例，我们必须使用 <code>factory-method</code> 来调用 <code>asepctOf()</code> 方法</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.aspect.test.AspectInject&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;aspectOf&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li>《Spring 实战（第 4 版）》</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;面向切面编程(AOP)可以实现横切关注点与它们所影响对象之间的解耦，对业务逻辑没有任何侵入&lt;br&gt;使用场景有很多，如：日志、异常、声明式事物、安全、缓存等，包括但不限于这些场景&lt;br&gt;常见的AOP实现有&lt;code&gt;Spring-AOP&lt;/code&gt;</summary>
      
    
    
    
    <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
    <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>ssh-ControlMaster</title>
    <link href="http://yoursite.com/2020/11/18/ssh-ControlMaster/"/>
    <id>http://yoursite.com/2020/11/18/ssh-ControlMaster/</id>
    <published>2020-11-18T11:13:59.000Z</published>
    <updated>2020-11-19T12:18:58.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><code>ssh</code> 的配置文件<code>~/.ssh/config</code>可以大大的简化 <code>ssh</code> 的一些操作，如果没有这个文件则自己在 <code>~/.ssh/</code> 下<code>touch</code>一个即可</p></blockquote><blockquote><p>该文主要介绍使用 <code>ControlMaster</code> 来复用连接，每次<code>ssh</code>一台服务器时不需要每次输入密码</p></blockquote><h3 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h3><h4 id="ControlMaster"><a href="#ControlMaster" class="headerlink" title="ControlMaster"></a>ControlMaster</h4><blockquote><p>SSH支持 <code>ControlMaster</code> 模式，单一网络共享多个seesion，复用之前建立的连接，</p></blockquote><p>值可以为 <code>no(default)/yes/ask/auto</code>需要和 <code>ControlPath</code> 配合使用，当值为 yes 时，ssh 会监听该路径下的 <code>control socket</code>，多个 session 会去连接该 socket，则会尽可能的复用连接</p><h4 id="ControlPath"><a href="#ControlPath" class="headerlink" title="ControlPath"></a>ControlPath</h4><blockquote><p>指定 control socket 的路径</p></blockquote><p>值可以使用下面这些参数：</p><ul><li>%L 本地主机名的第一个组件</li><li>%l 本地主机名（包括域名）</li><li>%h 远程主机名（命令行输入）</li><li>%n 远程原始主机名</li><li>%p 远程主机端口</li><li>%r 远程登录用户名</li><li>%u 本地 ssh 正在使用的用户名</li><li>%i 本地 ssh 正在使用 uid</li><li>%C 值为 %l%h%p%r 的 hash</li></ul><h4 id="ControlPersist"><a href="#ControlPersist" class="headerlink" title="ControlPersist"></a>ControlPersist</h4><blockquote><p>结合 <code>ControlMaster</code> 使用，指定连接打开后后台保持的时间。值可以为 no/yes/整数，单位 s。如果为 no，最初的客户端关闭就关闭。如果 yes/0，无限期的，直到杀死或通过其它机制，如：<code>ssh -O exit</code></p></blockquote><h3 id="实际配置"><a href="#实际配置" class="headerlink" title="实际配置"></a>实际配置</h3><h4 id="ssh-config文件"><a href="#ssh-config文件" class="headerlink" title="~/.ssh/config文件"></a>~/.ssh/config文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">host *</span><br><span class="line">ControlPersist yes</span><br><span class="line">ControlMaster auto</span><br><span class="line">ControlPath ~&#x2F;.ssh&#x2F;master-%r@%h:%p</span><br></pre></td></tr></table></figure><ul><li><code>host</code> 标识匹配的主机名，<code>*</code>代表所有，也可匹配的主机</li><li><code>ControlPersist</code> 保持连接，客户端关闭并不会真的关闭连接</li><li><code>ControlMaster</code> 开启连接复用</li><li><code>ControlPath</code> 指定<code>control socket</code>的路径，当开启<code>ssh</code>连接后，会在<code>~/.ssh/</code>下产生一个master开头的文件，当有这这个文件时，再次<code>ssh</code>连接同一个服务器时判断有该文件则不需要输入密码</li></ul><h4 id="修改expect脚本"><a href="#修改expect脚本" class="headerlink" title="修改expect脚本"></a>修改expect脚本</h4><p>经常会使用<code>expect</code>脚本来连接服务器，开启<code>ControlMaster</code>模式后可能会使之前的<code>expect</code>脚本有问题，所以需要修改<code>expect</code>脚本</p><ul><li><p>before</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/expect</span></span><br><span class="line">set host [lindex $argv 0]</span><br><span class="line">set username &quot;&quot;</span><br><span class="line"></span><br><span class="line">spawn ssh $username@$host</span><br><span class="line">expect &#123;</span><br><span class="line">&quot;*yes/no)? &quot; &#123;send &quot;yes\n&quot;; exp_continue&#125;</span><br><span class="line">&quot;password:&quot; &#123;send &quot;password&quot;&#125;</span><br><span class="line">&#125;</span><br><span class="line">interact</span><br></pre></td></tr></table></figure></li><li><p>after</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/expect</span></span><br><span class="line">set host [lindex $argv 0]</span><br><span class="line">set username &quot;&quot;</span><br><span class="line"></span><br><span class="line">set controlMaster [file exists ~/.ssh/master-$username@$host:22]</span><br><span class="line"></span><br><span class="line">if &#123; $controlMaster&#125; &#123;</span><br><span class="line">spawn ssh $username@$host</span><br><span class="line">&#125; else &#123;</span><br><span class="line">spawn ssh $username@$host</span><br><span class="line">expect &#123;</span><br><span class="line">    &quot;*yes/no)? &quot; &#123;send &quot;yes\n&quot;; exp_continue&#125;</span><br><span class="line">&quot;password:&quot; &#123;send &quot;password&quot;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">interact</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;ssh&lt;/code&gt; 的配置文件&lt;code&gt;~/.ssh/config&lt;/code&gt;可以大大的简化 &lt;code&gt;ssh&lt;/code&gt; 的一些操作，如果没有这个文件则自己在 &lt;code&gt;~/.ssh/&lt;/code&gt; 下&lt;code&gt;touc</summary>
      
    
    
    
    <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Annotation注解</title>
    <link href="http://yoursite.com/2020/11/13/Annotation%E6%B3%A8%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/11/13/Annotation%E6%B3%A8%E8%A7%A3/</id>
    <published>2020-11-13T04:33:31.000Z</published>
    <updated>2020-11-13T04:54:41.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="三种内置注解"><a href="#三种内置注解" class="headerlink" title="三种内置注解:"></a>三种内置注解:</h4><ol><li><p><code>@Override</code>表示当前的方法定义将覆盖超类中的方法。</p></li><li><p><code>@Deprecated</code>使用了注解为它的元素编译器将发出警告，因为注解@Deprecated是不赞成使用的代码，被弃用的代码。</p></li><li><p><code>@SuppressWarnings</code>关闭不当编辑器警告信息。</p></li></ol><h4 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h4><blockquote><p>定义注解的注解,是java提供给我们用于定义注解的基本注解.在<code>java.lang.annotation</code>包</p></blockquote><h5 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h5><blockquote><p>用于定义注解的作用目标，表示该注解可以用于什么地方，ElementType参数有：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Target(ElementType.TYPE)           用于接口(注解本质上也是接口),类,枚举</span><br><span class="line">@Target(ElementType.FIELD)          用于字段,枚举常量</span><br><span class="line">@Target(ElementType.METHOD)         用于方法</span><br><span class="line">@Target(ElementType.PARAMETER)      用于方法参数</span><br><span class="line">@Target(ElementType.CONSTRUCTOR)    用于构造参数</span><br><span class="line">@Target(ElementType.LOCAL_VARIABLE) 用于局部变量</span><br><span class="line">@Target(ElementType.ANNOTATION_TYPE)用于注解</span><br><span class="line">@Target(ElementType.PACKAGE)        用于包</span><br></pre></td></tr></table></figure><h5 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h5><blockquote><p>用于定义注解保留策略，即定义的注解类在什么时候存在(源码阶段 or 编译后 or 运行阶段).</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.SOURCE)注解仅在源码中保留,class文件中不存在</span><br><span class="line">@Retention(RetentionPolicy.CLASS)注解在源码和class文件中都存在,但运行时不存在,即运行时无法获得,该策略也是默认的保留策略</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)注解在源码,class文件中存在且运行时可以通过反射机制获取到</span><br></pre></td></tr></table></figure><h5 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h5><blockquote><p>用于描述其它类型的annotation应该被javadoc文档化,出现在api doc中</p></blockquote><h5 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h5><blockquote><p>允许子类继承父类中的注解</p></blockquote><h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE&#125;)   ---作用范围 Class</span><br><span class="line">@Retention(RetentionPolicy.CLASS)  ---生命周期：仅保留到.class文件</span><br><span class="line">public @interface 注解名 &#123;定义体&#125;</span><br></pre></td></tr></table></figure><p>像<code>@Override</code>这样,没有成员定义的注解称之为标记注解.</p><p>自定义注解后，需要处理注解，注解实现的具体逻辑需要自己来写注解处理器</p><h3 id="注解处理器"><a href="#注解处理器" class="headerlink" title="注解处理器:"></a>注解处理器:</h3><p>注解处理器可以分为运行时注解处理和编译时注解处理器.运行时处理器需要借助反射机制实现,而编译时处理器则需要借助APT来实现.</p><p>无论是运行时注解处理器还是编译时注解处理器,主要工作都是读取注解然后处理特定注解</p><h4 id="运行时注解处理器"><a href="#运行时注解处理器" class="headerlink" title="运行时注解处理器"></a>运行时注解处理器</h4><p>运行时注解属性为<code>@Retention(RetentionPolicy.RUNTIME)</code>的注解.</p><p>为了运行时能准确获取到注解的相关信息，Java在java.lang.reflect 反射包下新增了<code>AnnotatedElement</code>接口，所有程序元素的(Class,Method)都实现了该接口，通过该接口提供的方法可以利用反射技术地读取注解的信息</p><p>常用<code>AnnotatedElement</code>中的反射方法:</p><table><thead><tr><th align="center">方法</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center"><T extends Annotation> T getAnnotation(Class<T> annotationClass)</td><td align="center">返回该元素上存在的制定类型的注解</td></tr><tr><td align="center">Annotation[] getAnnotations()</td><td align="center">返回该元素上存在的所有注解</td></tr><tr><td align="center">default <T extends Annotation> T[] getAnnotationsByType(Class<T> annotationClass)</td><td align="center">返回该元素指定类型的注解</td></tr><tr><td align="center">default <T extends Annotation> T getDeclaredAnnotation(Class<T> annotationClass)</td><td align="center">返回直接存在与该元素上的所有注释</td></tr><tr><td align="center">default <T extends Annotation> T[] getDeclaredAnnotationsByType(Class<T> annotationClass)</td><td align="center">返回直接存在该元素岸上某类型的注释</td></tr><tr><td align="center">Annotation[] getDeclaredAnnotations()</td><td align="center">返回直接存在与该元素上的所有注释</td></tr></tbody></table><p>通过这些反射方法获取到注解信息，然后对其进行业务操作即可</p><h4 id="编译时注解处理器"><a href="#编译时注解处理器" class="headerlink" title="编译时注解处理器"></a>编译时注解处理器</h4><blockquote><p>(Annotation Processor Tool)APT,处理注解来生成代码<br>获取注解及生成代码都是在代码编译时候完成的，相比反射在运行时处理注解大大提高了程序性能</p></blockquote><p>不同于运行时注解处理器，编写编译时注解处理器分两步:</p><h5 id="继承AbstractProcessor，实现自己的注解处理器"><a href="#继承AbstractProcessor，实现自己的注解处理器" class="headerlink" title="继承AbstractProcessor，实现自己的注解处理器"></a>继承AbstractProcessor，实现自己的注解处理器</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RouteProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ProcessingEnvironment env)</span></span>&#123; </span><br><span class="line">        <span class="keyword">super</span>.init(processingEnv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annoations, RoundEnvironment env)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">getSupportedAnnotationTypes</span><span class="params">()</span> </span>&#123; </span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">super</span>.getSupportedAnnotationTypes();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SourceVersion <span class="title">getSupportedSourceVersion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">super</span>.getSupportedSourceVersion();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">方法</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">init(ProcessingEnvironment processingEnv)</td><td align="center">该方法有注解处理器自动调用，其中ProcessingEnvironment类提供了很多有用的工具类：Filter，Types，Elements，Messager等</td></tr><tr><td align="center">getSupportedAnnotationTypes()</td><td align="center">该方法返回字符串的集合表示该处理器用于处理那些注解</td></tr><tr><td align="center">getSupportedSourceVersion()</td><td align="center">该方法用来指定支持的java版本，一般来说我们都是支持到最新版本，因此直接返回SourceVersion.latestSupported(）即可</td></tr><tr><td align="center">process(Set annotations, RoundEnvironment roundEnv)</td><td align="center">该方法是注解处理器处理注解的主要地方，我们需要在这里写扫描和处理注解的代码，以及最终生成的java文件。其中需要深入的是RoundEnvironment类，该用于查找出程序元素上使用的注解</td></tr></tbody></table><h5 id="注册处理器-并打成jar包"><a href="#注册处理器-并打成jar包" class="headerlink" title="注册处理器,并打成jar包"></a>注册处理器,并打成jar包</h5><blockquote><p>注解和注解处理器必须要新建jar包，然后通过jar包引用。</p></blockquote><p>为了让java编译器或能够找到自定义的注解处理器我们需要对其进行注册和打包：自定义的处理器需要被打成一个jar，并且需要在jar包的<code>META-INF/services</code>路径下中创建一个固定的文件<code>javax.annotation.processing.Processor</code>,在<code>javax.annotation.processing.Processor</code>文件中需要填写自定义处理器的完整路径名，有几个处理器就需要填写几个</p><blockquote><p>AbstractProcessor中生成java类，可以使用JavaPoet开源库进行编写，提升效率</p></blockquote><p>常用的<code>Lombok</code>来消除代码冗余，则是通过APT来实现的<br><img src="/images/Annotation%E6%B3%A8%E8%A7%A3.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h3&gt;&lt;h4 id=&quot;三种内置注解&quot;&gt;&lt;a href=&quot;#三种内置注解&quot; class=&quot;headerlink&quot; title=&quot;三种内置注</summary>
      
    
    
    
    <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>创建文档站点</title>
    <link href="http://yoursite.com/2020/10/23/%E5%88%9B%E5%BB%BA%E6%96%87%E6%A1%A3%E7%AB%99%E7%82%B9/"/>
    <id>http://yoursite.com/2020/10/23/%E5%88%9B%E5%BB%BA%E6%96%87%E6%A1%A3%E7%AB%99%E7%82%B9/</id>
    <published>2020-10-23T08:47:20.000Z</published>
    <updated>2020-10-23T10:14:17.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>经常看到一些文档的网站很简洁，于是便调研了一下，自己动手基于<code>GitHub Pages</code>搭建了一个文档站点</p></blockquote><h3 id="文档站点生成器"><a href="#文档站点生成器" class="headerlink" title="文档站点生成器"></a>文档站点生成器</h3><blockquote><p>调研了5种文档站点生成器</p></blockquote><ol><li><p><a href="https://docsify.js.org/#/zh-cn/">docsify</a><br>不同于 <code>GitBook</code>、<code>vuePress</code>、<code>Hexo</code> 的地方是它不会生成静态的 .html 文件，所有转换工作都是在运行时。无需构建，写完文档直接发布</p></li><li><p><a href="https://docute.org/zh/">docute</a><br><code>docute</code> 和 <code>docsify</code> 几乎相同，都是运行时驱动，但具有不同的 UI 和不同的使用方式，Docute（60kB）比 Docisfy（20kB）大 3 倍，因为<code>docute</code>使用了 Vue，Vue Router 和 Vuex，而 <code>Docsify</code> 使用的是 vanilla JavaScript。</p></li><li><p><a href="https://vuepress.vuejs.org/zh/">vuePress</a><br>使用vue开发，每一个由 <code>VuePress</code> 生成的页面都带有预渲染好的 HTML，也因此具有非常好的加载性能和搜索引擎优化（SEO）</p></li><li><p><a href="https://rust-lang.github.io/mdBook/">mdBook</a><br><code>mdBook</code> 是一个命令行工具和<code>Rust crate</code>。可将Markdown文件创建为书籍。它与<code>Gitbook</code>非常相似,但用<code>Rust</code>编写</p></li><li><p><a href="https://www.gitbook.com/">gitBook</a><br><code>GitBook</code> 是一个基于 Node.js 的命令行工具，可使用 Github/Git 和 Markdown 来制作精美的电子书，支持输出多种格式文档：静态站点、PDF、eBook、单HTML网页、JSON</p></li></ol><h3 id="使用docsify搭建站点"><a href="#使用docsify搭建站点" class="headerlink" title="使用docsify搭建站点"></a>使用docsify搭建站点</h3><blockquote><p><a href="http://leetcode.tianwj.com/">leetcode.tianwj.com</a><br>把之前刷的leetcode记录生成了一个站点，并且绑定二级域名</p></blockquote><p><a href="https://docsify.js.org/#/zh-cn/">docsify</a> 官方文档写的非常详细，并且还支持中文，官方文档就是使用 <code>docsify</code> 生成的，具体可以查看官方文档</p><p>设置<code>GitHub Pages</code>:<br><img src="/images/gitHub-pages.png"></p><p>最终成品:<br><img src="/images/leetcode1.png"><br><img src="/images/leetcode2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;经常看到一些文档的网站很简洁，于是便调研了一下，自己动手基于&lt;code&gt;GitHub Pages&lt;/code&gt;搭建了一个文档站点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;文档站点生成器&quot;&gt;&lt;a href=&quot;#文档站点生成器&quot; class</summary>
      
    
    
    
    <category term="其他" scheme="http://yoursite.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux expect</title>
    <link href="http://yoursite.com/2020/09/13/Linux-expect/"/>
    <id>http://yoursite.com/2020/09/13/Linux-expect/</id>
    <published>2020-09-13T07:54:52.000Z</published>
    <updated>2020-09-13T09:08:43.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><code>expect</code> 是基于<a href="http://tcl.tk/man/tcl8.5/TclCmd/contents.htm">Tcl</a>实现的一个脚本语言，用来实现自动和程序交互式通信。类似自动远程登录命令，模拟人手工交互输入密码的过程，从而实现自动远程登录<br><code>expect</code> 的工作流程为:<code>spawn</code>(启动指定进程)—&gt;<code>expect</code>(获取指定关键字)—&gt;<code>send</code>(向指定程序发送指定字符)—&gt;<code>interact</code>(允许用户交互)–&gt;退出结束</p></blockquote><h3 id="安装expect"><a href="#安装expect" class="headerlink" title="安装expect"></a>安装expect</h3><p>使用<code>expect</code>的前提需要安装，这里以<code>yum</code>安装为例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y expect</span><br></pre></td></tr></table></figure><h3 id="expect常用命令"><a href="#expect常用命令" class="headerlink" title="expect常用命令"></a>expect常用命令</h3><h4 id="spawn"><a href="#spawn" class="headerlink" title="spawn"></a>spawn</h4><p>启动一个进程，然后所有的<code>expect</code>都在这个进程中进行</p><h4 id="expect"><a href="#expect" class="headerlink" title="expect"></a>expect</h4><p>获取匹配信息匹配成功则执行<code>expect</code>后面的程序动作</p><blockquote><p>example:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">expect &#123;</span><br><span class="line">    “yes&#x2F;no”</span><br><span class="line">    &#123;send “yes\n”;exp_continue&#125;</span><br><span class="line">    “*password:”</span><br><span class="line">    &#123;send “123456\n”&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="exp-continue"><a href="#exp-continue" class="headerlink" title="exp_continue"></a>exp_continue</h4><p>在<code>expect</code>中多次匹配用到，使后面的匹配仍然从第一个关键字开始，否则第一次匹配从第一个关键字开始，但是后面第二次匹配则从第二个关键字开始</p><h4 id="send-exp-send"><a href="#send-exp-send" class="headerlink" title="send exp_send"></a>send exp_send</h4><p>用于发送指定的字符串信息</p><h4 id="send-user"><a href="#send-user" class="headerlink" title="send_user"></a>send_user</h4><p>把参数输出到标准输出中去，默认的<code>send</code>,<code>exp_send</code>命令都是将参数输出到程序中的，相当于<code>shell</code>中的<code>echo</code></p><h4 id="interact"><a href="#interact" class="headerlink" title="interact"></a>interact</h4><p>停留在当前进程，退出<code>expect</code>，交给用户操作</p><h4 id="exit"><a href="#exit" class="headerlink" title="exit"></a>exit</h4><p>退出<code>expect</code>脚本，还可以使用该命令指定退出前的一些命令</p><blockquote><p>example:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">exit -onexit &#123;</span><br><span class="line">    exec rm $tmpfile(删除临时文件)</span><br><span class="line">    send_user “Good bye\n”</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><blockquote><p><code>expect</code>变量使用方法和<code>Tcl</code>一致</p></blockquote><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p>定义变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set host localhost</span><br><span class="line">set passwrod 123456</span><br></pre></td></tr></table></figure><blockquote><p>example:接收命令行参数为变量</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set host [lindex $argv 0]</span><br><span class="line">set passwrod [lindex $argv 1]</span><br></pre></td></tr></table></figure><h4 id="puts"><a href="#puts" class="headerlink" title="puts"></a>puts</h4><p>输出变量</p><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><h4 id="eof"><a href="#eof" class="headerlink" title="eof"></a>eof</h4><p><code>expect</code>执行结束 退出</p><h4 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a>timeout</h4><p>设置全局性的超时时间，默认是10s</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set timeout 60</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;expect&lt;/code&gt; 是基于&lt;a href=&quot;http://tcl.tk/man/tcl8.5/TclCmd/contents.htm&quot;&gt;Tcl&lt;/a&gt;实现的一个脚本语言，用来实现自动和程序交互式通信。类似自动远程登录命令，模拟人</summary>
      
    
    
    
    <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>线程安全与锁优化</title>
    <link href="http://yoursite.com/2020/04/06/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2020/04/06/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/</id>
    <published>2020-04-06T09:48:29.000Z</published>
    <updated>2020-04-06T09:58:36.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><h4 id="Java中的线程安全"><a href="#Java中的线程安全" class="headerlink" title="Java中的线程安全"></a>Java中的线程安全</h4><p>按照线程安全的“安全程度”分为五大类：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立</p><ol><li><strong>不可变</strong><br>在Java中不可变(Immutable)对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要再进行任何线程安全保护措施。如<code>final</code>关键字</li><li><strong>绝对线程安全</strong><br>绝对的线程安全是指“不管运行时环境如何，调用者都不需要任何额外的同步策略”，绝对的线程安全是需要付出非常高的代价的，甚至是不切实际的代价。而在Java API中标注是线程安全的类，大多数都不是绝对的线程安全，都是相对的线程安全</li><li><strong>相对线程安全</strong><br>相对线程安全就是我们通常意义上所讲的线程安全。它需要保证<strong>对象单次的操作是安全的,</strong> 如<code>Vector</code>的<code>get()</code>方法，这个方法是同步的。但是对于一些特定顺序的连续调用，则需要调用端使用额外的同步手段来保证正确性，如使用<code>synchronized</code>关键字<br>在Java中，大部分声明线程安全的类都属于这种类型，如<code>Vector</code>、<code>HashTable</code>、<code>ConcurrentHashMap</code>和<code>Collections</code>的<code>synchronizedCollection()</code>方法包装的集合等</li><li><strong>线程兼容</strong><br>线程兼容是值对象本身并不是线程安全的，但是通过调用端正确的使用同步手段来保证对象在并发环境中可以安全的使用。平常我们说一个类不是线程安全的，指的就是这种情况。<br>Java类库中大部分类都是线程兼容的，如<code>ArrayList</code>和<code>HashMap</code>等</li><li><strong>线程对立</strong><br>线程独立是指不管调用端是否采取了同步措施，都无法在多线程环境中并发使用。<br>线程对立这种情况是很少出现的，而且通常都是有害的，应当避免<br>如<code>Thread</code>类的<code>suspend()</code>和<code>resume()</code>方法。</li></ol><h4 id="线程安全的实现方法"><a href="#线程安全的实现方法" class="headerlink" title="线程安全的实现方法"></a>线程安全的实现方法</h4><ol><li><p><strong>互斥同步</strong><br>互斥同步是最常见也是最主要的并发保障手段。同步是指共享数据在同一时刻只能背一个线程使用，而互斥是实现同步的一种手段，<code>临界区(Critical Section)</code>、<code>互斥量(Mutex)</code>和<code>信号量(Semaphore)</code>都是常见的互斥实现方式</p><ul><li>synchronized关键字:<br>在Java中，最基本的互斥同步手段就是<code>synchronized关键字</code>，这是一个块结构的语法。<code>synchronized</code>关键字经过javac编译后，会在同步块前后形成<code>monitorenter</code>和<code>monitorexit</code>两个字节码指令。<br>在执行<code>monitorenter</code>指令时，首先尝试去获取对象锁，如果对象没有被锁定或当前线程已经持有了该对象的锁，就把锁的计数器增加一，而在执行<code>monitorexit</code>指令时将会将锁计数器的值减一。当锁计数器的值为0时，锁则被释放了。如果获取对象锁失败则会一直阻塞等待，直到获取到锁  </li></ul></li></ol><p><strong><code>synchronized</code>对于一个线程来说是可重入的，同时<code>synchronized</code>中的锁是非公平的</strong></p><pre><code>- 重入锁(ReentrantLock):  </code></pre><p>重入锁(ReentrantLock)是Lock接口最常见的一种实现，与<code>synchronized</code>相似，但是比<code>synchronized</code>相比多了一些高级功能，主要是：等待可中断、可实现公平锁(默认也是非公平锁)、可以绑定多个条件</p><ol start="2"><li><p><strong>非阻塞同步</strong><br>互斥同步也被称为阻塞同步，是一种悲观悲观的并发策略，主要问题是进行线程阻塞和唤醒所带来的性能开销。与之对应的则是乐观的并发策略，最常用的是不断的重试，直接操作共享数据，当出现冲突时，不断的重试，直到没有冲突。<br>最常见的方法是CAS(Compare-and-Swap)，如juc包中的<code>Atomic</code>类则是通过自旋和CAS实现的，同时CAS可能会出现ABA问题，但是大部分情况下ABA问题不会影响程序并发的正确性</p></li><li><p><strong>无同步方案</strong><br>如果让一个方法不涉及多线程共享数据，自然也不需要去保证线程安全，因为他们天生就是线程安全的，如<code>ThreadLocal</code>这个类，每一个<code>Thread</code>对象都有一个<code>ThreadLocalMap</code>对象，用来存储当前线程的变量</p></li></ol><h3 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h3><blockquote><p>JDK 5升级到JDK 6后，进行了大量的锁优化</p></blockquote><h4 id="自旋锁和自适应自旋"><a href="#自旋锁和自适应自旋" class="headerlink" title="自旋锁和自适应自旋"></a>自旋锁和自适应自旋</h4><ul><li>自旋锁：当线程尝试获取锁时发现冲突，则让获取锁的线程等一会，但不放弃CPU的执行时间，而让线程等待则让线程执行一个循环(自旋)即可</li><li>自适应自旋：自旋所等待的时间必须有一定的限度，如果超过了限定的次数仍然没有获取到锁，则使用传统的方法挂起该线程，自旋次数默认是10次。而自适应自旋则是自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定</li></ul><h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><p>锁消除是虚拟机即时编译器在运行时，检测到数据不可能被其他线程访问，则会对锁进行消除。锁消除的主要判断依据来源于逃逸分析的数据支持，如果判断一段代码在堆上的所有数据都不会逃逸出去被其他线程访问到，则可以把他们当作栈上的数据对待，认为他们是线程私有的</p><h4 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h4><p>如果虚拟机探测到有一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展(粗化)到整个操作序列的外部。如果<code>StringBuffer.append()</code>方法，连续操作append方法，锁则会扩展到第一个append方法之前和最后一个append方法之后，只需加一次锁就可以</p><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><blockquote><p>轻量级锁是通过CAS来实现的</p></blockquote><p>HotSpot虚拟机的对象头中有一部分用来存储对象自身的运行时数据，如哈希码，GC分代年龄、存储标识位、偏向模式等，官方称它为“Mark Word”。</p><p>在代码即将进入同步块之前，如果同步对象没有被锁定，则在当前线程的栈帧中建立一个锁记录(Lock Record)的空间，用来存储锁对象Mark Word的拷贝。<br>然后虚拟机使用CAS操作尝试把对象的Mark Word更新为Lock Record的指针，如果更新成功，则代表该线程拥有了这个对象的所，如果更新失败了，首先检查是否是当前线程拥有了这个对象的锁，如果是的话直接执行即可，如果不是则说明锁被其他线程抢占了。解锁反之。</p><p>如果出现两个线程争用一个锁的情况，那轻量级锁则不再有效，必须膨胀为重量级锁</p><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>轻量级锁是在无竞争的情况下使用CAS来消除同步的互斥量，而偏向锁是在无竞争的情况下把整个同步都消除掉，连CAS都不再操作</p><p>具体是这样的，当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设置为“01”、把偏向模式设置为“1”，标识进入偏向模式。同时使用CAS操作把获取这个锁的线程ID记录在了对象头的Mark Word中，如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁都不需要有任何同步操作。但是如果另外的线程去尝试获取这个锁，偏向模式则马上宣告结束</p><p>偏向锁是一种权衡的优化，如果程序中的大多数锁都总是被多个不同的线程访问，那偏向模式反而是多余的。具体情况具体分析，可以使用参数<code>-CC:-UseBiasedLocking</code>来禁止偏向锁优化</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;线程安全&quot;&gt;&lt;a href=&quot;#线程安全&quot; class=&quot;headerlink&quot; title=&quot;线程安全&quot;&gt;&lt;/a&gt;线程安全&lt;/h3&gt;&lt;h4 id=&quot;Java中的线程安全&quot;&gt;&lt;a href=&quot;#Java中的线程安全&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
</feed>
