<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tianwj&#39;s blog</title>
  
  
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2022-11-12T10:49:13.048Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>tianwj</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java-Agent</title>
    <link href="http://yoursite.com/2022/11/12/Java-Agent/"/>
    <id>http://yoursite.com/2022/11/12/Java-Agent/</id>
    <published>2022-11-12T10:36:35.000Z</published>
    <updated>2022-11-12T10:49:13.048Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>Java Agent 直译过来叫做 Java 代理，但更多称叫做 Java 探针</p></blockquote><p>Java Agent是一种特殊的Java程序（Jar文件），与普通Java程序通过main方法启动不同，agent并不是一个可以单独启动的程序，而必须依附在一个Java应用程序（JVM）上，与它运行在同一个进程中，通过<code>Instrumentation API</code>与虚拟机交互</p><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="Instrumentation"><a href="#Instrumentation" class="headerlink" title="Instrumentation"></a>Instrumentation</h3><p><code>Instrumentation</code>是Java提供的一个来自JVM的接口，该接口提供了一系列查看和操作Java类定义的方法，例如修改类的字节码、向<code>classLoader</code>的<code>classpath</code>下加入jar文件等。使得开发者可以通过Java语言来操作和监控JVM内部的一些状态，进而实现Java程序的监控分析，甚至实现一些特殊功能（如AOP、热部署）</p><p>主流的JVM都提供了<code>Instrumentation</code>的实现，但是鉴于<code>Instrumentation</code>的特殊功能，并不适合直接提供在JDK的runtime里，而更适合出现在Java程序的外层，以上帝视角在合适的时机出现。因此如果想使用<code>Instrumentation</code>功能，<strong>「拿到Instrumentation实例，我们必须通过Java agent」</strong>，<code>Instrumentation</code>常用方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Instrumentation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//增加一个Class 文件的转换器，转换器用于改变 Class 二进制流的数据，参数 canRetransform 设置是否允许重新转换。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addTransformer</span><span class="params">(ClassFileTransformer transformer, <span class="keyword">boolean</span> canRetransform)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在类加载之前，重新定义 Class 文件，ClassDefinition 表示对一个类新的定义，</span></span><br><span class="line">    <span class="comment">//如果在类加载之后，需要使用 retransformClasses 方法重新定义。addTransformer方法配置之后，后续的类加载都会被Transformer拦截。</span></span><br><span class="line">    <span class="comment">//对于已经加载过的类，可以执行retransformClasses来重新触发这个Transformer的拦截。类加载的字节码被修改后，除非再次被retransform，否则不会恢复。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addTransformer</span><span class="params">(ClassFileTransformer transformer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除一个类转换器</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">removeTransformer</span><span class="params">(ClassFileTransformer transformer)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//是否允许对class retransform</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isRetransformClassesSupported</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在类加载之后，重新定义 Class。这个很重要，该方法是1.6 之后加入的，事实上，该方法是 update 了一个类。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">retransformClasses</span><span class="params">(Class&lt;?&gt;... classes)</span> <span class="keyword">throws</span> UnmodifiableClassException</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//是否允许对class重新定义</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isRedefineClassesSupported</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//此方法用于替换类的定义，而不引用现有的类文件字节，就像从源代码重新编译以进行修复和继续调试时所做的那样。</span></span><br><span class="line">    <span class="comment">//在要转换现有类文件字节的地方（例如在字节码插装中），应该使用retransformClasses。</span></span><br><span class="line">    <span class="comment">//该方法可以修改方法体、常量池和属性值，但不能新增、删除、重命名属性或方法，也不能修改方法的签名</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">redefineClasses</span><span class="params">(ClassDefinition... definitions)</span> <span class="keyword">throws</span>  ClassNotFoundException, UnmodifiableClassException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取已经被JVM加载的class，有className可能重复（可能存在多个classloader）</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span></span><br><span class="line">    Class[] getAllLoadedClasses();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中最常用的方法就是<code>addTransformer(ClassFileTransformer transformer)</code>了，这个方法可以在类加载时做拦截，对输入的类的字节码进行修改，其参数是一个<code>ClassFileTransformer</code>接口，定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 传入参数表示一个即将被加载的类，包括了classloader，classname和字节码byte[]</span></span><br><span class="line"><span class="comment"> * 返回值为需要被修改后的字节码byte[]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">byte</span>[] transform( ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, <span class="keyword">byte</span>[] classfileBuffer) <span class="keyword">throws</span> IllegalClassFormatException;</span><br></pre></td></tr></table></figure><p><code>addTransformer</code>方法配置之后，后续的类加载都会被<code>Transformer</code>拦截。对于已经加载过的类，可以执行<code>retransformClasses</code>来重新触发这个<code>Transformer</code>的拦截。类加载的字节码被修改后，除非再次被<code>retransform</code>，否则不会恢复</p><h3 id="Attach"><a href="#Attach" class="headerlink" title="Attach"></a>Attach</h3><p><code>Attach API</code>其实是跨JVM进程通讯的工具，能够将某种指令从一个JVM进程发送给另一个JVM进程</p><p><code>Attach</code>机制可以对目标进程收集很多信息，如内存<code>dump</code>，线程<code>dump</code>，类信息统计(比如加载的类及大小以及实例个数等)，动态加载agent，动态设置vm flag，打印vm flag，获取系统属性等等</p><h2 id="Java-Agent结构"><a href="#Java-Agent结构" class="headerlink" title="Java Agent结构"></a>Java Agent结构</h2><p>Java Agent 最终以 jar 包的形式存在。主要包含两个部分，一部分是实现代码，一部分是配置文件。配置文件放在 META-INF 目录下，文件名为 <code>MANIFEST.MF</code> </p><p>代码入口是<code>premain</code>或<code>agentmain</code>方法，具体选用哪个方法以及其中的内容根据应用场景决定</p><p>配置文件参数说明：</p><ul><li>Manifest-Version: 版本号</li><li>Created-By: 创作者</li><li>Agent-Class: agentmain方法所在类</li><li>Can-Redefine-Classes: 是否可以实现类的重定义</li><li>Can-Retransform-Classes: 是否可以实现字节码替换</li><li>Premain-Class: premain 方法所在类</li></ul><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>   Java Agent 技术有以下主要功能：</p><ul><li>在加载Java文件前拦截字节码并做修改</li><li>在运行期间变更已加载的类的字节码</li><li> 获取所有已经被加载过的类</li><li>获取所有已经被初始化过了的类</li><li>获取某个对象的大小</li></ul><p>基于这些功能，衍生出了很多常见工具，Java调式、热部署、线上诊断等工具都有依赖Java Agent：</p><ul><li><p>各个 Java IDE 的调试功能，例如 eclipse、IntelliJ </p></li><li><p>热部署功能，例如 JRebel、XRebel、spring-loaded</p></li><li><p>各种线上诊断工具，例如 Btrace、Greys，还有阿里的 Arthas</p></li><li><p>各种性能分析工具，例如 Visual VM、JConsole 等</p></li></ul><h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><p>Java Agent分为两种：静态<code>Agent</code>与动态<code>Agent</code></p><p><img src="/images/image-20221008202408373.png" alt="image-20221008202408373"></p><h2 id="静态Agent"><a href="#静态Agent" class="headerlink" title="静态Agent"></a>静态Agent</h2><p> 这种方式是使用<code>premain</code>作为<code>Agent</code>的入口方法，以JVM启动参数<code>-javaagent:xxx.jar</code>方式载入，在Java程序的<code>main</code>方法执行之前执行</p><ol><li><p>编写<code>premain</code>方法，应该包含以下两个方法中的一个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String args, Instrumentation inst)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String args)</span></span>;</span><br></pre></td></tr></table></figure><p>JVM 会优先加载带<code>Instrumentation</code>签名的方法1，加载成功忽略方法2，如果没有<code>Instrumentation</code>签名的方法，则加载方法2</p></li><li><p>定义一个<code>MANIFEST.MF</code>文件，其中必须包含Premain-Class选项</p></li><li><p>将包含<code>premain</code>的类与<code>MANIFEST.MF</code>配置文件打包成一个 jar 包</p></li><li><p>在JVM启动参数中添加<code>-javaagent:[path]</code>，其中的<code>path</code>为对应的<code>Agent</code>的jar包路径。这样则将<code>Agent</code>挂载成功，Java程序再执行<code>main</code>方法前执行</p></li></ol><h2 id="动态Agent"><a href="#动态Agent" class="headerlink" title="动态Agent"></a>动态Agent</h2><p> 与静态方式不同，动态<code>Agent</code>允许代理的目标程序的JVM先启动，再通过<code>attach</code>机制载入</p><ol><li><p>同样需要实现<code>agentmain</code>方法，加载优先级与<code>premain</code>相同，带<code>Instrumentation</code>签名的方法优先</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">agentmain</span><span class="params">(String args, Instrumentation inst)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">agentmain</span><span class="params">(String args)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>定义一个<code>MANIFEST.MF</code>文件，与静态<code>Agent</code>不同的是，此时必须包含Agent-Class选项</p></li><li><p>同样将包含<code>agentmain</code>的类与<code>MANIFEST.MF</code>配置文件打包成一个 jar 包</p></li><li><p>和<code>premain</code>模式不同，不再通过添加启动参数的方式来连接<code>agent</code>和主程序了，而使用<code>attach</code>方式来挂载。<code>attach</code>方式使用了<code>com.sun.tools.attach</code>包下的<code>VirtualMachine</code>工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取所有VM实例</span></span><br><span class="line">List&lt;VirtualMachineDescriptor&gt; list = VirtualMachine.list();</span><br><span class="line"><span class="comment">// attach对应VM</span></span><br><span class="line">VirtualMachine attach = VirtualMachine.attach(descriptor);</span><br><span class="line"><span class="comment">// 加载目标Agent</span></span><br><span class="line">attach.loadAgent(<span class="string">&quot;Java-Agent路径&quot;</span>);</span><br></pre></td></tr></table></figure></li></ol><h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><p>最常用<code>Instrumentation</code>的<code>addTransformer</code>方法对类加载做拦截，对输入的类的字节码进行修改、增强。依赖字节码修改，字节码修改技术主要有 Javassist、ASM，Javassist使用更简单，这里使用Javassist来进行字节码修改，引入相关maven包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javassist<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javassist<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.12.1.GA<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>Javassist</code> 使用可以参考下面文档：</p><p><a href="https://www.cnblogs.com/chiangchou/p/javassist.html">基于 Javassist 和 Javaagent 实现动态切面</a></p><p><a href="https://github.com/jboss-javassist/javassist/wiki">Javassist API</a></p><h2 id="实现极简的watch命令"><a href="#实现极简的watch命令" class="headerlink" title="实现极简的watch命令"></a>实现极简的watch命令</h2><blockquote><p>模拟Arthas的watch命令，来统计方法执行耗时</p></blockquote><h3 id="开发Agent"><a href="#开发Agent" class="headerlink" title="开发Agent"></a>开发Agent</h3><p><a href="https://github.com/ShadowTwj/sandbox/tree/master/agent/src/main/java/cn/tianwenjie/watch">https://github.com/ShadowTwj/sandbox/tree/master/agent/src/main/java/cn/tianwenjie/watch</a></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ol><li>Agent入口方法，包括<code>premain</code>和<code>agentmain</code>两个方法，后面会分别测试两个场景</li></ol><img src="/images/image-20221010202535725.png" alt="image-20221010202535725" style="zoom: 33%;" /><ol start="2"><li><p>实现类转换器，来对指定类和方法增强</p><img src="/images/image-20221010202839064.png" alt="image-20221010202839064" style="zoom:33%;" /></li></ol><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><p>配置<code>MANIFEST.MF</code>文件，指定<code>Premain-Class</code>和<code>Agent-Class</code>等属性，将配置文件与代码一同打包生成jar包</p><p>也可以使用maven的<code>maven-assembly-plugin</code>插件，来进行打包，参数可直接配置在pom文件中，打包的时候就会自动将配置信息生成 <code>MANIFEST.MF</code> 配置文件打进包里</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-assembly-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">archive</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">addClasspath</span>&gt;</span>true<span class="tag">&lt;/<span class="name">addClasspath</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">manifestEntries</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Built-By</span>&gt;</span>neo<span class="tag">&lt;/<span class="name">Built-By</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Premain-Class</span>&gt;</span>cn.tianwenjie.watch.WatchDemo<span class="tag">&lt;/<span class="name">Premain-Class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Agent-Class</span>&gt;</span>cn.tianwenjie.watch.WatchDemo<span class="tag">&lt;/<span class="name">Agent-Class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Main-Class</span>&gt;</span>cn.tianwenjie.watch.WatchDemo<span class="tag">&lt;/<span class="name">Main-Class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Can-Redefine-Classes</span>&gt;</span>true<span class="tag">&lt;/<span class="name">Can-Redefine-Classes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Can-Retransform-Classes</span>&gt;</span>true<span class="tag">&lt;/<span class="name">Can-Retransform-Classes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Can-Set-Native-Method-Prefix</span>&gt;</span>true<span class="tag">&lt;/<span class="name">Can-Set-Native-Method-Prefix</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">manifestEntries</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">descriptorRef</span>&gt;</span>jar-with-dependencies<span class="tag">&lt;/<span class="name">descriptorRef</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><blockquote><p>分别测试Agent的两种方式</p></blockquote><p><a href="https://github.com/ShadowTwj/sandbox/tree/master/agent-run/src/main/java/cn/tianwenjie/watch">https://github.com/ShadowTwj/sandbox/tree/master/agent-run/src/main/java/cn/tianwenjie/watch</a></p><h4 id="静态Agent测试"><a href="#静态Agent测试" class="headerlink" title="静态Agent测试"></a>静态Agent测试</h4><ul><li>打印控制台输入，统计打印方法耗时</li></ul><img src="/images/image-20221011110030840.png" alt="image-20221011110030840" style="zoom: 33%;" /><ul><li>添加<code>VM options</code>，指定<code>Agent</code> Jar包路径</li></ul><img src="/images/image-20221011110416104.png" alt="image-20221011110416104" style="zoom:33%;" /><ul><li><p>执行<code>main</code>方法，观察<code>print</code>方法耗时</p><img src="/images/image-20221011110730915.png" alt="image-20221011110730915" style="zoom:33%;" /></li></ul><h4 id="动态Agent测试"><a href="#动态Agent测试" class="headerlink" title="动态Agent测试"></a>动态Agent测试</h4><ul><li><p>测试方法如上，打印控制台输入，统计打印方法耗时</p></li><li><p>不需要添加<code>VM options</code>，直接执行<code>main</code>方法，观察未挂载<code>Agent</code>前控制台只打印了输入参数，没有打印方法耗时，该方法不要结束，等待下面<code>Attach</code></p><img src="/images/image-20221011111320354.png" alt="image-20221011111320354" style="zoom:33%;" /></li><li><p><code>Attach</code> VM，挂载<code>Agent</code> Jar包</p><img src="/images/image-20221011111737935.png" alt="image-20221011111737935" style="zoom:33%;" /></li><li><p><code>Attach</code>成功后，再执行测试类，观察到方法增强成功，打印控制台输入的同时打印方法耗时</p><img src="/images/image-20221011112040162.png" alt="image-20221011112040162" style="zoom:33%;" /></li></ul><h2 id="模拟热加载"><a href="#模拟热加载" class="headerlink" title="模拟热加载"></a>模拟热加载</h2><blockquote><p>模拟热加载，重新加载修改的类</p><p>与watch命令最大的区别是没有使用字节码修改技术，而是自定义编译器，将新的代码编译为字节码</p></blockquote><h3 id="开发Agent-1"><a href="#开发Agent-1" class="headerlink" title="开发Agent"></a>开发Agent</h3><p><a href="https://github.com/ShadowTwj/sandbox/tree/master/agent/src/main/java/cn/tianwenjie/hotdeploy">https://github.com/ShadowTwj/sandbox/tree/master/agent/src/main/java/cn/tianwenjie/hotdeploy</a></p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><ol><li><p>Agent入口方法，静态Agent对热加载无用，这里只实现动态Agent的<code>agentmain</code>方法</p><p>使用<code>retransform</code>和<code>redefineClasses</code>方法效果一样，这里使用<code>redefineClasses</code>方法，不在实现类转换器</p><img src="/images/image-20221112180722715.png" alt="image-20221112180722715" style="zoom:50%;" /></li><li><p>自定义编译器，因为热加载改动代码大多都不可预测，使用字节码修改技术并不方便，这里自定义编译器，来编译成字节码</p><p>具体代码：</p><p><a href="https://github.com/ShadowTwj/sandbox/blob/master/agent/src/main/java/cn/tianwenjie/hotdeploy/common/DynamicCompiler.java">https://github.com/ShadowTwj/sandbox/blob/master/agent/src/main/java/cn/tianwenjie/hotdeploy/common/DynamicCompiler.java</a></p></li></ol><h4 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h4><p>修改<code>maven-assembly-plugin</code>插件配置，打包生成配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-assembly-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">archive</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">addClasspath</span>&gt;</span>true<span class="tag">&lt;/<span class="name">addClasspath</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">manifestEntries</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Built-By</span>&gt;</span>neo<span class="tag">&lt;/<span class="name">Built-By</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Premain-Class</span>&gt;</span>cn.tianwenjie.hotdeploy.HotLoadingDemo<span class="tag">&lt;/<span class="name">Premain-Class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Agent-Class</span>&gt;</span>cn.tianwenjie.hotdeploy.HotLoadingDemo<span class="tag">&lt;/<span class="name">Agent-Class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Main-Class</span>&gt;</span>cn.tianwenjie.hotdeploy.HotLoadingDemo<span class="tag">&lt;/<span class="name">Main-Class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Can-Redefine-Classes</span>&gt;</span>true<span class="tag">&lt;/<span class="name">Can-Redefine-Classes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Can-Retransform-Classes</span>&gt;</span>true<span class="tag">&lt;/<span class="name">Can-Retransform-Classes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Can-Set-Native-Method-Prefix</span>&gt;</span>true<span class="tag">&lt;/<span class="name">Can-Set-Native-Method-Prefix</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">manifestEntries</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">descriptorRef</span>&gt;</span>jar-with-dependencies<span class="tag">&lt;/<span class="name">descriptorRef</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><p><a href="https://github.com/ShadowTwj/sandbox/tree/master/agent-run/src/main/java/cn/tianwenjie/hotdeploy">https://github.com/ShadowTwj/sandbox/tree/master/agent-run/src/main/java/cn/tianwenjie/hotdeploy</a></p><ul><li><p>测试方法同上watch命令，打印控制台输入</p><img src="/images/image-20221112182332843.png" alt="image-20221112182332843" style="zoom:50%;" /></li><li><p><code>Attach</code> VM，挂载<code>Agent</code> Jar包，热加载新类。如下图，继续打印控制台输入，可以看到热加载成功</p><img src="/images/image-20221112182533197.png" alt="image-20221112182533197" style="zoom:50%;" /></li></ul><h1 id="Java-Agent原理"><a href="#Java-Agent原理" class="headerlink" title="Java-Agent原理"></a>Java-Agent原理</h1><h2 id="静态Agent-1"><a href="#静态Agent-1" class="headerlink" title="静态Agent"></a>静态Agent</h2><h3 id="启动时加载过程"><a href="#启动时加载过程" class="headerlink" title="启动时加载过程"></a>启动时加载过程</h3><blockquote><p>JPLISAgent：作用是初始化所有通过Java Instrumentation API编写的Agent，并且也承担着通过JVMTI实现Java Instrumentation中暴露API的责任</p></blockquote><ol><li>创建并初始化 JPLISAgent；</li><li>监听 VMInit 事件，在 JVM 初始化完成之后做下面的事情：<ol><li>创建 InstrumentationImpl 对象 ；</li><li>监听 ClassFileLoadHook 事件 ；</li><li>调用 InstrumentationImpl 的loadClassAndCallPremain方法，在这个方法里会去调用 javaagent 中 MANIFEST.MF 里指定的Premain-Class 类的 premain 方法 ；</li></ol></li><li>解析 javaagent 中 MANIFEST.MF 文件的参数，并根据这些参数来设置 JPLISAgent 里的一些内容。</li></ol><img src="https://img2020.cnblogs.com/blog/1071038/202101/1071038-20210112143707325-1984756789.png" /><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><ol><li><p>参数解析</p><p>JVM启动时解析对应参数，观察<code>hotspot/src/share/vm/runtime/arguments.cpp</code>中的<code>Arguments::parse_each_vm_init_arg</code>函数片段</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -agentlib and -agentpath</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">match_option</span>(option, <span class="string">&quot;-agentlib:&quot;</span>, &amp;tail) ||</span><br><span class="line">          (is_absolute_path = <span class="built_in">match_option</span>(option, <span class="string">&quot;-agentpath:&quot;</span>, &amp;tail))) &#123;</span><br><span class="line">      <span class="keyword">if</span>(tail != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* pos = <span class="built_in">strchr</span>(tail, <span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">        <span class="keyword">char</span>* name;</span><br><span class="line">        <span class="keyword">if</span> (pos == <span class="literal">NULL</span>) &#123;</span><br><span class="line">          name = os::<span class="built_in">strdup_check_oom</span>(tail, mtArguments);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">size_t</span> len = pos - tail;</span><br><span class="line">          name = <span class="built_in">NEW_C_HEAP_ARRAY</span>(<span class="keyword">char</span>, len + <span class="number">1</span>, mtArguments);</span><br><span class="line">          <span class="built_in">memcpy</span>(name, tail, len);</span><br><span class="line">          name[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> *options = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(pos != <span class="literal">NULL</span>) &#123;</span><br><span class="line">          options = os::<span class="built_in">strdup_check_oom</span>(pos + <span class="number">1</span>, mtArguments);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !INCLUDE_JVMTI</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">valid_jdwp_agent</span>(name, is_absolute_path)) &#123;</span><br><span class="line">          <span class="built_in">jio_fprintf</span>(defaultStream::<span class="built_in">error_stream</span>(),</span><br><span class="line">            <span class="string">&quot;Debugging agents are not supported in this VM\n&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span> JNI_ERR;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// !INCLUDE_JVMTI</span></span></span><br><span class="line">        <span class="comment">// 存储Agent解析结果</span></span><br><span class="line">        <span class="comment">// name:&quot;instrument&quot;，动态链接库</span></span><br><span class="line">        <span class="built_in">add_init_agent</span>(name, options, is_absolute_path);</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">// -javaagent</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">match_option</span>(option, <span class="string">&quot;-javaagent:&quot;</span>, &amp;tail)) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !INCLUDE_JVMTI</span></span><br><span class="line">      <span class="built_in">jio_fprintf</span>(defaultStream::<span class="built_in">error_stream</span>(),</span><br><span class="line">        <span class="string">&quot;Instrumentation agents are not supported in this VM\n&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> JNI_ERR;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">      <span class="keyword">if</span> (tail != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">size_t</span> length = <span class="built_in">strlen</span>(tail) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> *options = <span class="built_in">NEW_C_HEAP_ARRAY</span>(<span class="keyword">char</span>, length, mtArguments);</span><br><span class="line">        <span class="built_in">jio_snprintf</span>(options, length, <span class="string">&quot;%s&quot;</span>, tail);</span><br><span class="line">        <span class="built_in">add_instrument_agent</span>(<span class="string">&quot;instrument&quot;</span>, options, <span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// java agents need module java.instrument</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">create_numbered_module_property</span>(<span class="string">&quot;jdk.module.addmods&quot;</span>, <span class="string">&quot;java.instrument&quot;</span>, addmods_count++)) &#123;</span><br><span class="line">          <span class="keyword">return</span> JNI_ENOMEM;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// !INCLUDE_JVMTI</span></span></span><br></pre></td></tr></table></figure><p>这段逻辑用来解析需要加载的Agent路径，然后调用<code>add_init_agent</code>存储解析结果到<code>_agentList</code>中，<code>AgentLibraryList</code>是一个链表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -agentlib and -agentpath arguments</span></span><br><span class="line"><span class="keyword">static</span> AgentLibraryList _agentList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Arguments::add_init_agent</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">char</span>* options, <span class="keyword">bool</span> absolute_path)</span> </span>&#123;</span><br><span class="line">  _agentList.<span class="built_in">add</span>(<span class="keyword">new</span> <span class="built_in">AgentLibrary</span>(name, options, absolute_path, <span class="literal">NULL</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>加载Agent</p><p>观察<code>hotspot/src/share/vm/runtime/threads.cpp</code>中的<code>Threads::create_vm</code>函数，JVM在解析完参数后，判断<code>_agentList</code>是否为空，不为空加载<code>Agent</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Launch -agentlib/-agentpath and converted -Xrun agents</span></span><br><span class="line"><span class="comment">// 判断agent链表是否为空，不为空加载Agent</span></span><br><span class="line"><span class="keyword">if</span> (Arguments::<span class="built_in">init_agents_at_startup</span>()) &#123;</span><br><span class="line">  <span class="built_in">create_vm_init_agents</span>();</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">init_agents_at_startup</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> !_agentList.<span class="built_in">is_empty</span>(); &#125;</span><br></pre></td></tr></table></figure><p>分析<code>create_vm_init_agents</code>函数，遍历<code>Agent</code>逐个加载，解析对应的<code>Agent_Onload</code>函数，最终调用<code>premain</code>方法，执行<code>Agent_Onload</code>函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (agent = Arguments::<span class="built_in">agents</span>(); agent != <span class="literal">NULL</span>; agent = agent-&gt;<span class="built_in">next</span>()) &#123;</span><br><span class="line">  <span class="comment">// CDS dumping does not support native JVMTI agent.</span></span><br><span class="line">  <span class="comment">// CDS dumping supports Java agent if the AllowArchivingWithJavaAgent diagnostic option is specified.</span></span><br><span class="line">  <span class="keyword">if</span> (Arguments::<span class="built_in">is_dumping_archive</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!agent-&gt;<span class="built_in">is_instrument_lib</span>()) &#123;</span><br><span class="line">      <span class="built_in">vm_exit_during_cds_dumping</span>(<span class="string">&quot;CDS dumping does not support native JVMTI agent, name&quot;</span>, agent-&gt;<span class="built_in">name</span>());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!AllowArchivingWithJavaAgent) &#123;</span><br><span class="line">      <span class="built_in">vm_exit_during_cds_dumping</span>(</span><br><span class="line">        <span class="string">&quot;Must enable AllowArchivingWithJavaAgent in order to run Java agent during CDS dumping&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解析Agent_OnLoad函数，最终调用premain方法</span></span><br><span class="line">  OnLoadEntry_t  on_load_entry = <span class="built_in">lookup_agent_on_load</span>(agent);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (on_load_entry != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">// Invoke the Agent_OnLoad function</span></span><br><span class="line">    <span class="comment">// 执行Agent_OnLoad函数</span></span><br><span class="line">    jint err = (*on_load_entry)(&amp;main_vm, agent-&gt;<span class="built_in">options</span>(), <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (err != JNI_OK) &#123;</span><br><span class="line">      <span class="built_in">vm_exit_during_initialization</span>(<span class="string">&quot;agent library failed to init&quot;</span>, agent-&gt;<span class="built_in">name</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">vm_exit_during_initialization</span>(<span class="string">&quot;Could not find Agent_OnLoad function in the agent library&quot;</span>, agent-&gt;<span class="built_in">name</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Agent_OnLoad函数</p><blockquote><p>动态链接库<code>libinstrument</code>，用来支持使用Java Instrumentation API来编写Agent，在libinstrument中有一个非常重要的类称为：JPLISAgent（Java Programming Language Instrumentation Services Agent），它的作用是初始化所有通过Java Instrumentation API编写的Agent，并且也承担着通过JVMTI实现Java Instrumentation中暴露API的责任</p></blockquote><p>在动态链接库<code>libinstrument</code>中找到<code>Agent_OnLoad</code>函数，在<code>java.instrument/share/native/libinstrument/InvocationAdapter.c</code>中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">JNIEXPORT jint JNICALL</span><br><span class="line">DEF_Agent_OnLoad(JavaVM *vm, <span class="keyword">char</span> *tail, <span class="keyword">void</span> * reserved) &#123;</span><br><span class="line">    JPLISInitializationError initerror  = JPLIS_INIT_ERROR_NONE;</span><br><span class="line">    jint                     result     = JNI_OK;</span><br><span class="line">    JPLISAgent *             agent      = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 创建并初始化JPLISAgent</span></span><br><span class="line">    initerror = createNewJPLISAgent(vm, &amp;agent);</span><br><span class="line">   <span class="keyword">if</span> ( initerror == JPLIS_INIT_ERROR_NONE ) &#123;</span><br><span class="line">        <span class="keyword">int</span>             oldLen, newLen;</span><br><span class="line">        <span class="keyword">char</span> *          jarfile;</span><br><span class="line">        <span class="keyword">char</span> *          options;</span><br><span class="line">        jarAttribute*   attributes;</span><br><span class="line">        <span class="keyword">char</span> *          premainClass;</span><br><span class="line">        <span class="keyword">char</span> *          bootClassPath;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Parse &lt;jarfile&gt;[=options] into jarfile and options</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (parseArgumentTail(tail, &amp;jarfile, &amp;options) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;-javaagent: memory allocation failure.\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> JNI_ERR;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        attributes = readAttributes(jarfile);</span><br><span class="line">        </span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">        premainClass = getAttribute(attributes, <span class="string">&quot;Premain-Class&quot;</span>);</span><br><span class="line">        </span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Save the jarfile name */</span></span><br><span class="line">        agent-&gt;mJarfile = jarfile;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">      </span><br><span class="line">        bootClassPath = getAttribute(attributes, <span class="string">&quot;Boot-Class-Path&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Convert JAR attributes into agent capabilities</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        convertCapabilityAttributes(attributes, agent);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Track (record) the agent class name and options data</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        initerror = recordCommandLineData(agent, premainClass, options);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Clean-up</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (options != <span class="literal">NULL</span>) <span class="built_in">free</span>(options);</span><br><span class="line">        freeAttributes(attributes);</span><br><span class="line">        <span class="built_in">free</span>(premainClass);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到函数中调用<code>createNewJPLISAgent</code>方法，创建JPLISAgent，在<code>createNewJPLISAgent</code>函数中又调用<code>initializeJPLISAgent</code>函数进行初始化，<code>initializeJPLISAgent</code>函数中有设置VMInit时间回调函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.触发VMInit事件回调</span></span><br><span class="line">callbacks.VMInit = &amp;eventHandlerVMInit;</span><br></pre></td></tr></table></figure><p>看下<code>eventHandlerVMInit</code>函数实现，<code>eventHandlerVMInit</code> -&gt; <code>processJavaStart</code> -&gt; <code>startJavaAgent</code> -&gt; <code>invokeJavaAgentMainMethod</code>，最终<code>invokeJavaAgentMainMethod</code>函数则是调用<code>premain</code>方法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> JNICALL</span><br><span class="line">eventHandlerVMInit( jvmtiEnv *      jvmtienv,</span><br><span class="line">                    JNIEnv *        jnienv,</span><br><span class="line">                    jthread         thread) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  success = processJavaStart( environment-&gt;mAgent, jnienv);</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jboolean</span><br><span class="line">processJavaStart(   JPLISAgent *    agent,</span><br><span class="line">                    JNIEnv *        jnienv) &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *  Now make the InstrumentationImpl instance.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ( result ) &#123;</span><br><span class="line">        result = createInstrumentationImpl(jnienv, agent);</span><br><span class="line">        jplis_assert_msg(result, <span class="string">&quot;instrumentation instance creation failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *  Load the Java agent, and call the premain.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ( result ) &#123;</span><br><span class="line">        result = startJavaAgent(agent, jnienv,</span><br><span class="line">                                agent-&gt;mAgentClassName, agent-&gt;mOptionsString,</span><br><span class="line">                                agent-&gt;mPremainCaller);</span><br><span class="line">        jplis_assert_msg(result, <span class="string">&quot;agent load/premain call failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jboolean</span><br><span class="line">startJavaAgent( JPLISAgent *    agent,</span><br><span class="line">                JNIEnv *        jnienv,</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">char</span> *    classname,</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">char</span> *    optionsString,</span><br><span class="line">                jmethodID       agentMainMethod) &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 3.执行premain方法</span></span><br><span class="line">  success = invokeJavaAgentMainMethod(   jnienv,</span><br><span class="line">                                      agent-&gt;mInstrumentationImpl,</span><br><span class="line">                                      agentMainMethod,</span><br><span class="line">                                      classNameObject,</span><br><span class="line">                                      optionsStringObject);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="动态Agent-1"><a href="#动态Agent-1" class="headerlink" title="动态Agent"></a>动态Agent</h2><h3 id="运行时加载过程"><a href="#运行时加载过程" class="headerlink" title="运行时加载过程"></a>运行时加载过程</h3><p>通过 JVM 的attach机制来请求目标 JVM 加载对应的agent，过程大致如下：</p><ol><li>创建并初始化JPLISAgent；</li><li>解析 javaagent 里 MANIFEST.MF 里的参数；</li><li>创建 InstrumentationImpl 对象；</li><li>监听 ClassFileLoadHook 事件；</li><li>调用 InstrumentationImpl 的loadClassAndCallAgentmain方法，在这个方法里会去调用javaagent里 MANIFEST.MF 里指定的Agent-Class类的agentmain方法。</li></ol><img src="https://img2020.cnblogs.com/blog/1071038/202101/1071038-20210112143615738-1489695442.png"/><h3 id="Attach-1"><a href="#Attach-1" class="headerlink" title="Attach"></a>Attach</h3><blockquote><p>动态Agent是通过Attach机制来加载，下面分析下Attach原理</p></blockquote><ol><li><p>AttachListener</p><p><code>Attach</code>机制通过<code>Attach Listener</code>线程来进行相关事务的处理，<code>AttachListener</code>初始化如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AttachListener::init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  EXCEPTION_MARK;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* name = <span class="string">&quot;Attach Listener&quot;</span>;</span><br><span class="line">  Handle thread_oop = JavaThread::<span class="built_in">create_system_thread_object</span>(name, <span class="literal">true</span> <span class="comment">/* visible */</span>, THREAD);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">has_init_error</span>(THREAD)) &#123;</span><br><span class="line">    <span class="built_in">set_state</span>(AL_NOT_INITIALIZED);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  JavaThread* thread = <span class="keyword">new</span> <span class="built_in">JavaThread</span>(&amp;attach_listener_thread_entry);</span><br><span class="line">  JavaThread::<span class="built_in">vm_exit_on_osthread_failure</span>(thread);</span><br><span class="line"></span><br><span class="line">  JavaThread::<span class="built_in">start_internal_daemon</span>(THREAD, thread, thread_oop, NoPriority);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>attach_listener_thread_entry</code>函数是线程入口，代码片段如下：</p><p>首先获取到<code>Attach</code>任务，然后查询匹配命令对应的函数，最后执行对应函数，funcs是命令对应的函数，其中”load”命令对应<code>load_agent</code>函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">attach_listener_thread_entry</span><span class="params">(JavaThread* thread, TRAPS)</span> </span>&#123;</span><br><span class="line">  AttachListener::<span class="built_in">set_initialized</span>();</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">// 1.获取Attach任务</span></span><br><span class="line">      AttachOperation* op = AttachListener::<span class="built_in">dequeue</span>();</span><br><span class="line">    </span><br><span class="line">      <span class="comment">// find the function to dispatch too</span></span><br><span class="line">    <span class="comment">// 2.查询匹配命令对应的函数，funcs是命令对应的函数，其中&quot;load&quot;命令对应load_agent函数</span></span><br><span class="line">      AttachOperationFunctionInfo* info = <span class="literal">NULL</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; funcs[i].name != <span class="literal">NULL</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* name = funcs[i].name;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(op-&gt;<span class="built_in">name</span>(), name) == <span class="number">0</span>) &#123;</span><br><span class="line">          info = &amp;(funcs[i]); <span class="keyword">break</span>;</span><br><span class="line">        &#125;&#125;</span><br><span class="line">    </span><br><span class="line">       <span class="comment">// dispatch to the function that implements this operation</span></span><br><span class="line">    <span class="comment">// 3.执行命令对应的函数</span></span><br><span class="line">        res = (info-&gt;func)(op, &amp;st);</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看<code>dequeue</code>函数，是如何获取任务的，<code>dequeue</code>函数不系统实现不同，windows系统是<code>Win32AttachListener::dequeue()</code>，Mac系统是<code>BsdAttachListener::dequeue()</code>，Linux系统是<code>LinuxAttachListener::dequeue()</code>。下面是Linux系统实现，等待客户端连接，通过<code>accept</code>来接收，然后将请求读出来，包装成<code>AttachOperation</code>对象，返回进行处理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinuxAttachOperation* <span class="title">LinuxAttachListener::dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">// wait for client to connect</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> <span class="title">addr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> len = <span class="built_in"><span class="keyword">sizeof</span></span>(addr);</span><br><span class="line">    <span class="comment">// 等待连接，通过accept来接收</span></span><br><span class="line">    <span class="built_in">RESTARTABLE</span>(::<span class="built_in">accept</span>(<span class="built_in">listener</span>(), &amp;addr, &amp;len), s);</span><br><span class="line">    <span class="comment">// get the credentials of the peer and check the effective uid/guid</span></span><br><span class="line">    <span class="comment">// - check with jeff on this.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ucred</span> <span class="title">cred_info</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> optlen = <span class="built_in"><span class="keyword">sizeof</span></span>(cred_info);</span><br><span class="line">    <span class="keyword">if</span> (::<span class="built_in">getsockopt</span>(s, SOL_SOCKET, SO_PEERCRED, (<span class="keyword">void</span>*)&amp;cred_info, &amp;optlen) == <span class="number">-1</span>) &#123;</span><br><span class="line">      ::<span class="built_in">close</span>(s);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// peer credential look okay so we read the request</span></span><br><span class="line">    <span class="comment">// 将请求读出来</span></span><br><span class="line">    LinuxAttachOperation* op = <span class="built_in">read_request</span>(s);</span><br><span class="line">    <span class="keyword">return</span> op;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>VirtualMachine.attach</code>方法</p><p>通过<code>com.sun.tools.attach.VirtualMachine#attach</code>方法来连接指定pid的JVM进程，查看源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> VirtualMachine <span class="title">attach</span><span class="params">(String var0)</span> <span class="keyword">throws</span> AttachNotSupportedException, IOException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (var0 == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;id cannot be null&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    List var1 = AttachProvider.providers();</span><br><span class="line">    <span class="keyword">if</span> (var1.size() == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> AttachNotSupportedException(<span class="string">&quot;no providers installed&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      AttachNotSupportedException var2 = <span class="keyword">null</span>;</span><br><span class="line">      Iterator var3 = var1.iterator();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span>(var3.hasNext()) &#123;</span><br><span class="line">        AttachProvider var4 = (AttachProvider)var3.next();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> var4.attachVirtualMachine(var0);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AttachNotSupportedException var6) &#123;</span><br><span class="line">          var2 = var6;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">throw</span> var2;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出最终调用<code>AttachProvider</code>的<code>attachVirtualMachine</code>方法，<code>AttachProvider</code>是抽象类，不同系统不同实现，在MacOS中实现类是<code>BsdAttachProvider</code>，其中<code>attachVirtualMachine</code>实现是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> VirtualMachine <span class="title">attachVirtualMachine</span><span class="params">(String var1)</span> <span class="keyword">throws</span> AttachNotSupportedException, IOException </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.checkAttachPermission();</span><br><span class="line">  <span class="keyword">this</span>.testAttachable(var1);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> BsdVirtualMachine(<span class="keyword">this</span>, var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看其构造方法，通过<code>findSocketFile</code>方法用来查询目标JVM上是否已经启动了<code>Attach Listener</code>，因为<code>Attach Listener</code>是懒加载，所以JVM启动也不一定加载。检查<code>/tmp/.java_pid&#123;pid&#125;</code>文件是否存在，如果存在，则说明目标JVM Attach机制已准备就绪，可以直接通过<code>connect</code>方法来连接到目标JVM，发送命令；如果不存在，则说明目标JVM的<code>Attach Listener</code>还没有初始化，这时通过<code>sendQuitTo</code>方法向目标JVM发送信号，让其初始化<code>Attach Listener</code>，并且循环等待<code>/tmp/.java_pid&#123;pid&#125;</code>文件的创建，之后再通过<code>connect</code>方法来连接到目标JVM，发送命令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">BsdVirtualMachine(AttachProvider var1, String var2) <span class="keyword">throws</span> AttachNotSupportedException, IOException &#123;</span><br><span class="line">  <span class="keyword">super</span>(var1, var2);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> var3;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    var3 = Integer.parseInt(var2);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (NumberFormatException var22) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> AttachNotSupportedException(<span class="string">&quot;Invalid process identifier&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// var3为pid，检查/tmp/.java_pid&#123;pid&#125;是否存在</span></span><br><span class="line">  <span class="keyword">this</span>.path = <span class="keyword">this</span>.findSocketFile(var3);</span><br><span class="line">  <span class="comment">// 如果存在，则说明目标JVM Attach机制已准备就绪，可以直接通过connect方法来连接到目标JVM，发送命令</span></span><br><span class="line">  <span class="comment">// 如果不存在，则说明目标JVM的Attach Listener还没有初始化</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.path == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 创建/tmp/.java_pid&#123;pid&#125;文件</span></span><br><span class="line">    File var4 = <span class="keyword">new</span> File(tmpdir, <span class="string">&quot;.attach_pid&quot;</span> + var3);</span><br><span class="line">    createAttachFile(var4.getPath());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 向目标JVM发送信号，让其初始化Attach Listener</span></span><br><span class="line">      sendQuitTo(var3);</span><br><span class="line">      <span class="keyword">int</span> var5 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">long</span> var6 = <span class="number">200L</span>;</span><br><span class="line">      <span class="keyword">int</span> var8 = (<span class="keyword">int</span>)(<span class="keyword">this</span>.attachTimeout() / var6);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 循环等待/tmp/.java_pid&#123;pid&#125;文件的创建，之后再通过connect方法来连接到目标JVM，发送命令</span></span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          Thread.sleep(var6);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException var21) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.path = <span class="keyword">this</span>.findSocketFile(var3);</span><br><span class="line">        ++var5;</span><br><span class="line">      &#125; <span class="keyword">while</span>(var5 &lt;= var8 &amp;&amp; <span class="keyword">this</span>.path == <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.path == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AttachNotSupportedException(<span class="string">&quot;Unable to open socket file: target process not responding or HotSpot VM not loaded&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      var4.delete();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  checkPermissions(<span class="keyword">this</span>.path);</span><br><span class="line">  <span class="keyword">int</span> var24 = socket();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    connect(var24, <span class="keyword">this</span>.path);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    close(var24);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>loadAgent方法</code></p><p>通过<code>attach</code>方法，连接上目标JVM后，通过<code>loadAgent</code>方法来加载<code>Agent</code>，其本质是向目标JVM发送<code>load</code>命令，这里不再展开</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadAgentLibrary</span><span class="params">(String var1, <span class="keyword">boolean</span> var2, String var3)</span> <span class="keyword">throws</span> AgentLoadException, AgentInitializationException, IOException </span>&#123;</span><br><span class="line">  InputStream var4 = <span class="keyword">this</span>.execute(<span class="string">&quot;load&quot;</span>, var1, var2 ? <span class="string">&quot;true&quot;</span> : <span class="string">&quot;false&quot;</span>, var3);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> var5 = <span class="keyword">this</span>.readInt(var4);</span><br><span class="line">    <span class="keyword">if</span> (var5 != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> AgentInitializationException(<span class="string">&quot;Agent_OnAttach failed&quot;</span>, var5);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    var4.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看下JVM中<code>load</code>命令的实现，上面<code>Agtach Listener</code>的<code>attach_listener_thread_entry</code>函数中，会查询匹配命令对应的函数，然后执行对应的函数，<code>funcs</code>则是一个命令函数表，查看<code>load</code>命令对应的函数，发现是<code>load_agent</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// names must be of length &lt;= AttachOperation::name_length_max</span></span><br><span class="line"><span class="keyword">static</span> AttachOperationFunctionInfo funcs[] = &#123;</span><br><span class="line">  &#123; <span class="string">&quot;agentProperties&quot;</span>,  get_agent_properties &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;datadump&quot;</span>,         data_dump &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;dumpheap&quot;</span>,         dump_heap &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;load&quot;</span>,             load_agent &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;properties&quot;</span>,       get_system_properties &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;threaddump&quot;</span>,       thread_dump &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;inspectheap&quot;</span>,      heap_inspection &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;setflag&quot;</span>,          set_flag &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;printflag&quot;</span>,        print_flag &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;jcmd&quot;</span>,             jcmd &#125;,</span><br><span class="line">  &#123; <span class="literal">NULL</span>,               <span class="literal">NULL</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再查看<code>load_agent</code>函数实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Implementation of &quot;load&quot; command.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> jint <span class="title">load_agent</span><span class="params">(AttachOperation* op, outputStream* out)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// get agent name and options</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* agent = op-&gt;<span class="built_in">arg</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* absParam = op-&gt;<span class="built_in">arg</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* options = op-&gt;<span class="built_in">arg</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If loading a java agent then need to ensure that the java.instrument module is loaded</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strcmp</span>(agent, <span class="string">&quot;instrument&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">    JavaThread* THREAD = JavaThread::<span class="built_in">current</span>(); <span class="comment">// For exception macros.</span></span><br><span class="line">    <span class="function">ResourceMark <span class="title">rm</span><span class="params">(THREAD)</span></span>;</span><br><span class="line">    <span class="function">HandleMark <span class="title">hm</span><span class="params">(THREAD)</span></span>;</span><br><span class="line">    <span class="function">JavaValue <span class="title">result</span><span class="params">(T_OBJECT)</span></span>;</span><br><span class="line">    Handle h_module_name = java_lang_String::<span class="built_in">create_from_str</span>(<span class="string">&quot;java.instrument&quot;</span>, THREAD);</span><br><span class="line">    JavaCalls::<span class="built_in">call_static</span>(&amp;result,</span><br><span class="line">                           vmClasses::<span class="built_in">module_Modules_klass</span>(),</span><br><span class="line">                           vmSymbols::<span class="built_in">loadModule_name</span>(),</span><br><span class="line">                           vmSymbols::<span class="built_in">loadModule_signature</span>(),</span><br><span class="line">                           h_module_name,</span><br><span class="line">                           THREAD);</span><br><span class="line">    <span class="keyword">if</span> (HAS_PENDING_EXCEPTION) &#123;</span><br><span class="line">      java_lang_Throwable::<span class="built_in">print</span>(PENDING_EXCEPTION, out);</span><br><span class="line">      CLEAR_PENDING_EXCEPTION;</span><br><span class="line">      <span class="keyword">return</span> JNI_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> JvmtiExport::<span class="built_in">load_agent_library</span>(agent, absParam, options, out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要作用是加载<code>Agent</code>动态链接库，如果是通过<code>Java instrument API</code>实现的Agent，则加载的是<code>libinstrument</code>动态链接库。然后通过动态链接库中的<code>Agent_OnAttach</code>函数来创建<code>JPLISAgent</code>，从而调用<code>agentmain</code>方法。这一部分内容和<code>libinstrument</code>中的<code>Agent_OnLoad</code>函数来创建<code>JPLISAgent</code>，调用<code>premain</code>方法的逻辑相似</p></li></ol><h1 id="相关开源项目"><a href="#相关开源项目" class="headerlink" title="相关开源项目"></a>相关开源项目</h1><p>很多开源项目都用到了<code>Java-Agent</code>，下面列举两个项目，有兴趣可以阅读一下</p><h2 id="Arthas"><a href="#Arthas" class="headerlink" title="Arthas"></a>Arthas</h2><p>Arthas用到非常重要的技术就是Java-Agent，以及相关的字节码增强等技术，从启动方式就能看出来使用的是动态Agent的方式</p><p>代码地址：<a href="https://github.com/alibaba/arthas">https://github.com/alibaba/arthas</a></p><h2 id="ja-netfilter"><a href="#ja-netfilter" class="headerlink" title="ja-netfilter"></a>ja-netfilter</h2><p>一个Java Instrumentation框架，也是通过Java-Agent实现的，支持插件化。使用的是静态Agent方式</p><p>相关文章：<a href="https://zhile.io/2021/11/29/ja-netfilter-javaagent-lib.html">https://zhile.io/2021/11/29/ja-netfilter-javaagent-lib.html</a></p><p>代码地址：<a href="https://gitee.com/ja-netfilter/ja-netfilter">https://gitee.com/ja-netfilter/ja-netfilter</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.51cto.com/alex4dream/3247542">https://blog.51cto.com/alex4dream/3247542</a></p><p><a href="https://tech.meituan.com/2019/11/07/java-dynamic-debugging-technology.html">https://tech.meituan.com/2019/11/07/java-dynamic-debugging-technology.html</a></p><p><a href="https://tech.meituan.com/2022/03/17/java-hotswap-sonic.html">https://tech.meituan.com/2022/03/17/java-hotswap-sonic.html</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzkyMjIzOTQ3NA==&amp;mid=2247484609&amp;idx=1&amp;sn=8bd852871d656f5a5dcb216f810a273f&amp;source=41#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MzkyMjIzOTQ3NA==&amp;mid=2247484609&amp;idx=1&amp;sn=8bd852871d656f5a5dcb216f810a273f&amp;source=41#wechat_redirect</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Java Agent 直译过来叫做 Java 代理，但更多称叫做 Java 探针&lt;/p&gt;
&lt;/blockquote</summary>
      
    
    
    
    <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
    <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>PostgreSQL介绍</title>
    <link href="http://yoursite.com/2021/11/26/PostgreSQL%E4%BB%8B%E7%BB%8D/"/>
    <id>http://yoursite.com/2021/11/26/PostgreSQL%E4%BB%8B%E7%BB%8D/</id>
    <published>2021-11-26T05:59:37.000Z</published>
    <updated>2022-03-13T06:11:47.742Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/postgresql0.png"></p><h1 id="关于PostgreSQL"><a href="#关于PostgreSQL" class="headerlink" title="关于PostgreSQL"></a>关于PostgreSQL</h1><p><code>PostgreSQL</code> 是一个强大的开源对象关系数据库系统，它使用并扩展了 SQL 语言，并结合了许多安全存储和扩展最复杂数据工作负载的功能。</p><p><code>PostgreSQL</code> 是以加州大学伯克利分校计算机系开发的<a href="https://dsf.berkeley.edu/postgres.html">POSTGRES， 版本 4.2</a>为基础的对象关系型数据库系统</p><p><code>PostgreSQL</code>，也称为 <code>Postgres</code>，简称<strong>PG</strong>(以下都简称PG)</p><p>PG 号称是“世界上最先进的开源关系型数据库”，和“世界上最好的语言”不同，PG的自吹自擂并没有受到大家的调侃</p><p>PG 不属于任何一家公司，它背后的控制机构是——<strong>PostgreSQL全球开发小组</strong>，是一个松散的组织</p><p>其核心成员来自全球各地的不同公司，如果感兴趣，可以在PG<a href="https://www.postgresql.org/community/contributors/">官网</a>查询到这个组织的成员列表</p><p>可以这么说，没有任何一个公司享有对 PG 的绝对控制权，PG永远是属于社区</p><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><blockquote><p>开源大家都不陌生，但是开源并不等于免费，下面是几种协议的区别</p></blockquote><p><img src="/images/postgresql1.png"></p><ul><li><p>GPL 协议：</p><p>GPL 是一种传染协议，如果修改了源码，也必须使用 GPL 协议</p><p>GPL 是一种“非商业”友好协议，如果是商业项目，那一定要注意 GPL 的可能带来的问题</p><p>Linux 内核 使用的就是 GPL 协议，免费的 MySQL 社区版使用的也是 GPL 协议</p></li><li><p>BSD 协议：</p><p>BSD 是一个给予使用者很大自由的协议</p><p>基本上使用者可以“为所欲为”可以自由的使用,修改源代码,也可以将修改后的代码作为开源或者专有软件再发布</p></li></ul><p>PG 早期使用的就是 BSD 协议，后面换成了自有协议——<strong>PostgreSQL License</strong>，虽然换了自由协议，但并没有多少改变，依然属于最为友好的协议类型</p><p>不论是自用还是商用，都是完全没有问题，修改代码并且用来盈利也是毫无商业风险的</p><h2 id="PG影响力"><a href="#PG影响力" class="headerlink" title="PG影响力"></a>PG影响力</h2><ul><li><p>在行业中的应用(几年前的图)</p><p><img src="/images/postgresql2.png"></p></li><li><p><a href="https://db-engines.com/en/ranking_trend">DB-Engines 排名</a></p><p><img src="/images/postgresql3.png"></p></li><li><p>Stack Overflow 问卷调查</p><p><a href="https://insights.stackoverflow.com/survey/2021#section-most-loved-dreaded-and-wanted-databases">2021最受欢迎数据库排名</a></p><p><img src="/images/postgresql4.png"></p><p><a href="https://insights.stackoverflow.com/survey/2021#section-most-loved-dreaded-and-wanted-databases">2021使用数据库排名</a></p><p><img src="/images/postgresql5.png"></p></li></ul><h1 id="PG功能"><a href="#PG功能" class="headerlink" title="PG功能"></a>PG功能</h1><h2 id="SQL标准"><a href="#SQL标准" class="headerlink" title="SQL标准"></a>SQL标准</h2><p>最新的 SQL 标准是 SQL:2016</p><p>SQL:2016 标准中的核心标准中的<strong>179</strong>项特性，而 PG 至少实现了<strong>170</strong>项，在数据库中也算名列前茅的</p><h2 id="Schema"><a href="#Schema" class="headerlink" title="Schema"></a>Schema</h2><h3 id="Schema定义"><a href="#Schema定义" class="headerlink" title="Schema定义"></a>Schema定义</h3><p>一个 PG 集群可以包含多个数据库，一个数据库包含一个或多个命名<em>模式</em>，模式中包含着表</p><p><code>schema</code> 还包含其他类型的命名对象，包括数据类型、函数和操作符。相同的对象名称可以被用于不同的模式中而不会出现冲突，例如 schema1 和 myschema 都可以包含名为 mytable 的表</p><p>下面是一些使用 <code>schema</code> 的原因：</p><ul><li>允许多个用户使用一个数据库并且不会互相干扰</li><li>将数据库对象组织成逻辑组以便更容易管理</li><li>第三方应用的对象可以放在独立的模式中，这样它们就不会与其他对象的名称发生冲突</li></ul><p><code>schema</code> 类似于操作系统层的目录，但是 <code>schema</code> 不能嵌套</p><img src="/images/postgresql6.png" style="zoom:50%;" /><p>默认情况下，新创建的数据库有一个 <code>public</code> 的模式，但可以添加任何其他模式，并且 <code>public</code> 模式不是必需的</p><h3 id="Schema使用"><a href="#Schema使用" class="headerlink" title="Schema使用"></a>Schema使用</h3><p>在 SQL 中需要在表名前添加 <code>schema</code> 前缀，如不添加则默认是 <code>public</code> 模式，或使用 <code>search_path</code> 指定 <code>schema</code></p><img src="/images/postgresql7.png" style="zoom: 50%;" /><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>PG 支持非常丰富的数据类型，下面是普通数据类型，同时下面所有普通数据类型都支持数组类型</p><table><thead><tr><th align="left">名字</th><th align="left">别名(曾经使用过)</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">bigint</td><td align="left">int8</td><td align="left">有符号的8字节整数</td></tr><tr><td align="left">bigserial</td><td align="left">serial8</td><td align="left">自动增长的8字节整数</td></tr><tr><td align="left">bit [ (<em><strong>n</strong></em>) ]</td><td align="left"></td><td align="left">定长位串</td></tr><tr><td align="left">bit varying [ (<em><strong>n</strong></em>) ]</td><td align="left">varbit [ (<em><strong>n</strong></em>) ]</td><td align="left">变长位串</td></tr><tr><td align="left">boolean</td><td align="left">bool</td><td align="left">逻辑布尔值（真/假）</td></tr><tr><td align="left">box</td><td align="left"></td><td align="left">平面上的普通方框</td></tr><tr><td align="left">bytea</td><td align="left"></td><td align="left">二进制数据（“字节数组”）</td></tr><tr><td align="left">character [ (<em><strong>n</strong></em>) ]</td><td align="left">char [ (<em><strong>n</strong></em>) ]</td><td align="left">定长字符串</td></tr><tr><td align="left">character varying [ (<em><strong>n</strong></em>) ]</td><td align="left">varchar [ (<em><strong>n</strong></em>) ]</td><td align="left">变长字符串</td></tr><tr><td align="left">cidr</td><td align="left"></td><td align="left">IPv4或IPv6网络地址</td></tr><tr><td align="left">circle</td><td align="left"></td><td align="left">平面上的圆</td></tr><tr><td align="left">date</td><td align="left"></td><td align="left">日历日期（年、月、日）</td></tr><tr><td align="left">double precision</td><td align="left">float8</td><td align="left">双精度浮点数（8字节）</td></tr><tr><td align="left">inet</td><td align="left"></td><td align="left">IPv4或IPv6主机地址</td></tr><tr><td align="left">integer</td><td align="left">int, int4</td><td align="left">有符号4字节整数</td></tr><tr><td align="left">interval [ <em><strong>fields</strong></em> ] [ (<em><strong>p</strong></em>) ]</td><td align="left"></td><td align="left">时间段</td></tr><tr><td align="left">json</td><td align="left"></td><td align="left">文本 JSON 数据</td></tr><tr><td align="left">jsonb</td><td align="left"></td><td align="left">二进制 JSON 数据，已分解</td></tr><tr><td align="left">line</td><td align="left"></td><td align="left">平面上的无限长的线</td></tr><tr><td align="left">lseg</td><td align="left"></td><td align="left">平面上的线段</td></tr><tr><td align="left">macaddr</td><td align="left"></td><td align="left">MAC（Media Access Control）地址</td></tr><tr><td align="left">macaddr8</td><td align="left"></td><td align="left">MAC（Media Access Control）地址（EUI-64格式）</td></tr><tr><td align="left">money</td><td align="left"></td><td align="left">货币数量</td></tr><tr><td align="left">numeric [ (<em><strong>p</strong></em>, <em><strong>s</strong></em>) ]</td><td align="left">decimal [ (<em><strong>p</strong></em>, <em><strong>s</strong></em>) ]</td><td align="left">可选择精度的精确数字</td></tr><tr><td align="left">path</td><td align="left"></td><td align="left">平面上的几何路径</td></tr><tr><td align="left">pg_lsn</td><td align="left"></td><td align="left">PostgreSQL日志序列号</td></tr><tr><td align="left">pg_snapshot</td><td align="left"></td><td align="left">用户级事务ID快照</td></tr><tr><td align="left">point</td><td align="left"></td><td align="left">平面上的几何点</td></tr><tr><td align="left">polygon</td><td align="left"></td><td align="left">平面上的封闭几何路径</td></tr><tr><td align="left">real</td><td align="left">float4</td><td align="left">单精度浮点数（4字节）</td></tr><tr><td align="left">smallint</td><td align="left">int2</td><td align="left">有符号2字节整数</td></tr><tr><td align="left">smallserial</td><td align="left">serial2</td><td align="left">自动增长的2字节整数</td></tr><tr><td align="left">serial</td><td align="left">serial4</td><td align="left">自动增长的4字节整数</td></tr><tr><td align="left">text</td><td align="left"></td><td align="left">变长字符串</td></tr><tr><td align="left">time [ (<em><strong>p</strong></em>) ] [ without time zone ]</td><td align="left"></td><td align="left">一天中的时间（无时区）</td></tr><tr><td align="left">time [ (<em><strong>p</strong></em>) ] with time zone</td><td align="left">timetz</td><td align="left">一天中的时间，包括时区</td></tr><tr><td align="left">timestamp [ (<em><strong>p</strong></em>) ] [ without time zone ]</td><td align="left"></td><td align="left">日期和时间（无时区）</td></tr><tr><td align="left">timestamp [ (<em><strong>p</strong></em>) ] with time zone</td><td align="left">timestamptz</td><td align="left">日期和时间，包括时区</td></tr><tr><td align="left">tsquery</td><td align="left"></td><td align="left">文本搜索查询</td></tr><tr><td align="left">tsvector</td><td align="left"></td><td align="left">文本搜索文档</td></tr><tr><td align="left">txid_snapshot</td><td align="left"></td><td align="left">用户级别事务ID快照(废弃; 参见 pg_snapshot)</td></tr><tr><td align="left">uuid</td><td align="left"></td><td align="left">通用唯一标识码</td></tr><tr><td align="left">xml</td><td align="left"></td><td align="left">XML数据</td></tr></tbody></table><p>PG 还可以自定义数据类型，用户可以使用<a href="http://www.postgres.cn/docs/13/sql-createtype.html">CREATE TYPE</a>命令为 <code>PostgreSQL</code>增加新的数据类型</p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h3><p>PG 提供了多种索引类型： <code>B-tree</code>、<code>Hash</code>、<code>GiST</code>、<code>SP-GiST</code> 、<code>GIN</code> 和 <code>BRIN</code></p><ul><li><p><code>B-tree</code> 可以在可排序数据上的处理等值和范围查询</p></li><li><p><code>Hash</code> 索引只能处理简单等值比较</p></li><li><p><code>GiST</code> 索引并不是一种单独的索引，是一个通用的索引接口</p></li><li><p><code>SP-GiST</code> 类似 <code>GiST</code>，是一个通用的索引接口，但是 <code>SP-GIST</code> 使用了空间分区的方法，使得 <code>SP-GiST</code> 可以更好的支持非平衡数据结构，例如四叉树、k-d树和radix树</p></li><li><p><code>GIN</code> 索引是“倒排索引”，它适合于包含多个组成值的数据值，例如数组</p></li><li><p><code>BRIN</code> 索引是块级索引，有别于 <code>B-TREE</code> 等索引，BRIN 记录并不是以行号为单位记录索引明细，而是记录每个数据块或者每段连续的数据块的统计信息</p><p>因此 <code>BRIN</code> 索引空间占用特别的小，对数据写入、更新、删除的影响也很小</p><p>被索引列的值与物理存储相关性很强时，BRIN 索引的效果非常的好。例如时序数据，在时间或序列字段创建 <code>BRIN</code> 索引，进行等值、范围查询时效果很棒</p></li></ul><p>用户可以通过索引接口自定义索引</p><p>所以除上面的内置索引外，还有许多自定义索引，可以根据需求安装其他索引</p><h3 id="部分索引"><a href="#部分索引" class="headerlink" title="部分索引"></a>部分索引</h3><p>部分索引 又习惯称 <code>条件索引</code></p><p>一个条件索引是建立在表的一个子集上，而该子集则由一个条件表达式定义</p><p>而索引中只包含那些符合条件表达式的行。条件索引是一种专门的特性，但在很多种情况下它们也很有用</p><p>使用场景：</p><p>多租户的场景下，数据存在一个表中，不同租户存储的数据不同，使用场景不同，可以根据不同租户场景建立条件索引</p><h3 id="表达式索引"><a href="#表达式索引" class="headerlink" title="表达式索引"></a>表达式索引</h3><p>部分索引 又习惯称 <code>函数索引</code></p><p>一个索引列并不一定是底层表的一个列，也可以是从表的一列或多列计算而来的一个函数或者标量表达式</p><h2 id="过程语言"><a href="#过程语言" class="headerlink" title="过程语言"></a>过程语言</h2><blockquote><p>Procedural Language（过程语言）简称 PL</p></blockquote><p>几乎每个关系型数据库都有自己的PL实现，比如 Oracle 的 PL/SQL、SQL Server 的 T-SQL，而在 PG 中，提供的就是 PL/pgSQL</p><p>但是 PG 的 PL 支持多种语言，如下：</p><ul><li>PL/Java</li><li>PL/PHP</li><li>PL/Perl</li><li>PL/Python</li><li>PL/V8(JavaScript)</li></ul><h2 id="PostGIS"><a href="#PostGIS" class="headerlink" title="PostGIS"></a>PostGIS</h2><blockquote><p>官网：<a href="https://postgis.net/">https://postgis.net/</a></p></blockquote><h3 id="PostGIS介绍"><a href="#PostGIS介绍" class="headerlink" title="PostGIS介绍"></a>PostGIS介绍</h3><p><code>PostGIS</code> 是 PG 的一个空间对象扩展模块</p><p><code>PostGIS</code> 通过向 PG 添加对空间数据类型、空间索引和空间函数的支持，使其成为一个真正的大型空间数据库</p><p><code>PostGIS</code> 使 PG 目前成为开源空间信息软件领域性能最优的数据库</p><h3 id="PostGIS特性与功能"><a href="#PostGIS特性与功能" class="headerlink" title="PostGIS特性与功能"></a>PostGIS特性与功能</h3><ul><li><p><code>PostGIS</code> 支持所有的空间数据类型</p><p>这些类型包括：点（POINT）、线（LINESTRING）、多边形（POLYGON）、多点 （MULTIPOINT）、多线（MULTILINESTRING）、多多边形（MULTIPOLYGON）和集合对象集 （GEOMETRYCOLLECTION）等</p></li><li><p><code>PostGIS</code> 支持所有的对象表达方法</p><p>比如WKT和WKB。</p></li><li><p><code>PostGIS</code> 支持所有的数据存取和构造方法</p><p>如GeomFromText()、AsBinary()，以及GeometryN()等</p></li><li><p><code>PostGIS</code> 提供简单的空间分析函数</p><p>如Area和Length</p><p>同时也提供其他一些具有复杂分析功能的函数</p><p>比如Distance。</p></li><li><p><code>PostGIS</code> 提供了对于元数据的支持</p><p>如GEOMETRY_COLUMNS和SPATIAL_REF_SYS</p><p>同时，PostGIS也提供了相应的支持函数</p><p>如AddGeometryColumn和DropGeometryColumn。</p></li><li><p><code>PostGIS</code> 提供了一系列的二元谓词（如Contains、Within、Overlaps和Touches）用于检测空间对象之间的空间关系，同时返回布尔值来表征对象之间符合这个关系</p></li><li><p><code>PostGIS</code> 提供了空间操作符（如Union和Difference）用于空间数据操作</p><p>比如，Union操作符融合多边形之间的边界。两个交迭的多边形通过Union运算就会形成一个新的多边形，这个新的多边形的边界为两个多边形中最大边界</p></li><li><p>数据库坐标变换</p></li><li><p>球体长度运算</p></li><li><p>三维的几何类型</p></li><li><p>空间聚集函数</p></li><li><p>栅格数据类型</p></li><li><p>……</p></li></ul><p>PostGIS 的功能非常强大，PG 有目前的影响力 PostGIS 功不可没~</p><h1 id="PG的特殊能力"><a href="#PG的特殊能力" class="headerlink" title="PG的特殊能力"></a>PG的特殊能力</h1><h2 id="用户自定义对象"><a href="#用户自定义对象" class="headerlink" title="用户自定义对象"></a>用户自定义对象</h2><p>用户可以创建数据库中几乎所有对象的新类型，包括但不限于：</p><ul><li>自定义数据类型</li><li>自定义类型转换</li><li>自定义操作符</li><li>自定义函数，包括聚合函数和窗口函数</li><li>自定义索引</li><li>自定义过程语言</li></ul><h2 id="窗口函数"><a href="#窗口函数" class="headerlink" title="窗口函数"></a>窗口函数</h2><p>一个窗口函数在一系列与当前行有某种关联的表行上执行一种计算。这与一个聚集函数所完成的计算有可比之处。但是窗口函数并不会使多行被聚集成一个单独的输出行，这与通常的非窗口聚集函数不同。取而代之，行保留它们独立的标识。在这些现象背后，窗口函数可以访问的不仅仅是查询结果的当前行。</p><ol><li>可以访问与当前记录相关的多行记录；</li><li>不会使多行聚集成一行， 与聚集函数的区别；</li></ol><p>例如结合窗口函数得到总行数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">select * from testtable;</span><br><span class="line"> id | value</span><br><span class="line">----+-------</span><br><span class="line"> <span class="number">1</span> | <span class="number">1</span></span><br><span class="line"> <span class="number">2</span> | <span class="number">2</span></span><br><span class="line"> <span class="number">3</span> | <span class="number">3</span></span><br><span class="line"> <span class="number">4</span> | <span class="number">4</span></span><br><span class="line"> <span class="number">5</span> | <span class="number">5</span></span><br><span class="line"> <span class="number">6</span> | <span class="number">6</span></span><br><span class="line"> <span class="number">7</span> | <span class="number">7</span></span><br><span class="line"> <span class="number">8</span> | <span class="number">8</span></span><br><span class="line"> <span class="number">9</span> | <span class="number">9</span></span><br><span class="line"> <span class="number">10</span> | <span class="number">10</span></span><br><span class="line">(<span class="number">10</span> rows)</span><br><span class="line">select id,count(*) over () from testtable where id &lt; <span class="number">9</span> limit <span class="number">3</span>;</span><br><span class="line"> id | count</span><br><span class="line">----+-------</span><br><span class="line"> <span class="number">1</span> | <span class="number">8</span></span><br><span class="line"> <span class="number">2</span> | <span class="number">8</span></span><br><span class="line"> <span class="number">3</span> | <span class="number">8</span></span><br><span class="line">即，count over会在limit 和 offset之前计算，结果就是总行数。</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2><blockquote><p>PG 还有许多特殊的能力，只有想不到的，没有做不到的</p></blockquote><ul><li><p>表继承</p></li><li><p>触发器不光可以拦截 DML 还可以拦截 DDL 语句</p></li><li><p>时序数据支持</p></li><li><p>分区表</p></li><li><p>外部数据源FDW，PG 中可以引用多种外部数据，包括MySQL、Oracle等主流关系型数据库，甚至还支持Redis、MongoDB等非关系型数据库</p></li><li><p>……</p></li></ul><h1 id="PG、MySQL对比"><a href="#PG、MySQL对比" class="headerlink" title="PG、MySQL对比"></a>PG、MySQL对比</h1><h2 id="数据表存储结构对比"><a href="#数据表存储结构对比" class="headerlink" title="数据表存储结构对比"></a>数据表存储结构对比</h2><p>堆表(heap table）和索引组织表（Index Oragnization Table，简称IOT)是两种数据表的存储结构</p><p><strong>PG 中的表是堆表。MySQL Innodb引擎中的表是索引组织表</strong></p><ul><li><p>堆表</p><p>堆表的特点就是索引和数据分开存储</p><p>表数据行在堆中存储，没有任何特定顺序，向一个全新的没有做过更新和删除的堆中插入一行时候，总是 append 到堆表文件的最后一页当中。因为不用考虑排序，所以插入速度会比较快。</p><p>索引存储在索引里，所有索引都是二级索引，或叫辅助索引。所以主键索引也是二级索引，没有完整记录，区别只有唯一或非唯一</p><p><strong>优点：</strong>写入速度快、辅助索引查询较快、全表扫描快</p><p><strong>缺点：</strong>磁盘空间消耗较大、主键查询较慢，需要先按主键索引找到数据的物理位置、</p></li><li><p>索引组织表</p><p>索引组织表特点是数据和主键索引一起存储</p><p>数据存储在聚簇索引中，或者说，数据按照主键的顺序来组织数据，两者合二为一。主键索引，叶子节点存放整行数据。其他索引称为辅助索引(二级索引），叶子节点存放键值和主键值</p><p><strong>优点：</strong>主键查询比较快、比较节约磁盘、更新效率更高</p><p><strong>缺点：</strong>二级索引查询慢，需要回表</p></li></ul><h2 id="MVCC对比"><a href="#MVCC对比" class="headerlink" title="MVCC对比"></a>MVCC对比</h2><p>MVCC的两种实现方法：</p><ol><li><p>当写入新数据时，把原有数据转移到一个单独的地方，如undo段中，其他人读数据时，会读取undo中的旧数据</p></li><li><p>当写入新数据时，原有数据不删除，而是把新数据插入，在不同版本的原有数据不需要时，垃圾回收器将回收这些过期的数据</p></li></ol><p>MySQL：</p><p>MySQL采用的就是第一种方式，详细不在说明</p><p>PG：</p><p>PG 采用的第二种方式，数据文件中存放着每一逻辑行的多个版本，问题随之而来，表空间会非常容易膨胀</p><p>为了解决表空间膨胀的问题，PG 采用 <a href="http://postgres.cn/docs/13/sql-vacuum.html">VACUUM</a> 方式，来回收历史数据，且需要定期手动进行 VACUUM</p><h2 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h2><p>任何系统都有它的性能极限，在高并发读写，负载逼近极限下，PG的性能指标仍可以维持双曲线甚至对数曲线，到顶峰之后不再下降，而 MySQL 明显出现一个波峰后下滑（5.5版本之后，在企业级版本中有个插件可以改善很多，不过需要付费）</p><h2 id="其他对比"><a href="#其他对比" class="headerlink" title="其他对比"></a>其他对比</h2><table><thead><tr><th align="left">特性</th><th align="left">PG</th><th align="left">MySQL</th></tr></thead><tbody><tr><td align="left">口号性特点</td><td align="left">最先进的开源数据库</td><td align="left">最流行的开源数据库</td></tr><tr><td align="left">SQL编程能力</td><td align="left">强大的SQL能力，包括丰富的统计函数和统计分析，对BI 有很好的支持</td><td align="left">没有强大的统计功能支持</td></tr><tr><td align="left">数据类型</td><td align="left">丰富的数据类型支持，包括地理信息、几何图形、 json、数组等，json也可以建立索引</td><td align="left">在地理信息支持度上不如PG，不支持几何图形等数据 类型</td></tr><tr><td align="left">事务能力</td><td align="left">完整的ACID事务支持</td><td align="left">不是完整的支持ACID事务特性</td></tr><tr><td align="left">join</td><td align="left">支持nested-loop, sort-merge, hash三种类型</td><td align="left">只支持nested-loop</td></tr><tr><td align="left">Text类型</td><td align="left">没有长度限制，可以直接访问，可以索引，可以全文索 引</td><td align="left">有长度限制</td></tr><tr><td align="left">复杂查询</td><td align="left">支持窗口函数，支持递归，支持with语句</td><td align="left">不支持窗口函数、递归等</td></tr><tr><td align="left">索引</td><td align="left">多种索引类型，包括b-tree，hash，gin，gist等，可以 对模糊查询、正则表达式、地理信息系统等建立索引</td><td align="left">主要是b-tree索引</td></tr><tr><td align="left">数据复制</td><td align="left">同步，异步，半同步复制，以及基于日志逻辑复制，可以实现表级别的订阅和发布</td><td align="left">只支持异步复制</td></tr><tr><td align="left">查询优化器</td><td align="left">功能更强大，对子查询的支持更高效</td><td align="left">子查询效率不高</td></tr><tr><td align="left">7*24</td><td align="left">隔一段时间需要进行VACUUM</td><td align="left">适用7*24</td></tr><tr><td align="left">性能和适用场景</td><td align="left">复杂查询</td><td align="left">简单业务场景，更高的TPS</td></tr><tr><td align="left">大小写</td><td align="left">大小写敏感</td><td align="left">大小写不敏感</td></tr><tr><td align="left">行大小限制</td><td align="left">无限制</td><td align="left">65535</td></tr></tbody></table><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><p>官方文档</p><p><a href="https://www.postgresql.org/">https://www.postgresql.org/</a></p></li><li><p>PG中文社区</p><p><a href="http://www.postgres.cn/v2/home">http://www.postgres.cn/v2/home</a></p></li><li><p>PG官方客户端工具</p><p><a href="https://www.pgadmin.org/">https://www.pgadmin.org/</a></p></li><li><p>PG相关高质量博客</p><p><a href="https://postgres.fun/">https://postgres.fun/</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/postgresql0.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;关于PostgreSQL&quot;&gt;&lt;a href=&quot;#关于PostgreSQL&quot; class=&quot;headerlink&quot; title=&quot;关于PostgreSQL&quot;&gt;&lt;/a&gt;关于Postg</summary>
      
    
    
    
    <category term="DB" scheme="http://yoursite.com/categories/DB/"/>
    
    
    <category term="DB" scheme="http://yoursite.com/tags/DB/"/>
    
    <category term="PostgreSQL" scheme="http://yoursite.com/tags/PostgreSQL/"/>
    
  </entry>
  
  <entry>
    <title>金字塔原理</title>
    <link href="http://yoursite.com/2021/09/24/%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2021/09/24/%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%86/</id>
    <published>2021-09-24T08:22:37.000Z</published>
    <updated>2021-11-06T05:32:56.327Z</updated>
    
    <content type="html"><![CDATA[<h2 id="结构思考力三层次模型"><a href="#结构思考力三层次模型" class="headerlink" title="结构思考力三层次模型"></a>结构思考力三层次模型</h2><h3 id="三层模型"><a href="#三层模型" class="headerlink" title="三层模型"></a>三层模型</h3><p>理解 -&gt; 重构 -&gt; 呈现</p><p><img src="/images/%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%860.png"></p><h3 id="模型目标"><a href="#模型目标" class="headerlink" title="模型目标"></a>模型目标</h3><p>隐形思维显性化 -&gt; 显性思维结构化 -&gt; 结构思维形象化</p><ul><li>隐形思维显性化：要提高自己的思考，首先要看到它</li><li>显性思维结构化：看到之后发现不清晰，需要结构化</li><li>结构思维形象化：结构化之后还需要把它传递出去，需要形象化的表达</li></ul><h3 id="金字塔结构"><a href="#金字塔结构" class="headerlink" title="金字塔结构"></a>金字塔结构</h3><p><img src="/images/%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%861.png"></p><blockquote><p>结构化思维是一种“从无序到有序”的思考过程</p><p>需要建立一个“先总后分”的思维方式。先找到解决问题的关键要点，然后再深入分析</p></blockquote><h2 id="理解：隐形思维显性化"><a href="#理解：隐形思维显性化" class="headerlink" title="理解：隐形思维显性化"></a>理解：隐形思维显性化</h2><h3 id="概况全文的“万能公式”"><a href="#概况全文的“万能公式”" class="headerlink" title="概况全文的“万能公式”"></a>概况全文的“万能公式”</h3><blockquote><p><code>在___的基础上，</code></p><p><code>从__，__，__N个方面，</code></p><p><code>说明了_____________。</code></p></blockquote><h3 id="结构思考力识别概况技术"><a href="#结构思考力识别概况技术" class="headerlink" title="结构思考力识别概况技术"></a>结构思考力识别概况技术</h3><blockquote><p>识别 -&gt; 判断 -&gt; 概况</p></blockquote><p><img src="/images/%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%862.png"></p><h3 id="隐形思维显性化前提"><a href="#隐形思维显性化前提" class="headerlink" title="隐形思维显性化前提"></a>隐形思维显性化前提</h3><p>隐形思维显性化的前提———有审视问题的坐标系</p><p><img src="/images/%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%863.png"></p><ul><li>审视问题的坐标系：<blockquote><p>这个事情有没有证据和理由支撑？</p><p>这个理由/逻辑是否能够推出结论？</p><p>其中的证据/事实是否能有效支撑理由？</p><p>是否存在隐藏或模糊不利的证据/事实？</p></blockquote></li></ul><h2 id="重构：显性思维结构化"><a href="#重构：显性思维结构化" class="headerlink" title="重构：显性思维结构化"></a>重构：显性思维结构化</h2><h3 id="重构四原则"><a href="#重构四原则" class="headerlink" title="重构四原则"></a>重构四原则</h3><ul><li><p>论-结论先行</p><blockquote><p>一段表达有一个核心观点，最好放在开头</p></blockquote></li><li><p>证-以上统下</p><blockquote><p>任何一层的论点，是下一层思想的概括</p></blockquote></li><li><p>类-归类分组</p><blockquote><p>每一组思想属于同一个范畴</p></blockquote></li><li><p>比-逻辑递进</p><blockquote><p>每一组思想按照一定的逻辑顺序排列</p></blockquote></li></ul><h3 id="论-结论先行"><a href="#论-结论先行" class="headerlink" title="论-结论先行"></a>论-结论先行</h3><p>结论先行可以提升我们的表达效率，让人快速理解你的核心意思。结论先行的难点不是先行，而是如何得出结论，需要反复联系</p><p><img src="/images/%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%864.png"></p><h3 id="证-以上统下"><a href="#证-以上统下" class="headerlink" title="证-以上统下"></a>证-以上统下</h3><p>上有结论，下有理由，结论概括理由，理由支撑结论，上下对应</p><p><img src="/images/%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%865.png"></p><h3 id="类-归类分组"><a href="#类-归类分组" class="headerlink" title="类-归类分组"></a>类-归类分组</h3><blockquote><p>人类大脑一次性接收的信息量是有范围的，这个范围有两个说法：5+-2 和 7+-2，不管是哪个说法，7都是一个临界值，当超过7时都会对记忆造成负担，所以在写方案时最好不要超过7条</p></blockquote><blockquote><p>而很多领导讲话都喜欢讲3点，理由有</p><ol><li>好记</li><li>对方更容易倾听</li><li>具有说服力；同时在物理结构中，3是稳定结构</li></ol><p>但是3点要能把事情说轻，说全，而这依赖 归类分组</p></blockquote><h4 id="MECE原则"><a href="#MECE原则" class="headerlink" title="MECE原则"></a>MECE原则</h4><blockquote><p>归类分组标准采用 MECE原则</p></blockquote><p>相互独立、完全穷尽</p><p>分类时不能有交叉、更不能有遗漏，不重不漏</p><p><img src="/images/%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%866.png"></p><h3 id="比-逻辑递进"><a href="#比-逻辑递进" class="headerlink" title="比-逻辑递进"></a>比-逻辑递进</h3><p>三种顺序</p><ul><li>时间顺序</li><li>结构顺序</li><li>重要性顺序</li></ul><p><strong>在同一个层级、同一个分支，必须使用同一种逻辑顺序</strong></p><p><img src="/images/%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%867.png"></p><h2 id="呈现：结构思维形象化"><a href="#呈现：结构思维形象化" class="headerlink" title="呈现：结构思维形象化"></a>呈现：结构思维形象化</h2><blockquote><p>形象化表达是结构化思考最有力的输出方式，结构化思考是形象化表达的基础</p></blockquote><h3 id="结构罗盘"><a href="#结构罗盘" class="headerlink" title="结构罗盘"></a>结构罗盘</h3><blockquote><p>形象化表达工具——结构罗盘</p></blockquote><blockquote><p>“配”关系 -&gt; “得”图示 -&gt; “上”包装</p></blockquote><p><img src="/images/%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%868.png"></p><ul><li>配关系：确定关系结构图下的一个分支的要素之间是什么关系</li><li>得图示：根据关系选择不同图示</li><li>上包装：对观点进行高度浓缩提炼，变得更加简洁、明了、容易记忆，及所谓“卖点包装”</li></ul><h3 id="配关系"><a href="#配关系" class="headerlink" title="配关系"></a>配关系</h3><p>四种模式，十六种关系</p><p>根据关系分支下的要素判断属于哪一种模式中的哪一种关系</p><p><img src="/images/%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%869.png"></p><h3 id="得图示"><a href="#得图示" class="headerlink" title="得图示"></a>得图示</h3><h3 id="上包装"><a href="#上包装" class="headerlink" title="上包装"></a>上包装</h3><p>可以把观点凝练成一句口诀，既好记，又有高度，这种方法为“卖点包装”</p><p>可以根据四种包装方法来进行包装</p><ul><li>简化</li><li>类比</li><li>整合</li><li>引用</li></ul><p><img src="/images/%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%8610.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;结构思考力三层次模型&quot;&gt;&lt;a href=&quot;#结构思考力三层次模型&quot; class=&quot;headerlink&quot; title=&quot;结构思考力三层次模型&quot;&gt;&lt;/a&gt;结构思考力三层次模型&lt;/h2&gt;&lt;h3 id=&quot;三层模型&quot;&gt;&lt;a href=&quot;#三层模型&quot; class=&quot;head</summary>
      
    
    
    
    <category term="通用能力" scheme="http://yoursite.com/categories/%E9%80%9A%E7%94%A8%E8%83%BD%E5%8A%9B/"/>
    
    
    <category term="通用能力" scheme="http://yoursite.com/tags/%E9%80%9A%E7%94%A8%E8%83%BD%E5%8A%9B/"/>
    
  </entry>
  
  <entry>
    <title>单元测试-Spock</title>
    <link href="http://yoursite.com/2021/08/25/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-Spock/"/>
    <id>http://yoursite.com/2021/08/25/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-Spock/</id>
    <published>2021-08-25T03:22:37.000Z</published>
    <updated>2021-11-06T06:04:57.001Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>单元测试的重要性不言而喻，但在实际开发中单元测试往往都是缺失的，原因有很多，其中比较重要的一点是工期短、写单测耗时长</p><p>针对这种问题，为了提高写单测的效率，推荐 Spock 测试框架，改善单测体验、解放生产力~</p><h1 id="Spock是什么"><a href="#Spock是什么" class="headerlink" title="Spock是什么"></a>Spock是什么</h1><p>官网：<a href="https://spockframework.org/">https://spockframework.org/</a></p><h2 id="Spock简介"><a href="#Spock简介" class="headerlink" title="Spock简介"></a>Spock简介</h2><p>官方介绍：</p><blockquote><p>Spock is a testing and specification framework for Java and Groovy applications. What makes it stand out from the crowd is its beautiful and highly expressive specification language. Thanks to its JUnit runner, Spock is compatible with most IDEs, build tools, and continuous integration servers. Spock is inspired from JUnit, jMock, RSpec, Groovy, Scala, Vulcans, and other fascinating life forms.</p></blockquote><p>简单来说，<code>Spock</code> 是一个测试框架，有以下几个核心特点：</p><ul><li>可以应用于 <code>java</code> 或 <code>groovy</code> 应用的单元测试框架。</li><li>测试代码使用基于 <code>groovy</code> 语言扩展而成的规范说明语言（<code>specification language</code>）。</li><li>遵从 BDD（行为驱动开发）模式，有助于提升代码的质量。</li><li>通过 <code>junit runner</code> 调用测试，兼容绝大部分 <code>junit</code> 的运行场景（ide，构建工具，持续集成等）。</li><li>框架的设计思路参考了 <code>JUnit</code>，<code>jMock</code>，<code>RSpec</code>，<code>Groovy</code>，<code>Scala</code>，<code>Vulcans</code>……</li></ul><h2 id="与其他框架对比"><a href="#与其他框架对比" class="headerlink" title="与其他框架对比"></a>与其他框架对比</h2><p><img src="/images/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-Spock0.jpeg"></p><p><code>Spock</code> = 传统测试框架 + <code>Mock</code>+ <code>BDD</code> + 文档化</p><blockquote><p>代码规范化，结构层次清晰</p><p>简单易读、可维护性强</p><p>基于 <code>Groovy</code> 更快的写单侧</p><p>漂亮的参数化测试和异常测试<br><img src="/images/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-Spock1.png"></p></blockquote><p>缺点：</p><blockquote><p>偶尔有坑（版本不兼容等）</p><p>需要了解 <code>Groovy</code> 语言</p><p>与其它 java 测试框架风格相差比较大，需要适应</p></blockquote><p>而这些理由比起 <code>Spock</code> 提供的易于开发和维护的单元测试代码来说，是可以忽略的。。。</p><h1 id="Groovy"><a href="#Groovy" class="headerlink" title="Groovy"></a>Groovy</h1><p>使用 <code>Spock</code> 前先了解下 <code>Groovy</code></p><p>维基百科介绍：</p><blockquote><p>Groovy是Java平台上设计的面向对象编程语言。这门动态语言拥有类似Python、Ruby和Smalltalk中的一些特性，可以作为Java平台的脚本语言使用。</p></blockquote><p><code>Groovy</code> 的语法与 <code>Java</code> 非常相似，以至于多数的 <code>Java</code> 代码也是正确的 <code>Groovy</code> 代码。<code>Groovy</code> 代码动态的被编译器转换成 <code>Java</code> 字节码。由于其运行在JVM上的特性，<code>Groovy</code> 可以使用其他 <code>Java</code> 语言编写的库。</p><p>虽然需要了解 <code>Groovy</code>，但不用担心，<code>Groovy</code> 是一门比较轻量，学习门槛也比较低的语言，而且最重要的是 <code>Groovy</code> 支持 <code>Java</code> 语法，所以理论上使用纯 <code>Java</code> 写 <code>Groovy</code> 也是可以的~</p><p>而且熟悉使用 <code>Spock</code> 后，不仅提升了写单测的速度，还多学了一门脚本语言，两全其美~~</p><h2 id="Groovy-语法糖"><a href="#Groovy-语法糖" class="headerlink" title="Groovy 语法糖"></a>Groovy 语法糖</h2><p><img src="/images/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-Spock2.png"><br><img src="/images/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-Spock3.png"><br><img src="/images/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-Spock4.png"></p><blockquote><p>不用分号</p><p>可选择性使用 <code>return</code></p><p>默认采用 <code>public</code> 修饰符</p><p><code>==</code> 与 <code>equals</code></p></blockquote><p>更多语法参考推荐文档。。。</p><h2 id="Groovy-推荐文档"><a href="#Groovy-推荐文档" class="headerlink" title="Groovy 推荐文档"></a>Groovy 推荐文档</h2><p><a href="https://groovy-lang.org/documentation.html">https://groovy-lang.org/documentation.html</a></p><p><a href="https://sysgears.com/articles/groovy-differences-java/">https://sysgears.com/articles/groovy-differences-java/</a></p><p><a href="https://wiki.jikexueyuan.com/project/groovy-introduction/differences-with-java.html">https://wiki.jikexueyuan.com/project/groovy-introduction/differences-with-java.html</a></p><h1 id="使用Spock"><a href="#使用Spock" class="headerlink" title="使用Spock"></a>使用Spock</h1><blockquote><p>Spock Web Console</p><p><a href="https://meetspock.appspot.com/">https://meetspock.appspot.com/</a></p></blockquote><h2 id="使用姿势"><a href="#使用姿势" class="headerlink" title="使用姿势"></a>使用姿势</h2><ul><li><p>安装 IDE 插件</p><p><img src="/images/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-Spock5.png"></p></li><li><p>maven 引用</p><blockquote><p>建议使用 1.3-groovy-2.4 版本，其他版本可能与其他包有兼容问题</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.spockframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spock-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3-groovy-2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.spockframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spock-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3-groovy-2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建 Groovy 测试目录</p><p><img src="/images/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-Spock6.png"></p></li><li><p>编写测试代码</p><p><img src="/images/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-Spock7.png"></p></li></ul><p>创建测试类时可以这俩个，<code>Spock Specification</code> 会自动继承 <code>Specification</code>，<code>Groovy Class</code> 需要自己继承</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> spock.lang.Specification</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpockDemo</span> <span class="keyword">extends</span> <span class="title">Specification</span> </span>&#123; </span><br><span class="line">    def <span class="string">&quot;test&quot;</span>() &#123;</span><br><span class="line">        given: <span class="string">&quot;数据准备&quot;</span></span><br><span class="line">      def list = []</span><br><span class="line">        </span><br><span class="line">        when: <span class="string">&quot;执行需要测试的代码&quot;</span></span><br><span class="line">        list.add(<span class="string">&quot;test&quot;</span>)</span><br><span class="line"></span><br><span class="line">        then: <span class="string">&quot;验证执行结果&quot;</span></span><br><span class="line">        !list.empty </span><br><span class="line">        stack.size() == <span class="number">1</span>   </span><br><span class="line">    &#125;   </span><br><span class="line">    </span><br><span class="line">    def <span class="string">&quot;测试&quot;</span>() &#123;</span><br><span class="line">        expect:</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="集成-Spring"><a href="#集成-Spring" class="headerlink" title="集成 Spring"></a>集成 Spring</h2><p>和 Junit 集成的方式一样</p><ul><li><p>Spring</p><p><code>@ContextConfiguration(locations = &quot;classpath:spring-context.xml&quot;)</code></p></li><li><p>SpringBoot</p><p><code>@SpringBootTest</code></p></li></ul><h2 id="Spock中的概念"><a href="#Spock中的概念" class="headerlink" title="Spock中的概念"></a>Spock中的概念</h2><ul><li><p>Specification</p><p>在 <code>Spock</code> 中，待测系统的行为是由规格(specification) 所定义的。在使用 <code>Spock</code> 框架编写测试时，测试类需要继承自 <code>Specification</code> 类。</p></li><li><p>模板方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def setup() &#123;&#125;          &#x2F;&#x2F; run before every feature method</span><br><span class="line">def cleanup() &#123;&#125;        &#x2F;&#x2F; run after every feature method</span><br><span class="line">def setupSpec() &#123;&#125;     &#x2F;&#x2F; run before the first feature method</span><br><span class="line">def cleanupSpec() &#123;&#125;   &#x2F;&#x2F; run after the last feature method</span><br></pre></td></tr></table></figure><p>和 Junit 对比：</p><table><thead><tr><th>Spock</th><th>Junit</th></tr></thead><tbody><tr><td>setup()</td><td>@Before</td></tr><tr><td>cleanup()</td><td>@After</td></tr><tr><td>setupSpec()</td><td>@BeforeClass</td></tr><tr><td>cleanupSpec()</td><td>@AfterClass</td></tr></tbody></table></li><li><p>Feature methods</p><p>就是测试类中的测试方法，方法名可以是中文</p></li><li><p>blocks</p><p>每个测试方法又被划分为不同的 <code>block</code>，不同的 <code>block</code> 处于测试执行的不同阶段，在测试运行时，各个 <code>block</code> 按照不同的顺序和规则被执行，如下图：</p><p><img src="/images/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-Spock8.png"></p><blockquote><p><code>Spock</code> 定义了多种标签，去描述代码“应该做什么”，“输入条件是什么”，“输出是否符合预期”，从语义层面规范了代码的编写</p></blockquote><p><strong>setup</strong>：也可以写成 <code>given</code>，在这个 <code>block</code> 中会放置与这个测试方法相关的初始化程序，可选</p><p><strong>given</strong>：输入条件（前置参数），一般会在这个 <code>block</code> 中定义局部变量，<code>mock</code> 等，可选</p><p><strong>when</strong>、<code>then</code>：<code>when</code> 与 <code>then</code> 需要搭配使用，一起出现，在 <code>when</code> 中执行待测试的函数，在 <code>then</code> 中判断是否符合预期</p><p><strong>expect</strong>：可以看做精简版的 when+then</p><p><strong>and</strong>：衔接上个标签，补充的作用</p><p><strong>cleanup</strong>：退出前做一些清理工作，如关闭资源等</p><p><strong>where</strong>：做测试时最复杂的事情之一就是准备测试数据，尤其是要测试边界条件、测试异常分支等，这些都需要在测试之前规划好数据。但是传统的测试框架很难轻松的制造数据，要么依赖反复调用，要么使用其他丑陋的方式；在 <code>Spock</code> 中 <code>where</code> 完美解决了这个问题，<code>where</code> 可以说是 <code>Spock</code> 的核心，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* where 有两种写法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpockDemo</span> <span class="keyword">extends</span> <span class="title">Specification</span> </span>&#123;</span><br><span class="line">    def <span class="string">&quot;max&quot;</span>() &#123;</span><br><span class="line">        expect:</span><br><span class="line">        Math.max(a, b) == c</span><br><span class="line"></span><br><span class="line">        where: <span class="string">&quot;多个列使用 | 单竖线隔开，|| 双竖线区分输入和输出变量，即左边是输入值，右边是输出值&quot;</span></span><br><span class="line">        a | b || c</span><br><span class="line">        <span class="number">3</span> | <span class="number">5</span> || <span class="number">5</span></span><br><span class="line">        <span class="number">7</span> | <span class="number">0</span> || <span class="number">7</span></span><br><span class="line">        <span class="number">0</span> | <span class="number">0</span> || <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpockDemo</span> <span class="keyword">extends</span> <span class="title">Specification</span> </span>&#123;</span><br><span class="line">    def <span class="string">&quot;max&quot;</span>() &#123;</span><br><span class="line">        expect:</span><br><span class="line">        Math.max(a, b) == c</span><br><span class="line"></span><br><span class="line">        where:</span><br><span class="line">        a &lt;&lt; [<span class="number">3</span>, <span class="number">7</span>, <span class="number">0</span>]</span><br><span class="line">        b &lt;&lt; [<span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">        c &lt;&lt; [<span class="number">5</span>, <span class="number">7</span>, <span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><p>在 <code>then</code> 或 <code>expect</code> 中会默认 <code>assert</code> 所有返回值是 <code>boolean</code> 型的语句，所以在 <code>then</code> 和 <code>expect</code> 语句块中不需要写 <code>assert</code></p><p>如果要在其它地方增加断言，需要显式增加 <code>assert</code> 关键字，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  stack = <span class="keyword">new</span> Stack()</span><br><span class="line">  <span class="keyword">assert</span> stack.empty</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="with"><a href="#with" class="headerlink" title="with"></a>with</h3><p><code>with</code> 语句可以验证对象内部的多个属性是否符合预期值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">expect:</span><br><span class="line">with(response) &#123;</span><br><span class="line">  code == <span class="number">0</span></span><br><span class="line">  message == <span class="string">&quot;成功&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异常断言"><a href="#异常断言" class="headerlink" title="异常断言"></a>异常断言</h3><p>验证有没有抛出异常，可以用 <code>thrown()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def <span class="string">&quot;test&quot;</span>() &#123;</span><br><span class="line">  given:</span><br><span class="line">  def str = <span class="keyword">null</span></span><br><span class="line"></span><br><span class="line">  when:</span><br><span class="line">  str.add(<span class="string">&quot;test&quot;</span>)</span><br><span class="line"></span><br><span class="line">  then:</span><br><span class="line">  thrown(NullPointerException)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>要验证没有抛出某种异常，可以用 <code>notThrown()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def <span class="string">&quot;test&quot;</span>() &#123;</span><br><span class="line">  given:</span><br><span class="line">  def str = []</span><br><span class="line"></span><br><span class="line">  when:</span><br><span class="line">  str.add(<span class="string">&quot;test&quot;</span>)</span><br><span class="line"></span><br><span class="line">  then:</span><br><span class="line">  notThrown(NullPointerException)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Annotation"><a href="#Annotation" class="headerlink" title="Annotation"></a>Annotation</h2><table><thead><tr><th>注解</th><th>用途</th><th>样例</th></tr></thead><tbody><tr><td>Shared</td><td>在多个测试间共享变量</td><td>@Shared def h2 = new H2Database()</td></tr><tr><td>AutoCleanUp</td><td>测试结束后回收资源，不管是否发生异常等</td><td>@AutoCleanup(“shutdown”) def executor = new Executor()</td></tr><tr><td>Ignore</td><td>忽略这个测试</td><td></td></tr><tr><td>IgnoreIf</td><td>忽略满足条件的测试</td><td>@IgnoreIf(os.isWindows())</td></tr><tr><td>IgnoreRest</td><td>只运行这个测试</td><td></td></tr><tr><td>Requries</td><td>满足设定的条件才运行这个测试</td><td>@Requires({env.containsKey(“HASH_KEY_TO_AUTHENTICATE”)})</td></tr><tr><td>Unroll</td><td>配合数据表的时候，每行运行一个测试</td><td></td></tr><tr><td>FailsWith</td><td>运行测试必然抛出某个异常</td><td></td></tr><tr><td>Issue</td><td>指明这个测试对应某个issue</td><td>@Issue(“<a href="http://redmine.example.com/issues/2554&quot;">http://redmine.example.com/issues/2554&quot;</a>)</td></tr><tr><td>Timeout</td><td>如果运行时间超过某个阈值，则判定为失败</td><td>@Timeout(value = 5000, unit = TimeUnit.MILLISECONDS)</td></tr><tr><td>Title</td><td>设定一个更容易理解的标题名</td><td>@Title(”测试在》繁忙情况下》发红包”)</td></tr></tbody></table><h1 id="Mock"><a href="#Mock" class="headerlink" title="Mock"></a>Mock</h1><blockquote><p><code>Spock</code> 自带 <code>Mock</code> 功能，使用简单方便，同时也支持扩展第三方 <code>Mock</code> 框架，比如 <code>PowerMock</code></p></blockquote><h2 id="SpockMock"><a href="#SpockMock" class="headerlink" title="SpockMock"></a>SpockMock</h2><h3 id="Mock-1"><a href="#Mock-1" class="headerlink" title="Mock"></a>Mock</h3><p>创建一个假对象，验证是否执行了某些操作(在 <code>then</code> 或 <code>expect</code> 语句块中)</p><ul><li><p>创建一个 <code>Mock</code> 对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PublisherSpec</span> <span class="keyword">extends</span> <span class="title">Specification</span> </span>&#123;</span><br><span class="line">    Publisher publisher = <span class="keyword">new</span> Publisher()</span><br><span class="line">    <span class="comment">// def subscriber = Mock(Subscriber)</span></span><br><span class="line">    Subscriber subscriber = Mock()</span><br><span class="line">    <span class="comment">// def subscriber2 = Mock(Subscriber)</span></span><br><span class="line">    Subscriber subscriber2 = Mock()</span><br><span class="line"></span><br><span class="line">    <span class="function">def <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        publisher.subscribers.add(subscriber)</span><br><span class="line">        publisher.subscribers.add(subscriber2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>交互验证</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def <span class="string">&quot;should send messages to all subscribers&quot;</span>() &#123;</span><br><span class="line">    when:</span><br><span class="line">    publisher.send(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"></span><br><span class="line">    then:</span><br><span class="line">    <span class="number">1</span> * subscriber.receive(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">    <span class="number">1</span> * subscriber2.receive(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 publisher 调用 send 时，两个 subscriber 都应该被调用一次 receive(“hello”)</p></li><li><p>示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> * subscriber.receive(<span class="string">&quot;hello&quot;</span>)      <span class="comment">// exactly one call</span></span><br><span class="line"><span class="number">0</span> * subscriber.receive(<span class="string">&quot;hello&quot;</span>)      <span class="comment">// zero calls</span></span><br><span class="line">(<span class="number">1.</span><span class="number">.3</span>) * subscriber.receive(<span class="string">&quot;hello&quot;</span>) <span class="comment">// between one and three calls (inclusive)</span></span><br><span class="line">(<span class="number">1.</span>._) * subscriber.receive(<span class="string">&quot;hello&quot;</span>) <span class="comment">// at least one call</span></span><br><span class="line">(_.<span class="number">.3</span>) * subscriber.receive(<span class="string">&quot;hello&quot;</span>) <span class="comment">// at most three calls</span></span><br><span class="line">_ * subscriber.receive(<span class="string">&quot;hello&quot;</span>)      <span class="comment">// any number of calls, including zero</span></span><br><span class="line"><span class="number">1</span> * subscriber.receive(<span class="string">&quot;hello&quot;</span>)     <span class="comment">// an argument that is equal to the String &quot;hello&quot;</span></span><br><span class="line"><span class="number">1</span> * subscriber.receive(!<span class="string">&quot;hello&quot;</span>)    <span class="comment">// an argument that is unequal to the String &quot;hello&quot;</span></span><br><span class="line"><span class="number">1</span> * subscriber.receive()            <span class="comment">// the empty argument list (would never match in our example)</span></span><br><span class="line"><span class="number">1</span> * subscriber.receive(_)           <span class="comment">// any single argument (including null)</span></span><br><span class="line"><span class="number">1</span> * subscriber.receive(*_)          <span class="comment">// any argument list (including the empty argument list)</span></span><br><span class="line"><span class="number">1</span> * subscriber.receive(!<span class="keyword">null</span>)       <span class="comment">// any non-null argument</span></span><br><span class="line"><span class="number">1</span> * subscriber.receive(_ as String) <span class="comment">// any non-null argument that is-a String</span></span><br><span class="line"><span class="number">1</span> * subscriber.receive(&#123; it.size() &gt; <span class="number">3</span> &#125;) <span class="comment">// an argument that satisfies the given predicate</span></span><br><span class="line">                                          <span class="comment">// (here: message length is greater than 3)</span></span><br><span class="line"><span class="number">1</span> * subscriber._(*_)     <span class="comment">// any method on subscriber, with any argument list</span></span><br><span class="line"><span class="number">1</span> * subscriber._         <span class="comment">// shortcut for and preferred over the above</span></span><br><span class="line"><span class="number">1</span> * _._                  <span class="comment">// any method call on any mock object</span></span><br><span class="line"><span class="number">1</span> * _                    <span class="comment">// shortcut for and preferred over the above</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Stubbing"><a href="#Stubbing" class="headerlink" title="Stubbing"></a>Stubbing</h3><p>调用 <code>Mock</code> 对象的某个方法时返回特定的值</p><ul><li><p>调用返回指定值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subscriber.receive(_) &gt;&gt; <span class="string">&quot;ok&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>调用多次返回不同的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">subscriber.receive(_) &gt;&gt;&gt; [<span class="string">&quot;ok&quot;</span>, <span class="string">&quot;error&quot;</span>, <span class="string">&quot;error&quot;</span>, <span class="string">&quot;ok&quot;</span>]</span><br><span class="line">subscriber.receive(_) &gt;&gt; <span class="string">&quot;ok&quot;</span> &gt;&gt; <span class="string">&quot;error&quot;</span> &gt;&gt; <span class="string">&quot;error&quot;</span> &gt;&gt; <span class="string">&quot;ok&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>希望抛出异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subscriber.receive(_) &gt;&gt; &#123; <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">&quot;ouch&quot;</span>) &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Mock、Stubbing结合"><a href="#Mock、Stubbing结合" class="headerlink" title="Mock、Stubbing结合"></a>Mock、Stubbing结合</h3><p>如果既要判断某个 <code>mock</code> 对象的交互，又希望它返回值的话，可以结合 <code>mock</code> 和 <code>stub</code>，可以这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">then:</span><br><span class="line"><span class="number">1</span> * subscriber.receive(<span class="string">&quot;message1&quot;</span>) &gt;&gt; <span class="string">&quot;ok&quot;</span></span><br><span class="line"><span class="number">1</span> * subscriber.receive(<span class="string">&quot;message2&quot;</span>) &gt;&gt; <span class="string">&quot;fail&quot;</span></span><br></pre></td></tr></table></figure><p>一般使用 <code>Spock</code> 自带的 <code>Mock</code> 就够了，但是 <code>Spock</code> 的 <code>Mock</code> 也有着常见缺陷，既不能 <code>Mock</code> 私有方法和静态方法</p><p>针对这种情况，业界之前常见的是使用 <code>PowerMock</code> 来 <code>Mock</code>，但是 <code>PowerMock</code> 上手难度较高、且使用复杂</p><p>相比 <code>Spock</code> + <code>PowerMock</code>，推荐 <code>Spock</code> + <code>TestableMock</code> 来 <code>Mock</code>，快速上手、使用简单</p><h2 id="TestableMock"><a href="#TestableMock" class="headerlink" title="TestableMock"></a>TestableMock</h2><p><code>TestableMock</code>，阿里新一代测试工具，一款特立独行的轻量Mock工具。</p><p>官网：<a href="https://alibaba.github.io/testable-mock/#/">https://alibaba.github.io/testable-mock/#/</a></p><p>常见 Mock 工具对比：</p><table><thead><tr><th>工具</th><th>原理</th><th>最小Mock单元</th><th>对被Mock方法的限制</th><th>上手难度</th><th>IDE支持</th></tr></thead><tbody><tr><td>Mockito</td><td>动态代理</td><td>类</td><td>不能Mock私有/静态和构造方法</td><td>较容易</td><td>很好</td></tr><tr><td>Spock</td><td>动态代理</td><td>类</td><td>不能Mock私有/静态和构造方法</td><td>较复杂</td><td>一般</td></tr><tr><td>PowerMock</td><td>自定义类加载器</td><td>类</td><td>任何方法皆可</td><td>较复杂</td><td>较好</td></tr><tr><td>JMockit</td><td>运行时字节码修改</td><td>类</td><td>不能Mock构造方法(new操作符)</td><td>较复杂</td><td>一般</td></tr><tr><td>TestableMock</td><td>运行时字节码修改</td><td>方法</td><td>任何方法皆可</td><td>很容易</td><td>一般</td></tr></tbody></table><p>TestableMock 功能：</p><ul><li><a href="https://alibaba.github.io/testable-mock/#/zh-cn/doc/use-mock">快速Mock任意调用</a>：使被测类的任意方法调用快速替换为Mock方法，实现”指哪换哪”，解决传统Mock工具使用繁琐的问题</li><li><a href="https://alibaba.github.io/testable-mock/#/zh-cn/doc/private-accessor">访问被测类私有成员</a>：使单元测试能直接调用和访问被测类的私有成员，解决私有成员初始化和私有方法测试的问题</li><li><a href="https://alibaba.github.io/testable-mock/#/zh-cn/doc/omni-constructor">快速构造参数对象</a>：生成任意复杂嵌套的对象实例，并简化其内部成员赋值方式，解决被测方法参数初始化代码冗长的问题</li><li><a href="https://alibaba.github.io/testable-mock/#/zh-cn/doc/test-void-method">辅助测试void方法</a>：利用Mock校验器对方法的内部逻辑进行检查，解决无返回值方法难以实施单元测试的问题</li></ul><p>不足：</p><p>当前 <code>TestableMock</code> 的主要不足在于，编写 <code>Mock</code> 方法时 IDE 无法即时提示方法参数是否正确匹配。若发现匹配效果不符合预期，需要通过<a href="https://alibaba.github.io/testable-mock/#/zh-cn/doc/troubleshooting">自助问题排查</a>文档提供的方法在运行期进行校验</p><h1 id="推荐文档"><a href="#推荐文档" class="headerlink" title="推荐文档"></a>推荐文档</h1><ul><li><p>官方文档<br><a href="https://spockframework.org/spock/docs/2.0/all_in_one.html">https://spockframework.org/spock/docs/2.0/all_in_one.html</a></p></li><li><p>美团技术博客<br><a href="https://tech.meituan.com/2021/08/06/spock-practice-in-meituan.html">https://tech.meituan.com/2021/08/06/spock-practice-in-meituan.html</a></p></li><li><p>其他技术博客<br><a href="https://javakk.com/category/spock">https://javakk.com/category/spock</a></p></li><li><p>Java Testing with Spock<br><a href="https://github.com/kkapelon/java-testing-with-spock">https://github.com/kkapelon/java-testing-with-spock</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;单元测试的重要性不言而喻，但在实际开发中单元测试往往都是缺失的，原因有很多，其中比较重要的一点是工期短、写单测耗时长&lt;/p&gt;
&lt;p&gt;针对这种</summary>
      
    
    
    
    <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Code Review</title>
    <link href="http://yoursite.com/2021/06/19/Code%20Review/"/>
    <id>http://yoursite.com/2021/06/19/Code%20Review/</id>
    <published>2021-06-19T03:22:37.000Z</published>
    <updated>2021-11-06T06:03:09.657Z</updated>
    
    <content type="html"><![CDATA[<h2 id="认识-Code-Review"><a href="#认识-Code-Review" class="headerlink" title="认识 Code Review"></a>认识 Code Review</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>Code Review是一种用来确认方案设计和代码实现的质量保证机制，通过这个机制对代码、测试过程和注释进行检查，确保整体代码运行状况随着时间的推移而得到改善。</p><h3 id="目的和意义"><a href="#目的和意义" class="headerlink" title="目的和意义"></a>目的和意义</h3><ul><li>目的：代码质量、知识共享、团队规范</li><li>意义：<ul><li>查找系统和代码的缺陷，把控风险</li><li>保证代码整体健康度不会随时间的推移而降低</li><li>提高开发者自身水平</li></ul></li></ul><h3 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h3><p>常见的 Code Review 有下面几种方式</p><blockquote><p>结对编程(瞬时评审)</p></blockquote><ul><li>一对一的共同编程</li><li>场景：复杂的业务问题、或紧急问题的修复</li></ul><blockquote><p>即时代码评审(同步评审)</p></blockquote><ul><li>提交人给审核人讲解任务详情、改动等</li><li>场景：不清楚任务目标、或高级指导低级</li></ul><blockquote><p>工具支持的代码评审(异步评审)</p></blockquote><ul><li>和开发流集成，只有 Review 通过才能合并</li><li>默认的方式，也是最常用的</li></ul><blockquote><p>基于会议的代码评审(偶尔评审)</p></blockquote><ul><li>组织会议，团队多人共同评审</li><li>场景：大型、比较复杂的项目；有一定风险的项目；为了提高整体水平</li></ul><h3 id="不做-Code-Review-的典型场景"><a href="#不做-Code-Review-的典型场景" class="headerlink" title="不做 Code Review 的典型场景"></a>不做 Code Review 的典型场景</h3><ul><li>不认同，团队整体意识不到位</li><li>需求多，时间紧，疲于应付需求</li><li>技术水平不足，无法给出有效意见</li></ul><h3 id="Code-Review-常见问题"><a href="#Code-Review-常见问题" class="headerlink" title="Code Review 常见问题"></a>Code Review 常见问题</h3><blockquote><p>提交人</p></blockquote><ul><li>提交大量代码评审</li><li>发起评审前没有进行自测</li><li>不进行评审，直接上线</li><li>没有给评审人留够充裕的时间</li></ul><blockquote><p>评审人</p></blockquote><ul><li>Review 不仔细，产生低级的问题</li><li>对业务不熟悉，无法判断影响面</li><li>反馈时机长，不及时处理提交人提交的 Code Review</li></ul><blockquote><p>全体</p></blockquote><ul><li>没有规范的 Code Review 机制和自测机制</li></ul><h2 id="如何做好-Code-Review"><a href="#如何做好-Code-Review" class="headerlink" title="如何做好 Code Review"></a>如何做好 Code Review</h2><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>要避免 Code Review 流于形式，而避免流于形式的关键点则是 <strong>大家都有主观意愿，并且客观条件允许</strong></p><p>要有代码规范、Check list、总结优化、激励机制</p><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+-------+      +---------+      +---------+      +---------+      +-----+      +------------+</span><br><span class="line">| 定标准 | +--&gt; | 全员学习 | +--&gt; | 需求梳理  | +--&gt; | 代码评审 | +--&gt; | 讨论 | +--&gt; | 评审结果落地 |</span><br><span class="line">+-------+      +---------+      +---------+      +---------+      +-----+      +------------+ </span><br></pre></td></tr></table></figure><ol><li>定标准<ul><li>目的：有法可依、团队一致</li><li>内容：<ul><li>共识标准：权利责任标准、冲突处理标准、特例紧急case处理标准、检查单标准</li><li>提交人标准：发起时机标准、选择评审人标准、Commit 标准、代码标准、合并分支标准、处理评论标准</li><li>评审人标准：检查内容标准、可通过标准、评论标准、反馈周期标准</li></ul></li></ul></li><li>全员学习<ul><li>目的：统一思想、确认标准可落地</li></ul></li><li>需求梳理<ul><li>统一对需求理解，设计评审有理可依</li><li>内容：<ul><li>提交人要有基于需求的代码改动设计方案</li><li>评审人要有基于需求理解之下的代码改造意见</li></ul></li></ul></li><li>代码评审<ul><li>目的：实现正确的业务需求，代码长期的可维护性</li><li>内容：参照检查单（功能拆解；架构设计；代码逻辑；库表设计；编码风格；性能；等等）</li><li>工具：<a href="http://www.sonar.org.cn/">Sonar</a>、<a href="https://www.gerritcodereview.com/">Gerrit</a> 等工具</li></ul></li><li>讨论<ul><li>目的：达成共识，求同存异</li></ul></li><li>评审结果落地<ul><li>总结归纳，持续优化标准</li></ul></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Code Review 是提高代码质量、把控项目风险的一剂良药，同时也是提高个人水平的一个重要渠道。而长期维持良好的 Code Review 并不容易，但是良好的 Code Review 是个人和团队成功不可或缺的一环。</p><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><p>GoogleCR机制（原文）：<a href="https://google.github.io/eng-practices/review/reviewer/">https://google.github.io/eng-practices/review/reviewer/</a></p><p>GoogleCR机制（翻译版）：<a href="https://cloud.tencent.com/developer/article/1514271">https://cloud.tencent.com/developer/article/1514271</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;认识-Code-Review&quot;&gt;&lt;a href=&quot;#认识-Code-Review&quot; class=&quot;headerlink&quot; title=&quot;认识 Code Review&quot;&gt;&lt;/a&gt;认识 Code Review&lt;/h2&gt;&lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot;</summary>
      
    
    
    
    <category term="规范" scheme="http://yoursite.com/categories/%E8%A7%84%E8%8C%83/"/>
    
    
    <category term="规范" scheme="http://yoursite.com/tags/%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>Netty-BetyBuf</title>
    <link href="http://yoursite.com/2021/06/11/Netty-BetyBuf/"/>
    <id>http://yoursite.com/2021/06/11/Netty-BetyBuf/</id>
    <published>2021-06-11T07:55:37.000Z</published>
    <updated>2021-06-21T02:17:02.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>ByteBuf 是 Netty 中的数据交互单位，本质是一个 Byte 数组的缓冲区，有不同实现机制，首先看 ByteBuf 的数据结构</p></blockquote><h3 id="ByteBuf结构"><a href="#ByteBuf结构" class="headerlink" title="ByteBuf结构"></a>ByteBuf结构</h3><pre><code>+-------------------+------------------+------------------+| discardable bytes |  readable bytes  |  writable bytes  ||                   |     (CONTENT)    |                  |+-------------------+------------------+------------------+|                   |                  |                  |0      &lt;=      readerIndex   &lt;=   writerIndex    &lt;=    capacity</code></pre><p>ByteBuf 包括三部分，丢弃字节、可读字节、可写字节</p><p>通过两个指针，读指针（readerIndex）和写指针（writerIndex）来分成三部分，当 readerIndex = writerIndex 时不可读，当 writerIndex = capacity 时不可写。还有个参数 maxCapacity，当写入数据容量不足时会自动扩容，扩容的最大容量为 maxCapacity 值</p><h3 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h3><h4 id="容量API"><a href="#容量API" class="headerlink" title="容量API"></a>容量API</h4><ul><li><p><code>capacity()</code></p><p>表示 ByteBuf 的占用字节内存，包括丢弃字节、可读字节、可写字节，不同的底层实现机制有不同的计算方式</p></li><li><p><code>maxCapacity()</code>  </p><p>表示 ByteBuf 最大能够占用多少字节的内存</p></li><li><p><code>readableBytes()</code></p><p>ByteBuf 当前可读的字节数，它的值等于 writerIndex-readerIndex</p></li><li><p><code>isReadable()</code></p><p>返回是否可读，writerIndex = readerIndex 则不可读，返回 <code>false</code></p></li><li><p><code>writableBytes()</code></p><p>ByteBuf 当前可写的字节数，它的值等于 capacity-writerIndex</p></li><li><p><code>isWritable()</code></p><p>返回是否可写，capacity = writerIndex 则不可写</p></li><li><p><code>maxWritableBytes()</code></p><p>ByteBuf 可写的最大字节数，它的值等于 maxCapacity-writerIndex</p></li></ul><h4 id="指针相关API"><a href="#指针相关API" class="headerlink" title="指针相关API"></a>指针相关API</h4><ul><li><p><code>readerIndex()</code></p><p>返回当前读指针的 readerIndex</p></li><li><p><code>readerIndex(int)</code></p><p>设置读指针</p></li><li><p><code>writeIndex()</code></p><p>返回当前写指针的 writerIndex</p></li><li><p><code>writeIndex(int)</code></p><p>设置读指针</p></li><li><p><code>markReaderIndex()</code>、<code>markWriterIndex()</code></p><p>把当前的读、写指针保存起来</p></li><li><p><code>resetReaderIndex()</code>、<code>resetWriterIndex()</code></p><p>把当前的读、写指针恢复到之前保存的值</p></li></ul><h4 id="读写API"><a href="#读写API" class="headerlink" title="读写API"></a>读写API</h4><ul><li><p><code>writeBytes(byte[] src)</code></p><p>把字节数组 src 里面的数据全部写到 ByteBuf，src 字节数组大小的长度通常小于等于 <code>writableBytes()</code></p></li><li><p><code>readBytes(byte[] dst)</code></p><p>把 ByteBuf 里面的数据全部读取到 dst，这里 dst 字节数组的大小通常等于 <code>readableBytes()</code></p></li><li><p><code>writeByte(byte b)</code></p><p>表示往 ByteBuf 中写一个字节，类似还有 <code>writeBoolean()</code>、<code>writeChar()</code>、<code>writeShort()</code>、<code>writeInt()</code>、<code>writeLong()</code>、<code>writeFloat()</code>、<code>writeDouble()</code> </p></li><li><p><code>readByte()</code></p><p>表示从 ByteBuf 中读取一个字节，类似还有  <code>readBoolean()</code>、<code>readChar()</code>、<code>readShort()</code>、<code>readInt()</code>、<code>readLong()</code>、<code>readFloat()</code>、<code>readDouble()</code></p></li><li><p><code>setBytes()</code>、<code>setByte()</code></p><p>和 <code>writeBytes()</code> 等方法类似，但是 set 不会改变读写指针，而 write 会改变写指针</p></li><li><p><code>getBytes</code>、<code>getByte()</code></p><p>和 <code>readBytes()</code> 等方法类似，同样 get 不会改变读写指针，而 read 会改变读指针</p></li><li><p><code>retain()</code></p><p>将 BetyBuf 的引用计数加一</p></li><li><p><code>release()</code></p><p>将 ByteBuf 的引用计数减一，减完之后如果发现引用计数为0，则直接回收 ByteBuf 底层的内存</p></li></ul><blockquote><p>由于 Netty 使用了堆外内存，而堆外内存是不被 jvm 直接管理的，也就是说申请到的内存无法被垃圾回收器直接回收，所以需要我们手动回收。有点类似于c语言里面，申请到的内存必须手工释放，否则会造成内存泄漏。</p><p>Netty 的 ByteBuf 是通过引用计数的方式管理的，如果一个 ByteBuf 没有地方被引用到，需要回收底层内存。默认情况下，当创建完一个 ByteBuf，它的引用为1</p></blockquote><ul><li><p><code>slice()</code></p><p>从原始 ByteBuf 中截取一段，这段数据是从 readerIndex 到 writeIndex，同时，返回的新的 ByteBuf 的最大容量 maxCapacity 为原始 ByteBuf 的 <code>readableBytes()</code>；底层内存以及引用计数与原始的 ByteBuf 共享</p></li><li><p><code>duplicate()</code></p><p>把整个 ByteBuf 都截取出来，包括所有的指针信息。底层内存以及引用计数与原始的 ByteBuf 共享</p></li><li><p><code>copy()</code></p><p>从原始的 ByteBuf 中拷贝所有的信息，包括读写指针以及底层对应的数据，底层内存以及引用计数都独立，操作 ByteBuf 中的数据不会影响到原始的 ByteBuf </p></li></ul><blockquote><p>三个方法都会返回新的 ByteBuf 对象</p><p><code>slice()</code> 与 <code>duplicate()</code> 的相同点是：<strong>底层内存以及引用计数与原始的 ByteBuf 共享</strong>，也就是说经过 <code>slice()</code> 或者 <code>duplicate()</code> 返回的 ByteBuf 调用 write 系列方法都会影响到原始的 ByteBuf，但是它们都维持着与原始 ByteBuf 相同的内存引用计数和不同的读写指针 </p><p><code>slice()</code> 与 <code>duplicate()</code> 的不同点是：<code>slice()</code> 只截取从 readerIndex 到 writerIndex 之间的数据，它返回的 ByteBuf 的最大容量被限制到 原始 ByteBuf 的 <code>readableBytes()</code>, 而 <code>duplicate()</code> 是把整个 ByteBuf 都与原始的 ByteBuf 共享 </p><p><code>slice()</code> 和 <code>duplicate()</code> 不会改变 ByteBuf 的引用计数，所以原始的 ByteBuf 调用 <code>release()</code> 之后发现引用计数为零，就开始释放内存，调用这两个方法返回的 ByteBuf 也会被释放，这个时候如果再对它们进行读写，就会报错。因此，我们可以通过调用一次 <code>retain()</code> 方法 来增加引用，表示它们对应的底层的内存多了一次引用，引用计数为2，在释放内存的时候，需要调用两次 <code>release()</code> 方法，将引用计数降到零，才会释放内存</p><p><code>slice()</code> 、<code>duplicate()</code>、<code>copy()</code> 三个方法均维护着自己的读写指针，与原始的 ByteBuf 的读写指针无关，相互之间不受影响</p></blockquote><ul><li><p><code>retainedSlice()</code></p><p>截取内存片段的同时，增加内存的引用计数，等价于 <code>slice().retain()</code></p></li><li><p><code>retainedDuplicate()</code></p><p>也是截取内存片段的同时，增加内存的引用计数，等价于 <code>duplicate().retain()</code></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;ByteBuf 是 Netty 中的数据交互单位，本质是一个 Byte 数组的缓冲区，有不同实现机制，首先看 ByteBuf 的数据结构&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;ByteBuf结构&quot;&gt;&lt;a href=&quot;#ByteBuf结</summary>
      
    
    
    
    <category term="Netty" scheme="http://yoursite.com/categories/Netty/"/>
    
    
    <category term="Netty" scheme="http://yoursite.com/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot自动配置</title>
    <link href="http://yoursite.com/2021/06/04/SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2021/06/04/SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/</id>
    <published>2021-06-04T07:20:28.000Z</published>
    <updated>2021-06-06T11:38:59.292Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>SpringBoot的一个很重要的特性就是自动配置，使用注解，让服务不再需要xml等各种配置文件<br>然后使用main方法一键启动</p></blockquote><h2 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h2><p><code>@SpringBootApplication</code> 注解是 SpringBoot 的源头，一切都要从该注解开始说起</p><p>标注在类上时，表示该类是 SpringBoot 的主配置类，并从该类中的 <code>main</code> 方法来启动 SpringBoot 应用</p><p>注解源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(excludeFilters = &#123;</span></span><br><span class="line"><span class="meta">@Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span></span><br><span class="line"><span class="meta">@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br></pre></td></tr></table></figure><p>可以看出主要包含了三个注解：</p><ul><li><code>@SpringBootConfiguration</code></li><li><code>@ComponentScan</code></li><li><code>@EnableAutoConfiguration</code></li></ul><h3 id="SpringBootConfiguration"><a href="#SpringBootConfiguration" class="headerlink" title="@SpringBootConfiguration"></a>@SpringBootConfiguration</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootConfiguration &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看 <code>@SpringBootConfiguration</code> 的源码发现其实就是一个 <code>@Configuration</code> 注解，表示这是一个 SpringBoot 的配置类</p><h3 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h3><p><code>@ComponentScan</code> 表示开启组件扫描</p><p>默认是扫描<strong>当前类</strong>下的package。将 <code>@Controller/@Service/@Component/@Repository</code> 等注解加载到IOC容器中</p><h3 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h3><p><code>@EnableAutoConfiguration</code> 表示开启自动配置，SpringBoot 自动配置的原理都在这个注解中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(AutoConfigurationImportSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br></pre></td></tr></table></figure><p><code>@EnableAutoConfiguration</code> 又主要包含 <code>@Import</code>、<code>@AutoConfigurationPackage</code> 俩个注解，先看下重点 <code>@Import</code> 这个注解</p><h4 id="Import"><a href="#Import" class="headerlink" title="@Import"></a>@Import</h4><p><code>@Import</code> 注解是用来导入配置类或者一些需要前置加载的类，可以将多个配置类融合成一个配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Import &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Configuration&#125;, &#123;<span class="doctag">@link</span> ImportSelector&#125;, &#123;<span class="doctag">@link</span> ImportBeanDefinitionRegistrar&#125;</span></span><br><span class="line"><span class="comment"> * or regular component classes to import.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Class&lt;?&gt;[] value();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看代码可以看出，有三种使用方式：</p><ul><li>导入普通 Java 类，导入的类会被加载为 Bean</li><li>导入 <code>ImportSelector</code> 接口实现</li><li>导入 <code>ImportBeanDefinitionRegistrar</code> 接口实现</li></ul><ol><li><p>ImportSelector</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Select and return the names of which class(es) should be imported based on</span></span><br><span class="line"><span class="comment">* the &#123;<span class="doctag">@link</span> AnnotationMetadata&#125; of the importing @&#123;<span class="doctag">@link</span> Configuration&#125; class.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">String[] selectImports(AnnotationMetadata importingClassMetadata);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 接口中只有一个 <code>selectImports</code> 方法，用于返回全类名数组，会把返回数组中的类全部导入</p></li><li><p>ImportBeanDefinitionRegistrar</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Register bean definitions as necessary based on the given annotation metadata of</span></span><br><span class="line"><span class="comment">* the importing &#123;<span class="doctag">@code</span> <span class="doctag">@Configuration</span>&#125; class.</span></span><br><span class="line"><span class="comment">* &lt;p&gt;Note that &#123;<span class="doctag">@link</span> BeanDefinitionRegistryPostProcessor&#125; types may &lt;em&gt;not&lt;/em&gt; be</span></span><br><span class="line"><span class="comment">* registered here, due to lifecycle constraints related to &#123;<span class="doctag">@code</span> <span class="doctag">@Configuration</span>&#125;</span></span><br><span class="line"><span class="comment">* class processing.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> importingClassMetadata annotation metadata of the importing class</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> registry current bean definition registry</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>registerBeanDefinitions</code> 它可以手动注册bean到容器中</p></li></ol><h4 id="AutoConfigurationImportSelector-class"><a href="#AutoConfigurationImportSelector-class" class="headerlink" title="AutoConfigurationImportSelector.class"></a>AutoConfigurationImportSelector.class</h4><p><code>AutoConfigurationImportSelector.class</code> 类实现了 <code>ImportSelector</code> 接口，其中的核心方法是 <code>selectImports</code>，来返回需要导入的组件的全类名数组</p><ul><li><p><code>selectImports</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line"><span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line"><span class="keyword">return</span> NO_IMPORTS;</span><br><span class="line">&#125;</span><br><span class="line">AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader</span><br><span class="line">.loadMetadata(<span class="keyword">this</span>.beanClassLoader);</span><br><span class="line">AnnotationAttributes attributes = getAttributes(annotationMetadata);</span><br><span class="line"><span class="comment">//获取全类名数组</span></span><br><span class="line">List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata,</span><br><span class="line">attributes);</span><br><span class="line">configurations = removeDuplicates(configurations);</span><br><span class="line">Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);</span><br><span class="line">checkExcludedClasses(configurations, exclusions);</span><br><span class="line">configurations.removeAll(exclusions);</span><br><span class="line">configurations = filter(configurations, autoConfigurationMetadata);</span><br><span class="line">fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line"><span class="keyword">return</span> StringUtils.toStringArray(configurations);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>getCandidateConfigurations</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata,</span></span></span><br><span class="line"><span class="function"><span class="params">AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line"><span class="comment">//获取EnableAutoConfiguration.class对应的全类名数组</span></span><br><span class="line">List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(</span><br><span class="line">getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader());</span><br><span class="line">Assert.notEmpty(configurations,</span><br><span class="line"><span class="string">&quot;No auto configuration classes found in META-INF/spring.factories. If you &quot;</span></span><br><span class="line">+ <span class="string">&quot;are using a custom packaging, make sure that file is correct.&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> configurations;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; getSpringFactoriesLoaderFactoryClass() &#123;</span><br><span class="line"><span class="keyword">return</span> EnableAutoConfiguration.class;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>loadFactoryNames</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">loadFactoryNames</span><span class="params">(Class&lt;?&gt; factoryClass, <span class="meta">@Nullable</span> ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">String factoryClassName = factoryClass.getName();</span><br><span class="line"><span class="comment">//返回 META-INF/spring.factories 文件下 EnableAutoConfiguration.class 对应的所有值</span></span><br><span class="line"><span class="keyword">return</span> loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>loadSpringFactories</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从当前项目的类路径中获取所有 META-INF/spring.factories 这个文件下的信息。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(<span class="meta">@Nullable</span> ClassLoader classLoader) &#123;</span><br><span class="line">MultiValueMap&lt;String, String&gt; result = cache.get(classLoader);</span><br><span class="line"><span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//FACTORIES_RESOURCE_LOCATION:META-INF/spring.factories</span></span><br><span class="line">Enumeration&lt;URL&gt; urls = (classLoader != <span class="keyword">null</span> ?</span><br><span class="line">classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :</span><br><span class="line">ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));</span><br><span class="line">result = <span class="keyword">new</span> LinkedMultiValueMap&lt;&gt;();</span><br><span class="line"><span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">URL url = urls.nextElement();</span><br><span class="line">UrlResource resource = <span class="keyword">new</span> UrlResource(url);</span><br><span class="line">Properties properties = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">String factoryClassName = ((String) entry.getKey()).trim();</span><br><span class="line"><span class="keyword">for</span> (String factoryName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) &#123;</span><br><span class="line">result.add(factoryClassName, factoryName.trim());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cache.put(classLoader, result);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Unable to load factories from location [&quot;</span> +</span><br><span class="line">FACTORIES_RESOURCE_LOCATION + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="META-INF-spring-factories"><a href="#META-INF-spring-factories" class="headerlink" title="META-INF/spring.factories"></a>META-INF/spring.factories</h4><p><code>META-INF/spring.factories</code> 在很多第三方依赖中都会有这个文件，第三方依赖通过这个文件并配置 <code>EnableAutoConfiguration</code> 参数，然后自动配置会把这个参数下面的所有类都配置到 Spring 容器中，如图</p><p><img src="/images/SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE0.jpg" alt="image"></p><h4 id="AutoConfigurationPackage"><a href="#AutoConfigurationPackage" class="headerlink" title="@AutoConfigurationPackage"></a>@AutoConfigurationPackage</h4><p><code>@EnableAutoConfiguration</code> 注解中的另一个注解 <code>@AutoConfigurationPackage</code>，是用来自动配置包的，将主配置类 <code>@SpringBootConfiguration</code> 标注的类，所在包及下面所有子包里面的所有组件扫描到 Spring 容器中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Import(AutoConfigurationPackages.Registrar.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AutoConfigurationPackage &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>AutoConfigurationPackage</code> 注解依然使用了 <code>import</code> 注解，不过使用的是 <code>ImportBeanDefinitionRegistrar</code> 接口实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Registrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span>, <span class="title">DeterminableImports</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="comment">//把所在包及其子包里边的组件扫描注册到Spring容器中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata,</span></span></span><br><span class="line"><span class="function"><span class="params">BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">register(registry, <span class="keyword">new</span> PackageImport(metadata).getPackageName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;Object&gt; <span class="title">determineImports</span><span class="params">(AnnotationMetadata metadata)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> Collections.singleton(<span class="keyword">new</span> PackageImport(metadata));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p> SpringBoot的自动装配是由 <code>@EnableAutoConfiguration</code> 注解来实现的，而 <code>@EnableAutoConfiguration</code> 注解又是通过 <code>@AutoConfigurationPackage</code> 和 <code>@Import(AutoConfigurationImportSelector.class)</code> 来实现服务自身的自动配置和第三方依赖的自动配置</p><p>注解关系如图：</p><p> <img src="/images/SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE1.png" alt="image"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;SpringBoot的一个很重要的特性就是自动配置，使用注解，让服务不再需要xml等各种配置文件&lt;br&gt;然后使用main方法一键启动&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;SpringBootApplication&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
    <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Web fragments</title>
    <link href="http://yoursite.com/2021/02/19/Web%20fragments/"/>
    <id>http://yoursite.com/2021/02/19/Web%20fragments/</id>
    <published>2021-02-19T10:23:07.000Z</published>
    <updated>2021-02-19T11:28:12.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p><code>Web fragments</code>是<code>servlet 3.0</code>开始支持的一个特性(可插性支持)，通过插件的方式很方便的扩充已有<code>Web</code>应用的功能，而不需要修改原有的应用</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><blockquote><p>Servlet 3.0 的部署描述文件 web.xml 的顶层标签 有一个 metadata-complete 属性，该属性指定当前的部署描述文件是否是完全的。如果设置为 true，则容器在部署时将只依赖部署描述文件，忽略所有的注解（同时也会跳过 web-fragment.xml 的扫描，亦即禁用可插性支持，具体请看后文关于 <a href="https://www.ibm.com/developerworks/cn/java/j-lo-servlet30/#major4">可插性支持</a> 的讲解）；如果不配置该属性，或者将其设置为 false，则表示启用注解支持（和可插性支持）。</p></blockquote><h3 id="Web-fragments语法和规则"><a href="#Web-fragments语法和规则" class="headerlink" title="Web fragments语法和规则"></a>Web fragments语法和规则</h3><ol><li><code>Web fragments</code> 需要有 <code>web-fragment.xml</code> 的部署描述文件，该文件必须存放在 <code>JAR</code> 文件的 <code>META-INF</code> 目录下，该部署描述文件可以包含一切可以在 <code>web.xml</code> 中定义的内容(过滤器、监听器与<code>Servlet</code>)</li><li>包含 <code>web-fragment.xml</code> 的 <code>JAR</code> 应该部署到 <code>Web</code> 应用程序的 <code>WEBINF/lib</code> 目录中</li><li><code>web-fragment.xml</code> 的根元素是 <code>&lt;web-fragment&gt;</code>，它可以包含 <code>DD(web.xml)</code> 中 <code>&lt;web-app&gt;</code> 元素的任何子元素。</li><li>每个 <code>web-fragment.xml</code> 都可以包含一个 <code>name</code> 元素。<code>name</code> 元素在所有 <code>Web</code> 片段中应该是唯一的，并且不应有任何循环引用或循环，否则容器将因有意义的错误中止应用程序部署。该名称将用于 <code>Web</code> 片段的任何排序。</li><li>可以使用元素 <code>&lt;absolute-ordering&gt;</code> 从 <code>web.xml</code> 中指定 <code>Web</code> 片段的顺序。也可以使用元素 <code>&lt;ordering&gt;</code> 从 <code>Web</code> 片段本身内部指定 <code>Web</code> 片段的顺序。在 <code>web.xml</code> 或 <code>Web</code> 片段中，元素按照声明的顺序加载。</li><li>并且如果 <code>web-fragment.xml</code> 和 <code>web.xml</code> 之间存在冲突，则 <code>web.xml</code> 将具有优先权。但是，如果两个片段之间存在冲突，则会引发错误。</li></ol><h3 id="配置内容"><a href="#配置内容" class="headerlink" title="配置内容"></a>配置内容</h3><blockquote><p>servlet、filter、listener三个可以定义任何一个，也可以全部定义</p></blockquote><ul><li><p>web-fragment.xml:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-fragment</span> <span class="attr">id</span>=<span class="string">&quot;WebFragment_ID&quot;</span> <span class="attr">version</span>=<span class="string">&quot;3.1&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-fragment_3_1.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Test<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- servlet --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>servletTest<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.xxx.xxx.servlets.ServletTest<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>servletTest<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- filter --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filterTest<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.xxx.xxx.FilterTest<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">async-supported</span>&gt;</span>true<span class="tag">&lt;/<span class="name">async-supported</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filterTest<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- listener --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>com.xxx.xxx.ListenerTest<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ordering</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 表示在项目所有之前进行初始化 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">before</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">others</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">before</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 表示在项目所有之后进行初始化 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">after</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">others</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">after</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ordering</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">web-fragment</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>Servlet:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletTest</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.service(req, resp);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.destroy();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Filter:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.Filter;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.FilterChain;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.FilterConfig;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterTest</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Listener:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.ServletRequestEvent;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletRequestListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListenerTest</span> <span class="keyword">implements</span> <span class="title">ServletRequestListener</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestDestroyed</span><span class="params">(ServletRequestEvent servletRequestEvent)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestInitialized</span><span class="params">(ServletRequestEvent servletRequestEvent)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Web fragments&lt;/code&gt;是&lt;code&gt;servlet 3.0&lt;/code&gt;开始支持的一个特性(可插性支持)，通过</summary>
      
    
    
    
    <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>服务缓存优化</title>
    <link href="http://yoursite.com/2021/02/03/%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2021/02/03/%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%96/</id>
    <published>2021-02-03T08:36:35.000Z</published>
    <updated>2021-03-04T09:22:10.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="服务介绍"><a href="#服务介绍" class="headerlink" title="服务介绍"></a>服务介绍</h3><p><code>bizconf</code>服务是公司所有业务的通用配置服务，用来保存所有企业、以及用户的业务配置。分为三个级别的配置，系统级、租户级和用户级。</p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>之前就有发现<code>bizconf</code>调用量比较大，需要优化缓存来降低调用，而最初现状是只在<code>server</code>端有<code>Redis</code>缓存</p><p>问题爆发点：元旦前最后几天，数据库负载高，导致<code>bizconf</code>服务调用耗时从几毫米升高到 20~30 毫秒，这时客户反馈系统库卡顿、反应慢，经过排查发现调用耗时长的请求和<code>bizconf</code>耗时曲线一致，各个业务都用调用<code>bizconf</code>，还有的业务调用多次，<code>bizconf</code>耗时上涨导致整个系统卡顿</p><h3 id="优化目标"><a href="#优化目标" class="headerlink" title="优化目标"></a>优化目标</h3><p>在<code>client</code>添加<code>jvm cahce</code>来降低调用，从而做到服务降级，前后共经过俩次优化，第一次优化因为缓存穿透的原因效果不明显，第二次优化后效果显著</p><p>优化前调用量：<br><img src="/images/%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%960.png"></p><h3 id="第一次优化"><a href="#第一次优化" class="headerlink" title="第一次优化"></a>第一次优化</h3><p>优化范围：在<code>server</code>和<code>client</code>中添加<code>jvm cache</code></p><p>使用缓存：使用<code>caffeine cache</code>，分级缓存，在<code>server</code>和<code>client</code>中分别添加两个<code>cache</code>，企业级和用户级的<code>cache</code></p><p>缓存设置：</p><ul><li>size：<code>server</code>中<code>cache size</code>为50000，<code>client</code>中<code>cache size</code>为5000，</li><li>过期时间：一个小时</li><li>过期策略：<code>expireAfterAccess(long, TimeUnit)</code>按最后访问时间计时</li><li>基于引用：<code>softValues()</code>设置为软引用</li></ul><p>优化后观察：<br>观察发现虽然添加了<code>jvm cache</code>，但是调用量降低的效果不明显，甚至可以说无效果</p><p>又观察<code>Redis</code>调用量和<code>db</code>调用量，发现<code>db</code>调用量和<code>Redis</code>调用量差不多，少的很有限，这时觉得这种情况不对，怀疑发生了缓存穿透，缓存没有生效</p><p><code>Redis</code>和<code>db</code>调用量：<br><img src="/images/%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%961.png"></p><p>经过排查发现一些数据多次的访问数据库，询问对应业务，是在判断企业的某些状态，如果返回<code>false</code>或不存在则认为没有，至此问题定位，缓存穿透导致大量访问数据库，从而解释了为什么优化的效果不明显</p><p>针对缓存穿透有了下面的第二次的优化</p><h3 id="第二次优化"><a href="#第二次优化" class="headerlink" title="第二次优化"></a>第二次优化</h3><p>针对缓存穿透一般有两种处理方式：使用布隆过滤器和缓存空值</p><h4 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h4><p>布隆过滤器具体可以参考<a href="https://blog.csdn.net/yuanlong122716/article/details/104402602">https://blog.csdn.net/yuanlong122716/article/details/104402602</a></p><p>布隆过滤器有两个非常重要的缺点：</p><ol><li>存在误算率，虽然不会错判但是会误判，什么意思呢，返回不存在则一定不存在，返回存在但是并不能判断一定存在</li><li>不可以删除</li></ol><p>如果使用布隆过滤器则有两个场景，保存白名单和黑名单：</p><ul><li>白名单：如果保存白名单，需要把数据库中所有的数据(表示存在的逻辑true)都保存起来，并且新增时需要同步的维护布隆过滤器数据，但因为是分布式服务需要保证所有服务都同步的维护布隆过滤器，难度比较大；同时布隆过滤器不支持删除，所以不考虑使用白名单</li><li>黑名单：如果保存黑名单，把不存在的数据保存起来，但因为会有误判，可能会把存在的数据认为不存在从而返回了空，从而使数据错误，所以不可取</li></ul><p>分析考虑，不采用布隆过滤器，采用缓存空值的方法更为有效和简单</p><h4 id="缓存空值"><a href="#缓存空值" class="headerlink" title="缓存空值"></a>缓存空值</h4><p>优化目标：<br><img src="/images/fs-paas-bizconf%E9%87%8D%E6%9E%84.png"></p><p>优化范围：在<code>client</code>中添加<code>jvm cache</code>，在<code>server</code>中只使用<code>Redis cache</code></p><p>使用缓存：第一次优化时<code>client</code>端缓存的数据有限，这次决定使用<code>ehcache</code>，可以缓存更大的数据量，同样也是分级缓存</p><p>缓存设置：</p><ul><li>size：每个<code>cache</code>堆内存5000条、堆外内存1MB、磁盘50MB</li><li>过期时间：<code>client</code>的<code>jvm cache</code>5小时；<code>server</code>的<code>redis</code>存在的数据24小时，不存在的空值半小时(防止大量不存在的数据把<code>Redis</code>搞崩，还可以更短一些)</li><li>过期策略：<code>ExpiryPolicyBuilder.timeToLiveExpiration(Duration timeToLive)</code> 按创建时间计时</li></ul><p>优化后观察：<br>这次优化后效果显著，调用量就下降了90%，预计所有业务方改完后调用量还会进一步下降</p><p>优化前后对比：<br><img src="/images/%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%962.png"></p><h3 id="审计日志优化"><a href="#审计日志优化" class="headerlink" title="审计日志优化"></a>审计日志优化</h3><p>优化缓存的同时，增加了审计日志，可以用来分析业务方的不合理调用</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;服务介绍&quot;&gt;&lt;a href=&quot;#服务介绍&quot; class=&quot;headerlink&quot; title=&quot;服务介绍&quot;&gt;&lt;/a&gt;服务介绍&lt;/h3&gt;&lt;p&gt;&lt;code&gt;bizconf&lt;/code&gt;服务是公司所有业务的通用配置服务，用来保存所有企业、以及用户的业务配置。分为三个级别</summary>
      
    
    
    
    <category term="优化" scheme="http://yoursite.com/categories/%E4%BC%98%E5%8C%96/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
    <category term="Cache" scheme="http://yoursite.com/tags/Cache/"/>
    
    <category term="优化" scheme="http://yoursite.com/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>服务日志优化</title>
    <link href="http://yoursite.com/2021/01/04/%E6%9C%8D%E5%8A%A1%E6%97%A5%E5%BF%97%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2021/01/04/%E6%9C%8D%E5%8A%A1%E6%97%A5%E5%BF%97%E4%BC%98%E5%8C%96/</id>
    <published>2021-01-04T09:20:59.000Z</published>
    <updated>2021-03-04T10:10:56.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><blockquote><p>功能权限服务之前经手的人比较多，不同人日志打印比较乱，并且服务日志打印量很大，但当需要排查问题时，大日志量 <code>grep</code> 困难、关键信息打印不全或没有打印等问题很痛苦，决定对日志方面进行统一的优化</p></blockquote><h3 id="优化目标"><a href="#优化目标" class="headerlink" title="优化目标"></a>优化目标</h3><ol><li>对服务日志量大、关键信息不全、代码中侵入式打印日志乱等问题进行优化</li><li>人员角色模块，经常有用户、业务不知道什么时候人员角色发生了变化，针对这个模块增加审计日志，便于观察分析调用、排查问题，给出证据</li><li>日志上报日志中心，使得服务发布后日志不丢失</li></ol><h3 id="优化记录"><a href="#优化记录" class="headerlink" title="优化记录"></a>优化记录</h3><h4 id="服务日志优化"><a href="#服务日志优化" class="headerlink" title="服务日志优化"></a>服务日志优化</h4><ul><li><p>日志级别<br><img src="/images/%E6%9C%8D%E5%8A%A1%E6%97%A5%E5%BF%97%E4%BC%98%E5%8C%960.png"></p></li><li><p>日志内容<br><code>traceId</code>，方法名，方法调用链路，每个方法耗时，入参，出参，异常堆栈</p></li><li><p>相关类<br>使用 <code>Spring AOP</code>、<code>ThreadLocal</code>、<code>Spring StopWatch</code>、<code>Annotation</code> 注解<br>支持两种日志打印方式，<code>AOP</code> 打印和手动调用<br><img src="/images/%E6%9C%8D%E5%8A%A1%E6%97%A5%E5%BF%97%E4%BC%98%E5%8C%961.png"></p></li><li><p>使用方式  </p></li></ul><ol><li>新建切面类，继承 <code>TraceLogAop</code> 抽象类</li><li>编写切点，使用环绕通知，切在需要打印日志的地方</li><li>通知中调用父类的 <code>around</code> 方法，传入 <code>ProceedingJoinPoint</code> 和打印耗时日志阈值</li><li>如需要特殊处理异常，则重写 <code>exceptionHandler</code> 方法<br><img src="/images/%E6%9C%8D%E5%8A%A1%E6%97%A5%E5%BF%97%E4%BC%98%E5%8C%962.png"></li><li>在需要打印 <code>info</code> 日志的方法上添加 <code>@InOutLog(&quot;info&quot;)</code> 注解，<code>debug</code> 级别不用添加，默认就是 <code>debug</code> 级别<br><img src="/images/%E6%9C%8D%E5%8A%A1%E6%97%A5%E5%BF%97%E4%BC%98%E5%8C%963.png"></li><li>也可以修改 <code>logback.xml</code> 文件，添加一个 <code>logger</code> 把日志打印到独立的文件中<br><img src="/images/%E6%9C%8D%E5%8A%A1%E6%97%A5%E5%BF%97%E4%BC%98%E5%8C%964.png"></li></ol><ul><li>优化效果<br>入参、出参效果<br><img src="/images/%E6%9C%8D%E5%8A%A1%E6%97%A5%E5%BF%97%E4%BC%98%E5%8C%965.jpg"><br>方法调用链路、耗时效果<br><img src="/images/%E6%9C%8D%E5%8A%A1%E6%97%A5%E5%BF%97%E4%BC%98%E5%8C%966.jpg"><br>根据详细的入参、出参可以快速、准确的排查问题；根据调用链路和耗时可以来分析耗时长的接口，以及耗时的占比，找到最耗时的方法，从而进行优化</li></ul><h4 id="添加审计日志"><a href="#添加审计日志" class="headerlink" title="添加审计日志"></a>添加审计日志</h4><blockquote><p>人员角色模块增加审计日志，上报ES，使用 kibana 展示，便于观察分析调用、排查问题，给出证据</p></blockquote><p><img src="/images/%E6%9C%8D%E5%8A%A1%E6%97%A5%E5%BF%97%E4%BC%98%E5%8C%967.jpg"></p><h4 id="上报日志中心"><a href="#上报日志中心" class="headerlink" title="上报日志中心"></a>上报日志中心</h4><p>有时查问题前一天晚上有过发版，日志信息丢失，导致查询问题困难，针对这种情况把日志上报到日志中心的 Grafana Explore中</p><hr><p>把日志整体优化后，再也没有了以前的苦恼，有什么问题一目了然(<em>^▽^</em>)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;功能权限服务之前经手的人比较多，不同人日志打印比较乱，并且服务日志打印量很大，但当需要排查问题时，大日志量 &lt;co</summary>
      
    
    
    
    <category term="优化" scheme="http://yoursite.com/categories/%E4%BC%98%E5%8C%96/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
    <category term="优化" scheme="http://yoursite.com/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Spring-AOP</title>
    <link href="http://yoursite.com/2020/12/02/Spring-AOP/"/>
    <id>http://yoursite.com/2020/12/02/Spring-AOP/</id>
    <published>2020-12-02T03:22:37.000Z</published>
    <updated>2020-12-07T11:48:02.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>面向切面编程(AOP)可以实现横切关注点与它们所影响对象之间的解耦，对业务逻辑没有任何侵入<br>使用场景有很多，如：日志、异常、声明式事物、安全、缓存等，包括但不限于这些场景<br>常见的AOP实现有<code>Spring-AOP</code>和<code>AspectJ</code>，<code>Spring-AOP</code>基于动态代理实现，主要总结一下<code>Spring-AOP</code></p></blockquote><p><img src="/images/Spring-AOP0.png"></p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="切面-Aspect"><a href="#切面-Aspect" class="headerlink" title="切面(Aspect)"></a>切面(Aspect)</h4><p>切面是通知和切点的结合，通知和切点共同定义了切面的全面内容————是什么，在何时和何处完成其功能</p><h5 id="通知-Advice"><a href="#通知-Advice" class="headerlink" title="通知(Advice)"></a>通知(Advice)</h5><p>切面的具体功能被称为通知，同时通知不仅定义了切面功能，还定义了切面何时使用，而根据使用时机可以分为5种类型的通知：</p><ul><li>前置通知(Before)：在目标方法被调用之前调用通知功能</li><li>后置通知(After)：在目标方法完成之后调用通知，此时不会关心方法的输出是什么</li><li>返回通知(After-returning)：在目标方法成功执行之后调用通知</li><li>异常通知(After-throwing)：在目标方法抛出异常后调用通知</li><li>环绕通知(Around)：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。环绕通知是最强大的通知类型</li></ul><blockquote><p>在 <code>Spring-AOP</code> 中的环绕通知必须有 <code>ProceedingJoinPoint</code> 这个对象参数，通过它的 <code>proceed()</code> 方法来调用被通知的方法</p></blockquote><h5 id="切点-Poincut"><a href="#切点-Poincut" class="headerlink" title="切点(Poincut)"></a>切点(Poincut)</h5><p>通知定义了切面的 “什么” 和 “何时” ，切点则是定义了切面的 ”何处“</p><p>切点定义了通知被应用的具体位置(在哪些连接点)</p><h4 id="连接点-Join-point"><a href="#连接点-Join-point" class="headerlink" title="连接点(Join point)"></a>连接点(Join point)</h4><p>连接点是在应用执行过程中能够应用通知的 ”所有点“</p><p>连接点可以是调用方法时、抛出异常时、甚至修改一个字段时，但因为<code>Spring-AOP</code>基于动态代理，所以<code>Spring</code>只支持方法的连接点，而<code>AspectJ</code>和<code>JBoss</code>的AOP框架还提供了字段和构造器接入点。</p><p>但是方法拦截则满足了大部分的需求，如果需要方法拦截之外的连接点可以利用<code>AspectJ</code>来补充<code>Spring-AOP</code>的功能</p><h4 id="引入-Introduction"><a href="#引入-Introduction" class="headerlink" title="引入(Introduction)"></a>引入(Introduction)</h4><p>添加方法或字段到被通知的类</p><h4 id="织入-Weaving"><a href="#织入-Weaving" class="headerlink" title="织入(Weaving)"></a>织入(Weaving)</h4><p>织入是把切面应用到目标对象并创建新的代理对象的过程</p><p>织入可以在对象生命周期的多个点织入：</p><ul><li>编译期：切面在目标类编译期被织入。这种需要特殊的编译器。<code>AspectJ</code>的织入编译器就是以这种方式织入</li><li>类加载期：切面在目标类加载到JVM时被织入。这种方式需要特殊的类加载器，可以在目标类被引入应用之前增强该目标类的字节码。<code>AspectJ 5</code>的加载时织入就支持这种方式织入</li><li>运行期：切面在应用运行的某个时刻被织入。在织入时，AOP容器会为目标对象动态地创建一个代理对象。**<code>Spring-AOP</code>就是以这种方式织入切面的**</li></ul><h3 id="定义切点"><a href="#定义切点" class="headerlink" title="定义切点"></a>定义切点</h3><blockquote><p>切点用来定位使用通知的地方，在<code>Spring-AOP</code>中使用的是<code>AspectJ</code>的切点表达式语言来定义切点，但是<code>Spring</code>仅支持<code>AspectJ</code>切点指示器的一个子集</p></blockquote><h4 id="切点表达式"><a href="#切点表达式" class="headerlink" title="切点表达式"></a>切点表达式</h4><h5 id="切点指示器"><a href="#切点指示器" class="headerlink" title="切点指示器"></a>切点指示器</h5><p><code>Spring-AOP</code>所支持的<code>AspectJ</code>的切点指示器</p><table><thead><tr><th>AspectJ 指示器</th><th>描述</th></tr></thead><tbody><tr><td>arg()</td><td>限制连接点匹配参数为指定类型的执行方法</td></tr><tr><td>@args()</td><td>限制连接点匹配参数由指定注解标注的执行方法</td></tr><tr><td>execution()</td><td>用于匹配是连接点的执行方法</td></tr><tr><td>this()</td><td>限制连接点匹配AOP代理的bean引用为指定类型的类</td></tr><tr><td>target</td><td>限制连接点匹配目标对象为指定类型的类</td></tr><tr><td>@target()</td><td>限制连接点匹配特定的执行对象，这些对象对应的类要具有指定类 型的注解</td></tr><tr><td>within()</td><td>限制连接点匹配指定的类型</td></tr><tr><td>@within()</td><td>限制连接点匹配指定注解所标注的类型（当使用Spring AOP时，方 法定义在由指定的注解所标注的类里）</td></tr><tr><td>@annotation</td><td>限定匹配带有指定注解的连接点</td></tr></tbody></table><p><strong>只有<code>execution</code>指示器是实际执行匹配的，而其他的指示器都是用来限制匹配的</strong></p><h5 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h5><p>支持<code>and</code>、<code>or</code>、<code>not</code>关系来连接指示器</p><p>在POJO中使用<code>&amp;&amp;</code>、<code>||</code>、<code>!</code>分别代表<code>and</code>、<code>or</code>、<code>not</code>关系</p><p>在XML中直接使用<code>and</code>、<code>or</code>、<code>not</code>来连接指示器</p><p><img src="/images/Spring-AOP1.jpg"></p><h4 id="bean指示器"><a href="#bean指示器" class="headerlink" title="bean指示器"></a>bean指示器</h4><p>除去<code>AspectJ</code>指示器外，<code>Spring</code>还引入了一个新的<code>bean()</code>指示器，用来在切点表达式中使用bean的ID来标识bean。<code>bean()</code>使用<code>bean Id</code>或<code>bean名称</code>作为参数来限制切点只匹配特定的<code>bean</code></p><h3 id="注解创建切面"><a href="#注解创建切面" class="headerlink" title="注解创建切面"></a>注解创建切面</h3><blockquote><p><code>AspectJ 5</code>支持使用注解来创建切面，使用少量的注解就可以把任意类转变为切面</p></blockquote><blockquote><p><code>Spring</code>同时支持<code>AspectJ</code>注解驱动的切面</p></blockquote><h4 id="AOP配置注解"><a href="#AOP配置注解" class="headerlink" title="AOP配置注解"></a>AOP配置注解</h4><h5 id="Aspect"><a href="#Aspect" class="headerlink" title="@Aspect"></a>@Aspect</h5><p>表明该类不仅仅是个POJO，还是一个切面</p><h5 id="通知注解"><a href="#通知注解" class="headerlink" title="通知注解"></a>通知注解</h5><blockquote><p>通知注解对应五种通知类型，来声明通知方法</p></blockquote><table><thead><tr><th>注解</th><th>通知</th></tr></thead><tbody><tr><td>@After</td><td>通知方法会在目标方法返回或抛出异常后调用</td></tr><tr><td>@AfterReturning</td><td>通知方法会在目标方法返回后调用</td></tr><tr><td>@AfterThrowing</td><td>通知方法会在目标方法抛出异常后调用</td></tr><tr><td>@Around</td><td>通知方法会将目标方法封装起来</td></tr><tr><td>@Before</td><td>通知方法会在目标方法调用之前执行</td></tr></tbody></table><h5 id="Pointcut"><a href="#Pointcut" class="headerlink" title="@Pointcut"></a>@Pointcut</h5><p><code>@Pointcut</code>注解可以在一个<code>@AspectJ</code>切面内定义可重用的切点</p><p>E.g.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Audience</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Pointcut(&quot;execution(** concert.Performance.perform(..))&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performce</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Before(&quot;performce()&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">silenceCellPhones</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Silencing cell phones&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Around(&quot;performce()&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takeSeats</span><span class="params">(ProceedingJoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">joinPoint.proceed(joinPoint.getArgs())</span><br><span class="line">    System.out.println(<span class="string">&quot;Taking seats&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@AfterReturning(&quot;performce()&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">applause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;CLAP CLAP CLAP!!!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@AfterThrowing(&quot;performce()&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demandRefund</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Demanding a refund&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过在 <code>performance()</code> 方法上添加 <code>@Pointcut</code> 注解，这样就可以在任何的切点表达式中使用 <code>performance()</code> 了</p><p><code>performance()</code> 方法的实际内容并不重要，在这里它实际上应该是空的。其实该方法本身只是一个标识，供 <code>@Pointcut</code> 注解依附。</p><h4 id="通过注解引入新功能"><a href="#通过注解引入新功能" class="headerlink" title="通过注解引入新功能"></a>通过注解引入新功能</h4><blockquote><p>类似<code>Groovy</code>不直接修改对象或类的定义就能为对象或类增加新的方法，虽然Java不是动态语言，但是通过<code>AOP</code>引用新的接口则可以实现其功能</p></blockquote><blockquote><p>但是当引入接口的方法被调用时，代理会把此调用委托给实现了新接口的某个其他对象。实际上，<strong>一个<code>bean</code>的实现被拆分到了多个类中</strong></p></blockquote><p>通过<code>@DeclareParents</code>注解可以将新的接口引入到<code>bean</code>中</p><p>定义新的接口:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> concert;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Encoreable</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">performEncore</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建切面引入接口:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> concert;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.DeclareParents;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EncodeableIntroducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@DeclareParents(value=&quot;concert.Performce+&quot;,</span></span><br><span class="line"><span class="meta">                  defaultImpl=DefaultEncoreable.class)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Encoreable encoreable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@DeclareParents</code> 注解由三部分组成：</p><ul><li><code>value</code> 属性指定了哪种类型的 <code>bean</code> 要引入该接口。在本例中，也就是所有实现 <code>Performance</code> 的类型。（标记符后面的加号表示是 <code>Performance</code> 的所有子类型，而不是 Performance 本身。）</li><li><code>defaultImpl</code> 属性指定了为引入功能提供实现的类。在这里，我们指定的是 <code>DefaultEncoreable</code> 提供实现。</li><li><code>@DeclareParents</code> 注解所标注的静态属性指明了要引入了接口。在这里，我们所引入的是 Encoreable 接口。</li></ul><h3 id="XML中声明切面"><a href="#XML中声明切面" class="headerlink" title="XML中声明切面"></a>XML中声明切面</h3><h4 id="AOP配置元素"><a href="#AOP配置元素" class="headerlink" title="AOP配置元素"></a>AOP配置元素</h4><p>在 Spring 的 aop 命名空间中，提供了多个元素用来在 XML 中声明切面</p><table><thead><tr><th>AOP 配置元素</th><th>用途</th></tr></thead><tbody><tr><td>&lt;aop:advisor&gt;</td><td>定义 AOP 通知器</td></tr><tr><td>&lt;aop:after&gt;</td><td>定义 AOP 后置通知（不管被通知的方法是否执行成功）</td></tr><tr><td>&lt;aop:after-returning&gt;</td><td>定义 AOP 返回通知</td></tr><tr><td>&lt;aop:after-throwing&gt;</td><td>定义 AOP 异常通知</td></tr><tr><td>&lt;aop:around&gt;</td><td>定义 AOP 环绕通知</td></tr><tr><td>&lt;aop:aspect&gt;</td><td>定义一个切面</td></tr><tr><td>&lt;aop:aspectj-autoproxy&gt;</td><td>启用 @AspectJ 注解驱动的切面</td></tr><tr><td>&lt;aop:before&gt;</td><td>定义一个 AOP 前置通知</td></tr><tr><td>&lt;aop:config&gt;</td><td>顶层的 AOP 配置元素。大多数的元素必须包含在元素内</td></tr><tr><td>&lt;aop:declare-parents&gt;</td><td>以透明的方式为被通知的对象引入额外的接口</td></tr><tr><td>&lt;aop:pointcut&gt;</td><td>定义一个切点</td></tr></tbody></table><p>E.g.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;audience&quot;</span>&gt;</span></span><br><span class="line">    &lt;aop:pointcut</span><br><span class="line">      id=&quot;performance&quot;</span><br><span class="line">      expressions=&quot;execution(** concert.Performance.perform(..))&quot; /&gt;</span><br><span class="line">  </span><br><span class="line">    &lt;aop:before</span><br><span class="line">      pointcut-ref=&quot;performance&quot;</span><br><span class="line">      method=&quot;silenceCellPhones&quot; /&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;aop:around</span><br><span class="line">      pointcut-ref=&quot;performance&quot;</span><br><span class="line">      method=&quot;takeSeats&quot; /&gt;</span><br><span class="line">      </span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:after-returning</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">pointcut</span>=<span class="string">&quot;execution(** concert.Performance.perform(..))&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">method</span>=<span class="string">&quot;applause&quot;</span> /&gt;</span></span><br><span class="line">      </span><br><span class="line">    &lt;aop:after-throwing</span><br><span class="line">      pointcut-ref=&quot;performance&quot;</span><br><span class="line">      method=&quot;demandRefund&quot; /&gt;</span><br><span class="line">      </span><br><span class="line">  <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="通过切面引入新功能"><a href="#通过切面引入新功能" class="headerlink" title="通过切面引入新功能"></a>通过切面引入新功能</h4><p>使用 <code>@DeclareParents</code> 注解可以为被通知的方法引入新的方法，使用 <code>Spring aop</code> 命名空间中的 <code>&lt;aop:declare-parents&gt;</code> 元素，可以实现相同的功能</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">  &lt;aop:delate-parents</span><br><span class="line">    types-matching=&quot;concert.Performance+&quot;</span><br><span class="line">    implement-interface=&quot;concert.Encoreable&quot;</span><br><span class="line">    default-impl=&quot;concert.DefaultEncoreable&quot; /&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>types-matching</code>类型匹配，匹配为哪些<code>bean</code>引入接口</li><li><code>implement-interface</code>指定新加的接口</li><li><code>default-impl</code>用全限定类名来显式指定新加接口的实现</li><li><code>delegate-ref</code>还支持引用了一个<code>Spring bean</code>作为引入接口的实现</li></ul><h3 id="启用AspectJ自动代理"><a href="#启用AspectJ自动代理" class="headerlink" title="启用AspectJ自动代理"></a>启用AspectJ自动代理</h3><p><strong>无论是注解创建、还是XML声明切面，都需要启用自动代理，来创建切面的代理，否则切面不会生效</strong></p><p>启用自动代理有两种方式：</p><ul><li><p>在<code>JavaConfig</code>中启用</p><blockquote><p>配置类的类级别上通过使用 <code>@EnableAspectJAutoProxy</code> 注解启用自动代理功能</p></blockquote></li><li><p> 在<code>XML</code>中启用</p><blockquote><p>使用 Spring aop 命名空间中的 <code>&lt;aop:aspectj-autoproxy/&gt;</code> 元素</p></blockquote></li></ul><h3 id="注入AspectJ切面"><a href="#注入AspectJ切面" class="headerlink" title="注入AspectJ切面"></a>注入AspectJ切面</h3><blockquote><p>虽然 <code>Spring AOP</code> 能够满足许多应用的切面需求，但是与 <code>AspectJ</code> 相比，<code>Spring AOP</code> 是一个功能比较弱的 <code>AOP</code> 解决方案。<code>AspectJ</code> 提供了 <code>Spring AOP</code> 所不能支持的许多类型的切点</p></blockquote><p><code>AspectJ</code> 可以织入到任意的Java应用程序中，而我们可以借助 <code>Spring</code> 的依赖注入把 <code>bean</code> 装配进 <code>AspectJ</code> 切面中，这样更为方便</p><h4 id="用AspectJ实现切面"><a href="#用AspectJ实现切面" class="headerlink" title="用AspectJ实现切面"></a>用AspectJ实现切面</h4><p>创建 <code>AspectJ</code> 的切面需要使用扩展的Java语言</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.aspect.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> aspect AspectInject &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AspectInject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Pointcut（切入点）：定义了相应Advice要发生的地方。</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 定义切入点的常用的两种方式：</span></span><br><span class="line"><span class="comment">     * 1、使用正则表达式。</span></span><br><span class="line"><span class="comment">     * 2、使用AspectJ表达式（Https://www.iteye.com/blog/jinnianshilongnian-1415606）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">pointcut <span class="title">printInfo</span><span class="params">()</span>:<span class="title">execution</span><span class="params">(* xxx.xxx.xxx.xxx.printInfo(..)</span>)</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造器切点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">pointcut <span class="title">constructEntity</span><span class="params">()</span>:<span class="title">execution</span><span class="params">(xxx.xxx.xxx.xxx.User.new()</span>)</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Advice定义了在Pointcut（切入点）具体要做的操作。</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 切入点在AOP中有多种类型，但在Spring中只有方法类型。</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * before advice, 前置。</span></span><br><span class="line"><span class="comment">     * after return advice, 后置（出错不执行）。</span></span><br><span class="line"><span class="comment">     * after throwing advice, 后置（出错才执行）。</span></span><br><span class="line"><span class="comment">     * after(final) advice, 后置（怎么都执行）。</span></span><br><span class="line"><span class="comment">     * around advice, 环绕（前后都执行）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"> </span><br><span class="line">    before():printInfo()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------printInfo()方法的前置------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    after():printInfo()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------printInfo()的后置------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    before():constructEntity()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------new User()时候的前置------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    after():constructEntity()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-------new User()时候的后置------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用aspectOf-方法注入"><a href="#使用aspectOf-方法注入" class="headerlink" title="使用aspectOf()方法注入"></a>使用aspectOf()方法注入</h4><p><code>Spring bean</code> 由 <code>Spring</code> 容器初始化，但是 <code>AspectJ</code> 切面是由 <code>AspectJ</code> 在运行期创建的。等到 <code>Spring</code> 有机会为 <code>AspectJ</code> 切面注入 <code>bean</code> 时，切面已经被实例化了。</p><p>所有的 <code>AspectJ</code> 切面都提供了一个静态的 <code>aspectOf()</code> 方法，该方法返回切面的一个单例。所以为了获得切面的实例，我们必须使用 <code>factory-method</code> 来调用 <code>asepctOf()</code> 方法</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.aspect.test.AspectInject&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;aspectOf&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li>《Spring 实战（第 4 版）》</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;面向切面编程(AOP)可以实现横切关注点与它们所影响对象之间的解耦，对业务逻辑没有任何侵入&lt;br&gt;使用场景有很多，如：日志、异常、声明式事物、安全、缓存等，包括但不限于这些场景&lt;br&gt;常见的AOP实现有&lt;code&gt;Spring-AOP&lt;/code&gt;</summary>
      
    
    
    
    <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
    <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>ssh-ControlMaster</title>
    <link href="http://yoursite.com/2020/11/18/ssh-ControlMaster/"/>
    <id>http://yoursite.com/2020/11/18/ssh-ControlMaster/</id>
    <published>2020-11-18T11:13:59.000Z</published>
    <updated>2020-11-19T12:18:58.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><code>ssh</code> 的配置文件<code>~/.ssh/config</code>可以大大的简化 <code>ssh</code> 的一些操作，如果没有这个文件则自己在 <code>~/.ssh/</code> 下<code>touch</code>一个即可</p></blockquote><blockquote><p>该文主要介绍使用 <code>ControlMaster</code> 来复用连接，每次<code>ssh</code>一台服务器时不需要每次输入密码</p></blockquote><h3 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h3><h4 id="ControlMaster"><a href="#ControlMaster" class="headerlink" title="ControlMaster"></a>ControlMaster</h4><blockquote><p>SSH支持 <code>ControlMaster</code> 模式，单一网络共享多个seesion，复用之前建立的连接，</p></blockquote><p>值可以为 <code>no(default)/yes/ask/auto</code>需要和 <code>ControlPath</code> 配合使用，当值为 yes 时，ssh 会监听该路径下的 <code>control socket</code>，多个 session 会去连接该 socket，则会尽可能的复用连接</p><h4 id="ControlPath"><a href="#ControlPath" class="headerlink" title="ControlPath"></a>ControlPath</h4><blockquote><p>指定 control socket 的路径</p></blockquote><p>值可以使用下面这些参数：</p><ul><li>%L 本地主机名的第一个组件</li><li>%l 本地主机名（包括域名）</li><li>%h 远程主机名（命令行输入）</li><li>%n 远程原始主机名</li><li>%p 远程主机端口</li><li>%r 远程登录用户名</li><li>%u 本地 ssh 正在使用的用户名</li><li>%i 本地 ssh 正在使用 uid</li><li>%C 值为 %l%h%p%r 的 hash</li></ul><h4 id="ControlPersist"><a href="#ControlPersist" class="headerlink" title="ControlPersist"></a>ControlPersist</h4><blockquote><p>结合 <code>ControlMaster</code> 使用，指定连接打开后后台保持的时间。值可以为 no/yes/整数，单位 s。如果为 no，最初的客户端关闭就关闭。如果 yes/0，无限期的，直到杀死或通过其它机制，如：<code>ssh -O exit</code></p></blockquote><h3 id="实际配置"><a href="#实际配置" class="headerlink" title="实际配置"></a>实际配置</h3><h4 id="ssh-config文件"><a href="#ssh-config文件" class="headerlink" title="~/.ssh/config文件"></a>~/.ssh/config文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">host *</span><br><span class="line">ControlPersist yes</span><br><span class="line">ControlMaster auto</span><br><span class="line">ControlPath ~&#x2F;.ssh&#x2F;master-%r@%h:%p</span><br></pre></td></tr></table></figure><ul><li><code>host</code> 标识匹配的主机名，<code>*</code>代表所有，也可匹配的主机</li><li><code>ControlPersist</code> 保持连接，客户端关闭并不会真的关闭连接</li><li><code>ControlMaster</code> 开启连接复用</li><li><code>ControlPath</code> 指定<code>control socket</code>的路径，当开启<code>ssh</code>连接后，会在<code>~/.ssh/</code>下产生一个master开头的文件，当有这这个文件时，再次<code>ssh</code>连接同一个服务器时判断有该文件则不需要输入密码</li></ul><h4 id="修改expect脚本"><a href="#修改expect脚本" class="headerlink" title="修改expect脚本"></a>修改expect脚本</h4><p>经常会使用<code>expect</code>脚本来连接服务器，开启<code>ControlMaster</code>模式后可能会使之前的<code>expect</code>脚本有问题，所以需要修改<code>expect</code>脚本</p><ul><li><p>before</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/expect</span></span><br><span class="line">set host [lindex $argv 0]</span><br><span class="line">set username &quot;&quot;</span><br><span class="line"></span><br><span class="line">spawn ssh $username@$host</span><br><span class="line">expect &#123;</span><br><span class="line">&quot;*yes/no)? &quot; &#123;send &quot;yes\n&quot;; exp_continue&#125;</span><br><span class="line">&quot;password:&quot; &#123;send &quot;password&quot;&#125;</span><br><span class="line">&#125;</span><br><span class="line">interact</span><br></pre></td></tr></table></figure></li><li><p>after</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/expect</span></span><br><span class="line">set host [lindex $argv 0]</span><br><span class="line">set username &quot;&quot;</span><br><span class="line"></span><br><span class="line">set controlMaster [file exists ~/.ssh/master-$username@$host:22]</span><br><span class="line"></span><br><span class="line">if &#123; $controlMaster&#125; &#123;</span><br><span class="line">spawn ssh $username@$host</span><br><span class="line">&#125; else &#123;</span><br><span class="line">spawn ssh $username@$host</span><br><span class="line">expect &#123;</span><br><span class="line">    &quot;*yes/no)? &quot; &#123;send &quot;yes\n&quot;; exp_continue&#125;</span><br><span class="line">&quot;password:&quot; &#123;send &quot;password&quot;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">interact</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;ssh&lt;/code&gt; 的配置文件&lt;code&gt;~/.ssh/config&lt;/code&gt;可以大大的简化 &lt;code&gt;ssh&lt;/code&gt; 的一些操作，如果没有这个文件则自己在 &lt;code&gt;~/.ssh/&lt;/code&gt; 下&lt;code&gt;touc</summary>
      
    
    
    
    <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Annotation注解</title>
    <link href="http://yoursite.com/2020/11/13/Annotation%E6%B3%A8%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/11/13/Annotation%E6%B3%A8%E8%A7%A3/</id>
    <published>2020-11-13T04:33:31.000Z</published>
    <updated>2020-11-13T04:54:41.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="三种内置注解"><a href="#三种内置注解" class="headerlink" title="三种内置注解:"></a>三种内置注解:</h4><ol><li><p><code>@Override</code>表示当前的方法定义将覆盖超类中的方法。</p></li><li><p><code>@Deprecated</code>使用了注解为它的元素编译器将发出警告，因为注解@Deprecated是不赞成使用的代码，被弃用的代码。</p></li><li><p><code>@SuppressWarnings</code>关闭不当编辑器警告信息。</p></li></ol><h4 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h4><blockquote><p>定义注解的注解,是java提供给我们用于定义注解的基本注解.在<code>java.lang.annotation</code>包</p></blockquote><h5 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h5><blockquote><p>用于定义注解的作用目标，表示该注解可以用于什么地方，ElementType参数有：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Target(ElementType.TYPE)           用于接口(注解本质上也是接口),类,枚举</span><br><span class="line">@Target(ElementType.FIELD)          用于字段,枚举常量</span><br><span class="line">@Target(ElementType.METHOD)         用于方法</span><br><span class="line">@Target(ElementType.PARAMETER)      用于方法参数</span><br><span class="line">@Target(ElementType.CONSTRUCTOR)    用于构造参数</span><br><span class="line">@Target(ElementType.LOCAL_VARIABLE) 用于局部变量</span><br><span class="line">@Target(ElementType.ANNOTATION_TYPE)用于注解</span><br><span class="line">@Target(ElementType.PACKAGE)        用于包</span><br></pre></td></tr></table></figure><h5 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h5><blockquote><p>用于定义注解保留策略，即定义的注解类在什么时候存在(源码阶段 or 编译后 or 运行阶段).</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.SOURCE)注解仅在源码中保留,class文件中不存在</span><br><span class="line">@Retention(RetentionPolicy.CLASS)注解在源码和class文件中都存在,但运行时不存在,即运行时无法获得,该策略也是默认的保留策略</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)注解在源码,class文件中存在且运行时可以通过反射机制获取到</span><br></pre></td></tr></table></figure><h5 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h5><blockquote><p>用于描述其它类型的annotation应该被javadoc文档化,出现在api doc中</p></blockquote><h5 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h5><blockquote><p>允许子类继承父类中的注解</p></blockquote><h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE&#125;)   ---作用范围 Class</span><br><span class="line">@Retention(RetentionPolicy.CLASS)  ---生命周期：仅保留到.class文件</span><br><span class="line">public @interface 注解名 &#123;定义体&#125;</span><br></pre></td></tr></table></figure><p>像<code>@Override</code>这样,没有成员定义的注解称之为标记注解.</p><p>自定义注解后，需要处理注解，注解实现的具体逻辑需要自己来写注解处理器</p><h3 id="注解处理器"><a href="#注解处理器" class="headerlink" title="注解处理器:"></a>注解处理器:</h3><p>注解处理器可以分为运行时注解处理和编译时注解处理器.运行时处理器需要借助反射机制实现,而编译时处理器则需要借助APT来实现.</p><p>无论是运行时注解处理器还是编译时注解处理器,主要工作都是读取注解然后处理特定注解</p><h4 id="运行时注解处理器"><a href="#运行时注解处理器" class="headerlink" title="运行时注解处理器"></a>运行时注解处理器</h4><p>运行时注解属性为<code>@Retention(RetentionPolicy.RUNTIME)</code>的注解.</p><p>为了运行时能准确获取到注解的相关信息，Java在java.lang.reflect 反射包下新增了<code>AnnotatedElement</code>接口，所有程序元素的(Class,Method)都实现了该接口，通过该接口提供的方法可以利用反射技术地读取注解的信息</p><p>常用<code>AnnotatedElement</code>中的反射方法:</p><table><thead><tr><th align="center">方法</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center"><T extends Annotation> T getAnnotation(Class<T> annotationClass)</td><td align="center">返回该元素上存在的制定类型的注解</td></tr><tr><td align="center">Annotation[] getAnnotations()</td><td align="center">返回该元素上存在的所有注解</td></tr><tr><td align="center">default <T extends Annotation> T[] getAnnotationsByType(Class<T> annotationClass)</td><td align="center">返回该元素指定类型的注解</td></tr><tr><td align="center">default <T extends Annotation> T getDeclaredAnnotation(Class<T> annotationClass)</td><td align="center">返回直接存在与该元素上的所有注释</td></tr><tr><td align="center">default <T extends Annotation> T[] getDeclaredAnnotationsByType(Class<T> annotationClass)</td><td align="center">返回直接存在该元素岸上某类型的注释</td></tr><tr><td align="center">Annotation[] getDeclaredAnnotations()</td><td align="center">返回直接存在与该元素上的所有注释</td></tr></tbody></table><p>通过这些反射方法获取到注解信息，然后对其进行业务操作即可</p><h4 id="编译时注解处理器"><a href="#编译时注解处理器" class="headerlink" title="编译时注解处理器"></a>编译时注解处理器</h4><blockquote><p>(Annotation Processor Tool)APT,处理注解来生成代码<br>获取注解及生成代码都是在代码编译时候完成的，相比反射在运行时处理注解大大提高了程序性能</p></blockquote><p>不同于运行时注解处理器，编写编译时注解处理器分两步:</p><h5 id="继承AbstractProcessor，实现自己的注解处理器"><a href="#继承AbstractProcessor，实现自己的注解处理器" class="headerlink" title="继承AbstractProcessor，实现自己的注解处理器"></a>继承AbstractProcessor，实现自己的注解处理器</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RouteProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ProcessingEnvironment env)</span></span>&#123; </span><br><span class="line">        <span class="keyword">super</span>.init(processingEnv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annoations, RoundEnvironment env)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">getSupportedAnnotationTypes</span><span class="params">()</span> </span>&#123; </span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">super</span>.getSupportedAnnotationTypes();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SourceVersion <span class="title">getSupportedSourceVersion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">super</span>.getSupportedSourceVersion();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">方法</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">init(ProcessingEnvironment processingEnv)</td><td align="center">该方法有注解处理器自动调用，其中ProcessingEnvironment类提供了很多有用的工具类：Filter，Types，Elements，Messager等</td></tr><tr><td align="center">getSupportedAnnotationTypes()</td><td align="center">该方法返回字符串的集合表示该处理器用于处理那些注解</td></tr><tr><td align="center">getSupportedSourceVersion()</td><td align="center">该方法用来指定支持的java版本，一般来说我们都是支持到最新版本，因此直接返回SourceVersion.latestSupported(）即可</td></tr><tr><td align="center">process(Set annotations, RoundEnvironment roundEnv)</td><td align="center">该方法是注解处理器处理注解的主要地方，我们需要在这里写扫描和处理注解的代码，以及最终生成的java文件。其中需要深入的是RoundEnvironment类，该用于查找出程序元素上使用的注解</td></tr></tbody></table><h5 id="注册处理器-并打成jar包"><a href="#注册处理器-并打成jar包" class="headerlink" title="注册处理器,并打成jar包"></a>注册处理器,并打成jar包</h5><blockquote><p>注解和注解处理器必须要新建jar包，然后通过jar包引用。</p></blockquote><p>为了让java编译器或能够找到自定义的注解处理器我们需要对其进行注册和打包：自定义的处理器需要被打成一个jar，并且需要在jar包的<code>META-INF/services</code>路径下中创建一个固定的文件<code>javax.annotation.processing.Processor</code>,在<code>javax.annotation.processing.Processor</code>文件中需要填写自定义处理器的完整路径名，有几个处理器就需要填写几个</p><blockquote><p>AbstractProcessor中生成java类，可以使用JavaPoet开源库进行编写，提升效率</p></blockquote><p>常用的<code>Lombok</code>来消除代码冗余，则是通过APT来实现的<br><img src="/images/Annotation%E6%B3%A8%E8%A7%A3.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h3&gt;&lt;h4 id=&quot;三种内置注解&quot;&gt;&lt;a href=&quot;#三种内置注解&quot; class=&quot;headerlink&quot; title=&quot;三种内置注</summary>
      
    
    
    
    <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>创建文档站点</title>
    <link href="http://yoursite.com/2020/10/23/%E5%88%9B%E5%BB%BA%E6%96%87%E6%A1%A3%E7%AB%99%E7%82%B9/"/>
    <id>http://yoursite.com/2020/10/23/%E5%88%9B%E5%BB%BA%E6%96%87%E6%A1%A3%E7%AB%99%E7%82%B9/</id>
    <published>2020-10-23T08:47:20.000Z</published>
    <updated>2020-10-23T10:14:17.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>经常看到一些文档的网站很简洁，于是便调研了一下，自己动手基于<code>GitHub Pages</code>搭建了一个文档站点</p></blockquote><h3 id="文档站点生成器"><a href="#文档站点生成器" class="headerlink" title="文档站点生成器"></a>文档站点生成器</h3><blockquote><p>调研了5种文档站点生成器</p></blockquote><ol><li><p><a href="https://docsify.js.org/#/zh-cn/">docsify</a><br>不同于 <code>GitBook</code>、<code>vuePress</code>、<code>Hexo</code> 的地方是它不会生成静态的 .html 文件，所有转换工作都是在运行时。无需构建，写完文档直接发布</p></li><li><p><a href="https://docute.org/zh/">docute</a><br><code>docute</code> 和 <code>docsify</code> 几乎相同，都是运行时驱动，但具有不同的 UI 和不同的使用方式，Docute（60kB）比 Docisfy（20kB）大 3 倍，因为<code>docute</code>使用了 Vue，Vue Router 和 Vuex，而 <code>Docsify</code> 使用的是 vanilla JavaScript。</p></li><li><p><a href="https://vuepress.vuejs.org/zh/">vuePress</a><br>使用vue开发，每一个由 <code>VuePress</code> 生成的页面都带有预渲染好的 HTML，也因此具有非常好的加载性能和搜索引擎优化（SEO）</p></li><li><p><a href="https://rust-lang.github.io/mdBook/">mdBook</a><br><code>mdBook</code> 是一个命令行工具和<code>Rust crate</code>。可将Markdown文件创建为书籍。它与<code>Gitbook</code>非常相似,但用<code>Rust</code>编写</p></li><li><p><a href="https://www.gitbook.com/">gitBook</a><br><code>GitBook</code> 是一个基于 Node.js 的命令行工具，可使用 Github/Git 和 Markdown 来制作精美的电子书，支持输出多种格式文档：静态站点、PDF、eBook、单HTML网页、JSON</p></li></ol><h3 id="使用docsify搭建站点"><a href="#使用docsify搭建站点" class="headerlink" title="使用docsify搭建站点"></a>使用docsify搭建站点</h3><blockquote><p><a href="http://leetcode.tianwj.com/">leetcode.tianwj.com</a><br>把之前刷的leetcode记录生成了一个站点，并且绑定二级域名</p></blockquote><p><a href="https://docsify.js.org/#/zh-cn/">docsify</a> 官方文档写的非常详细，并且还支持中文，官方文档就是使用 <code>docsify</code> 生成的，具体可以查看官方文档</p><p>设置<code>GitHub Pages</code>:<br><img src="/images/gitHub-pages.png"></p><p>最终成品:<br><img src="/images/leetcode1.png"><br><img src="/images/leetcode2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;经常看到一些文档的网站很简洁，于是便调研了一下，自己动手基于&lt;code&gt;GitHub Pages&lt;/code&gt;搭建了一个文档站点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;文档站点生成器&quot;&gt;&lt;a href=&quot;#文档站点生成器&quot; class</summary>
      
    
    
    
    <category term="其他" scheme="http://yoursite.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux expect</title>
    <link href="http://yoursite.com/2020/09/13/Linux-expect/"/>
    <id>http://yoursite.com/2020/09/13/Linux-expect/</id>
    <published>2020-09-13T07:54:52.000Z</published>
    <updated>2020-09-13T09:08:43.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><code>expect</code> 是基于<a href="http://tcl.tk/man/tcl8.5/TclCmd/contents.htm">Tcl</a>实现的一个脚本语言，用来实现自动和程序交互式通信。类似自动远程登录命令，模拟人手工交互输入密码的过程，从而实现自动远程登录<br><code>expect</code> 的工作流程为:<code>spawn</code>(启动指定进程)—&gt;<code>expect</code>(获取指定关键字)—&gt;<code>send</code>(向指定程序发送指定字符)—&gt;<code>interact</code>(允许用户交互)–&gt;退出结束</p></blockquote><h3 id="安装expect"><a href="#安装expect" class="headerlink" title="安装expect"></a>安装expect</h3><p>使用<code>expect</code>的前提需要安装，这里以<code>yum</code>安装为例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y expect</span><br></pre></td></tr></table></figure><h3 id="expect常用命令"><a href="#expect常用命令" class="headerlink" title="expect常用命令"></a>expect常用命令</h3><h4 id="spawn"><a href="#spawn" class="headerlink" title="spawn"></a>spawn</h4><p>启动一个进程，然后所有的<code>expect</code>都在这个进程中进行</p><h4 id="expect"><a href="#expect" class="headerlink" title="expect"></a>expect</h4><p>获取匹配信息匹配成功则执行<code>expect</code>后面的程序动作</p><blockquote><p>example:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">expect &#123;</span><br><span class="line">    “yes&#x2F;no”</span><br><span class="line">    &#123;send “yes\n”;exp_continue&#125;</span><br><span class="line">    “*password:”</span><br><span class="line">    &#123;send “123456\n”&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="exp-continue"><a href="#exp-continue" class="headerlink" title="exp_continue"></a>exp_continue</h4><p>在<code>expect</code>中多次匹配用到，使后面的匹配仍然从第一个关键字开始，否则第一次匹配从第一个关键字开始，但是后面第二次匹配则从第二个关键字开始</p><h4 id="send-exp-send"><a href="#send-exp-send" class="headerlink" title="send exp_send"></a>send exp_send</h4><p>用于发送指定的字符串信息</p><h4 id="send-user"><a href="#send-user" class="headerlink" title="send_user"></a>send_user</h4><p>把参数输出到标准输出中去，默认的<code>send</code>,<code>exp_send</code>命令都是将参数输出到程序中的，相当于<code>shell</code>中的<code>echo</code></p><h4 id="interact"><a href="#interact" class="headerlink" title="interact"></a>interact</h4><p>停留在当前进程，退出<code>expect</code>，交给用户操作</p><h4 id="exit"><a href="#exit" class="headerlink" title="exit"></a>exit</h4><p>退出<code>expect</code>脚本，还可以使用该命令指定退出前的一些命令</p><blockquote><p>example:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">exit -onexit &#123;</span><br><span class="line">    exec rm $tmpfile(删除临时文件)</span><br><span class="line">    send_user “Good bye\n”</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><blockquote><p><code>expect</code>变量使用方法和<code>Tcl</code>一致</p></blockquote><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p>定义变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set host localhost</span><br><span class="line">set passwrod 123456</span><br></pre></td></tr></table></figure><blockquote><p>example:接收命令行参数为变量</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set host [lindex $argv 0]</span><br><span class="line">set passwrod [lindex $argv 1]</span><br></pre></td></tr></table></figure><h4 id="puts"><a href="#puts" class="headerlink" title="puts"></a>puts</h4><p>输出变量</p><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><h4 id="eof"><a href="#eof" class="headerlink" title="eof"></a>eof</h4><p><code>expect</code>执行结束 退出</p><h4 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a>timeout</h4><p>设置全局性的超时时间，默认是10s</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set timeout 60</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;expect&lt;/code&gt; 是基于&lt;a href=&quot;http://tcl.tk/man/tcl8.5/TclCmd/contents.htm&quot;&gt;Tcl&lt;/a&gt;实现的一个脚本语言，用来实现自动和程序交互式通信。类似自动远程登录命令，模拟人</summary>
      
    
    
    
    <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>线程安全与锁优化</title>
    <link href="http://yoursite.com/2020/04/06/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2020/04/06/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/</id>
    <published>2020-04-06T09:48:29.000Z</published>
    <updated>2020-04-06T09:58:36.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><h4 id="Java中的线程安全"><a href="#Java中的线程安全" class="headerlink" title="Java中的线程安全"></a>Java中的线程安全</h4><p>按照线程安全的“安全程度”分为五大类：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立</p><ol><li><strong>不可变</strong><br>在Java中不可变(Immutable)对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要再进行任何线程安全保护措施。如<code>final</code>关键字</li><li><strong>绝对线程安全</strong><br>绝对的线程安全是指“不管运行时环境如何，调用者都不需要任何额外的同步策略”，绝对的线程安全是需要付出非常高的代价的，甚至是不切实际的代价。而在Java API中标注是线程安全的类，大多数都不是绝对的线程安全，都是相对的线程安全</li><li><strong>相对线程安全</strong><br>相对线程安全就是我们通常意义上所讲的线程安全。它需要保证<strong>对象单次的操作是安全的,</strong> 如<code>Vector</code>的<code>get()</code>方法，这个方法是同步的。但是对于一些特定顺序的连续调用，则需要调用端使用额外的同步手段来保证正确性，如使用<code>synchronized</code>关键字<br>在Java中，大部分声明线程安全的类都属于这种类型，如<code>Vector</code>、<code>HashTable</code>、<code>ConcurrentHashMap</code>和<code>Collections</code>的<code>synchronizedCollection()</code>方法包装的集合等</li><li><strong>线程兼容</strong><br>线程兼容是值对象本身并不是线程安全的，但是通过调用端正确的使用同步手段来保证对象在并发环境中可以安全的使用。平常我们说一个类不是线程安全的，指的就是这种情况。<br>Java类库中大部分类都是线程兼容的，如<code>ArrayList</code>和<code>HashMap</code>等</li><li><strong>线程对立</strong><br>线程独立是指不管调用端是否采取了同步措施，都无法在多线程环境中并发使用。<br>线程对立这种情况是很少出现的，而且通常都是有害的，应当避免<br>如<code>Thread</code>类的<code>suspend()</code>和<code>resume()</code>方法。</li></ol><h4 id="线程安全的实现方法"><a href="#线程安全的实现方法" class="headerlink" title="线程安全的实现方法"></a>线程安全的实现方法</h4><ol><li><p><strong>互斥同步</strong><br>互斥同步是最常见也是最主要的并发保障手段。同步是指共享数据在同一时刻只能背一个线程使用，而互斥是实现同步的一种手段，<code>临界区(Critical Section)</code>、<code>互斥量(Mutex)</code>和<code>信号量(Semaphore)</code>都是常见的互斥实现方式</p><ul><li>synchronized关键字:<br>在Java中，最基本的互斥同步手段就是<code>synchronized关键字</code>，这是一个块结构的语法。<code>synchronized</code>关键字经过javac编译后，会在同步块前后形成<code>monitorenter</code>和<code>monitorexit</code>两个字节码指令。<br>在执行<code>monitorenter</code>指令时，首先尝试去获取对象锁，如果对象没有被锁定或当前线程已经持有了该对象的锁，就把锁的计数器增加一，而在执行<code>monitorexit</code>指令时将会将锁计数器的值减一。当锁计数器的值为0时，锁则被释放了。如果获取对象锁失败则会一直阻塞等待，直到获取到锁  </li></ul></li></ol><p><strong><code>synchronized</code>对于一个线程来说是可重入的，同时<code>synchronized</code>中的锁是非公平的</strong></p><pre><code>- 重入锁(ReentrantLock):  </code></pre><p>重入锁(ReentrantLock)是Lock接口最常见的一种实现，与<code>synchronized</code>相似，但是比<code>synchronized</code>相比多了一些高级功能，主要是：等待可中断、可实现公平锁(默认也是非公平锁)、可以绑定多个条件</p><ol start="2"><li><p><strong>非阻塞同步</strong><br>互斥同步也被称为阻塞同步，是一种悲观悲观的并发策略，主要问题是进行线程阻塞和唤醒所带来的性能开销。与之对应的则是乐观的并发策略，最常用的是不断的重试，直接操作共享数据，当出现冲突时，不断的重试，直到没有冲突。<br>最常见的方法是CAS(Compare-and-Swap)，如juc包中的<code>Atomic</code>类则是通过自旋和CAS实现的，同时CAS可能会出现ABA问题，但是大部分情况下ABA问题不会影响程序并发的正确性</p></li><li><p><strong>无同步方案</strong><br>如果让一个方法不涉及多线程共享数据，自然也不需要去保证线程安全，因为他们天生就是线程安全的，如<code>ThreadLocal</code>这个类，每一个<code>Thread</code>对象都有一个<code>ThreadLocalMap</code>对象，用来存储当前线程的变量</p></li></ol><h3 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h3><blockquote><p>JDK 5升级到JDK 6后，进行了大量的锁优化</p></blockquote><h4 id="自旋锁和自适应自旋"><a href="#自旋锁和自适应自旋" class="headerlink" title="自旋锁和自适应自旋"></a>自旋锁和自适应自旋</h4><ul><li>自旋锁：当线程尝试获取锁时发现冲突，则让获取锁的线程等一会，但不放弃CPU的执行时间，而让线程等待则让线程执行一个循环(自旋)即可</li><li>自适应自旋：自旋所等待的时间必须有一定的限度，如果超过了限定的次数仍然没有获取到锁，则使用传统的方法挂起该线程，自旋次数默认是10次。而自适应自旋则是自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定</li></ul><h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><p>锁消除是虚拟机即时编译器在运行时，检测到数据不可能被其他线程访问，则会对锁进行消除。锁消除的主要判断依据来源于逃逸分析的数据支持，如果判断一段代码在堆上的所有数据都不会逃逸出去被其他线程访问到，则可以把他们当作栈上的数据对待，认为他们是线程私有的</p><h4 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h4><p>如果虚拟机探测到有一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展(粗化)到整个操作序列的外部。如果<code>StringBuffer.append()</code>方法，连续操作append方法，锁则会扩展到第一个append方法之前和最后一个append方法之后，只需加一次锁就可以</p><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><blockquote><p>轻量级锁是通过CAS来实现的</p></blockquote><p>HotSpot虚拟机的对象头中有一部分用来存储对象自身的运行时数据，如哈希码，GC分代年龄、存储标识位、偏向模式等，官方称它为“Mark Word”。</p><p>在代码即将进入同步块之前，如果同步对象没有被锁定，则在当前线程的栈帧中建立一个锁记录(Lock Record)的空间，用来存储锁对象Mark Word的拷贝。<br>然后虚拟机使用CAS操作尝试把对象的Mark Word更新为Lock Record的指针，如果更新成功，则代表该线程拥有了这个对象的所，如果更新失败了，首先检查是否是当前线程拥有了这个对象的锁，如果是的话直接执行即可，如果不是则说明锁被其他线程抢占了。解锁反之。</p><p>如果出现两个线程争用一个锁的情况，那轻量级锁则不再有效，必须膨胀为重量级锁</p><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>轻量级锁是在无竞争的情况下使用CAS来消除同步的互斥量，而偏向锁是在无竞争的情况下把整个同步都消除掉，连CAS都不再操作</p><p>具体是这样的，当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设置为“01”、把偏向模式设置为“1”，标识进入偏向模式。同时使用CAS操作把获取这个锁的线程ID记录在了对象头的Mark Word中，如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁都不需要有任何同步操作。但是如果另外的线程去尝试获取这个锁，偏向模式则马上宣告结束</p><p>偏向锁是一种权衡的优化，如果程序中的大多数锁都总是被多个不同的线程访问，那偏向模式反而是多余的。具体情况具体分析，可以使用参数<code>-CC:-UseBiasedLocking</code>来禁止偏向锁优化</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;线程安全&quot;&gt;&lt;a href=&quot;#线程安全&quot; class=&quot;headerlink&quot; title=&quot;线程安全&quot;&gt;&lt;/a&gt;线程安全&lt;/h3&gt;&lt;h4 id=&quot;Java中的线程安全&quot;&gt;&lt;a href=&quot;#Java中的线程安全&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>ThreadPoolExecutor</title>
    <link href="http://yoursite.com/2020/04/02/ThreadPoolExecutor/"/>
    <id>http://yoursite.com/2020/04/02/ThreadPoolExecutor/</id>
    <published>2020-04-02T14:51:58.000Z</published>
    <updated>2020-04-02T15:57:14.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>ThreadPoolExecutor是Java中线程池的核心实现类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">classDiagram</span><br><span class="line">Executor &lt;|-- ExecutorService : 继承</span><br><span class="line">ExecutorService &lt;|-- AbstractExecutorService : 实现</span><br><span class="line">AbstractExecutorService &lt;|-- ThreadPoolExecutor : 继承</span><br></pre></td></tr></table></figure><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new &#123;<span class="doctag">@code</span> ThreadPoolExecutor&#125; with the given initial</span></span><br><span class="line"><span class="comment"> * parameters and default thread factory.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> corePoolSize      核心线程池大小</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> maximumPoolSize   最大线程池大小</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> keepAliveTime     线程池中超过corePoolSize数目的空闲线程最大存活时间；可以allowCoreThreadTimeOut(true)成为核心线程的有效时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unit              keepAliveTime的时间单位</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> workQueue         阻塞任务队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> threadFactory     线程工厂，对线程命名 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> handler           拒绝策略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure><h3 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h3><p>所有任务的调度都是由execute方法完成的，这部分完成的工作是：检查现在线程池的运行状态、运行线程数、运行策略，决定接下来执行的流程，是直接申请线程执行，或是缓冲到队列中执行，亦或是直接拒绝该任务。其执行过程如下：</p><ol><li>首先检测线程池运行状态，如果不是RUNNING，则直接拒绝，线程池要保证在RUNNING的状态下执行任务。</li><li>如果workerCount &lt; corePoolSize，则创建并启动一个线程来执行新提交的任务。</li><li>如果workerCount &gt;= corePoolSize，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中。</li><li>如果workerCount &gt;= corePoolSize &amp;&amp; workerCount &lt; maximumPoolSize，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务。</li><li>如果workerCount &gt;= maximumPoolSize，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。</li></ol><h3 id="任务存储策略"><a href="#任务存储策略" class="headerlink" title="任务存储策略"></a>任务存储策略</h3><p>使用不同的队列可以实现不一样的任务存取策略</p><ul><li><strong>ArrayBlockingQueue:</strong> 一个用数组实现的有界阻塞队列，此队列按照先进先出(FIFO)的原则对元素进行排序。支持公平锁和非公平锁</li><li><strong>LinkedBlockingQueue:</strong> 一个由链表结构组成的有界队列，此队列按照先进先出(FIFO)的原则对元素进行排序。此队列的默认长度是Integer.MAX_VALUE，所以默认创建的队列有容量危险</li><li><strong>PriorityBlockingQueue:</strong> 一个支持线程优先级排序的无界队列，默认自然序进行排序，也可以自定义实现compareTo()方法来指定元素排序规则，不能保证同优先级元素的排序</li><li><strong>DelayQueue:</strong> 一个实现<code>PriorityBlockingQueue</code>实现延迟获取的无界队列，在创建元素时，可以指定多久才能从队列中获取当前元素。只有延时期满后才能从队列中获取元素</li><li><strong>SynchronousQueue:</strong> 一个不存储元素的阻塞队列，每一个put操作必须等待take操作，否则不能添加元素。支持公平锁和非公平锁。<code>SynchronousQueue</code>的一个使用场景是在线程里。<code>Executors.newCachedThreadPool()</code>就使用了<code>SynchronousQueue</code>，这个线程池根据需要(新任务到来时)创建新的线程，如果有空闲线程则会重复使用，线程空闲60秒后会被回收</li><li><strong>LinkedTransferQueue:</strong> 一个由链表结构组成的无界阻塞队列，相当于其他队列，<code>LinkedTransferQueue</code>队列多了<code>transfer</code>和<code>tryTransfer</code>方法</li><li><strong>LinkedBlockingDeque:</strong> 一个由链表结构组成的双向阻塞队列，队列的头和尾部都可以添加和移除元素，多线程并发时，可以将锁的竞争最多降低一半</li></ul><h3 id="RejectedExecutionHandler拒绝策略"><a href="#RejectedExecutionHandler拒绝策略" class="headerlink" title="RejectedExecutionHandler拒绝策略"></a>RejectedExecutionHandler拒绝策略</h3><ul><li><p><strong>AbortPolicy:</strong> 默认策略，直接抛出异常阻止系统正常运行</p></li><li><p><strong>CallerRunsPolicy:</strong> “调用者运行”一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将任务回馈至发起方比如main线程</p></li><li><p><strong>DiscardOldestPolicy:</strong> 抛弃队列中等待最久的任务，然后把当前任务加入队列中尝试再次提交当前任务</p></li><li><p><strong>DiscardPolicy:</strong> 直接丢弃任务，不给予任何处理也不跑出异常，如果允许任务丢失，这是最好的一种方案</p></li></ul><h3 id="execute-和submit-区别"><a href="#execute-和submit-区别" class="headerlink" title="execute()和submit()区别"></a>execute()和submit()区别</h3><ol><li>接收的参数不一样</li><li>submit有返回值，而execute没有</li><li>submit方便Exception处理：可以通过捕获Future.get抛出的异常</li></ol><h3 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ThreadFactory factory &#x3D; new ThreadFactoryBuilder().setDaemon(true).setNameFormat(&quot;test-666-%d&quot;).build();</span><br><span class="line">ExecutorService threadPoolExecutor &#x3D; new ThreadPoolExecutor(5, 5, 0L, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(), factory);</span><br><span class="line">threadPoolExecutor.execute(()-&gt;&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br><span class="line">&lt;!--threadPoolExecutor.submit(()-&gt;&#123;--&gt;</span><br><span class="line">&lt;!--    ...--&gt;</span><br><span class="line">&lt;!--&#125;);--&gt;</span><br><span class="line">threadPoolExecutor.shutdown();</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;ThreadPoolExecutor是Java中线程池的核心实现类&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;</summary>
      
    
    
    
    <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>事物隔离级别</title>
    <link href="http://yoursite.com/2020/02/01/%E4%BA%8B%E7%89%A9%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    <id>http://yoursite.com/2020/02/01/%E4%BA%8B%E7%89%A9%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</id>
    <published>2020-02-01T05:25:55.000Z</published>
    <updated>2020-02-01T05:55:34.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="事物"><a href="#事物" class="headerlink" title="事物"></a>事物</h3><p>事务是由一组SQL语句组成的逻辑处理单元，是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。事务具有以下4个属性，通常简称为事务的ACID属性:</p><ul><li><p><strong>原子性(Atomicity):</strong> 事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。</p></li><li><p><strong>一致性(Consistent):</strong> 在事务开始和完成时，数据都必须保持一致状态。</p></li><li><p><strong>隔离性(Isolation):</strong> 并发访问数据库时，一个用户的事物不被其他事物所干扰，各并发事务之间数据库是独立的。</p></li><li><p><strong>持久性(Durable):</strong> 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</p></li></ul><h3 id="并发一致性问题"><a href="#并发一致性问题" class="headerlink" title="并发一致性问题"></a>并发一致性问题</h3><ul><li><p><strong>脏读(Dirty read):</strong> 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。<br>解决办法: 把数据库的事务隔离级别调整到<code>READ_COMMITTED</code></p></li><li><p><strong>更新丢失(Lost Update):</strong> 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 </p></li><li><p><strong>不可重复读(Unrepeatableread):</strong> 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。  </p></li></ul><p><strong>一个事务范围内两个相同的查询却返回了不同数据。</strong><br>解决办法: 把数据库的事务隔离级别调整到<code>REPEATABLE_READ</code></p><ul><li><p><strong>幻读(Phantom read):</strong> 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</p></li><li><p><strong>不可重复度和幻读区别:</strong><br>不可重复读的重点是修改，幻读的重点在于新增或者删除。</p></li></ul><h3 id="事物的隔离级别"><a href="#事物的隔离级别" class="headerlink" title="事物的隔离级别"></a>事物的隔离级别</h3><p>“脏读”、”不可重复读”和”幻读”，必须由事务隔离机制来解决。</p><h4 id="SQL-标准定义了四个隔离级别"><a href="#SQL-标准定义了四个隔离级别" class="headerlink" title="SQL 标准定义了四个隔离级别:"></a>SQL 标准定义了四个隔离级别:</h4><ul><li><p><strong>读未提交(Read Uncommitted):</strong><br>最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读</p></li><li><p><strong>读已提交(Read Committed):</strong><br>允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong><br>Oracle、SqlServer默认隔离级别都是<code>READ-COMMITTED</code></p></li><li><p><strong>可重复读(Repeatable Read):</strong><br>对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong><br>MYSQL默认隔离级别是<code>REPEATABLE-READ</code></p></li><li><p><strong>串行化(Serializable):</strong><br>最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong></p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><p>读未提交: 一个事务还没提交时，它做的变更就能被别的事务看到。</p></li><li><p>读已提交: 一个事务提交之后，它做的变更才会被其他事务看到。</p></li><li><p>可重复读 : 一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。</p></li><li><p>串行化: 顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</p></li></ul><p>四个级别逐渐增强，每个级别解决一个问题，事务级别越高，性能越差，大多数环境(<code>Read committed</code> 就可以了)</p><table><thead><tr><th>隔离级别</th><th>读数据一致性</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>读未提交</td><td>最低级别</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>读已提交</td><td>语句级</td><td>N</td><td>Y</td><td>Y</td></tr><tr><td>可重复读</td><td>事物级</td><td>N</td><td>N</td><td>Y</td></tr><tr><td>串行化</td><td>最高级别、事物级</td><td>N</td><td>N</td><td>N</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;事物&quot;&gt;&lt;a href=&quot;#事物&quot; class=&quot;headerlink&quot; title=&quot;事物&quot;&gt;&lt;/a&gt;事物&lt;/h3&gt;&lt;p&gt;事务是由一组SQL语句组成的逻辑处理单元，是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollbac</summary>
      
    
    
    
    <category term="DB" scheme="http://yoursite.com/categories/DB/"/>
    
    
    <category term="DB" scheme="http://yoursite.com/tags/DB/"/>
    
  </entry>
  
  <entry>
    <title>Spring中的FactoryBean</title>
    <link href="http://yoursite.com/2019/12/27/Spring%E4%B8%AD%E7%9A%84FactoryBean/"/>
    <id>http://yoursite.com/2019/12/27/Spring%E4%B8%AD%E7%9A%84FactoryBean/</id>
    <published>2019-12-27T11:22:04.000Z</published>
    <updated>2019-12-27T11:25:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>Spring 中有两种类型的Bean，一种是普通Bean，另一种是工厂Bean 即 FactoryBean。<br>FactoryBean跟普通Bean不同，其返回的对象不是指定类的一个实例，而是该<code>FactoryBean</code>的<code>getObject</code>方法所返回的对象</p><h3 id="FactoryBean接口定义"><a href="#FactoryBean接口定义" class="headerlink" title="FactoryBean接口定义"></a>FactoryBean接口定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.beans.factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FactoryBean</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//返回的对象实例</span></span><br><span class="line">    <span class="function">T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Bean的类型</span></span><br><span class="line">    Class&lt;?&gt; getObjectType();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//true是单例，false是非单例  在Spring5.0中此方法利用了JDK1.8的新特性变成了default方法，返回true</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>FactoryBean 通常是用来创建比较复杂的bean，一般的bean 直接用xml配置即可，但如果一个bean的创建过程中涉及到很多其他的bean 和复杂的逻辑，用xml配置比较困难，这时可以考虑用FactoryBean。</p><blockquote><p>当使用ApplicationContext的getBean()方法获取FactoryBean实例本身而不是它所产生的bean，则要使用&amp;符号+id。比如，现有FactoryBean，它有id，在容器上调用getBean(“myBean”)将返回FactoryBean所产生的bean，调用getBean(“&amp;myBean”)将返回FactoryBean它本身的实例。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Spring 中有两种类型的Bean，一种是普通Bean，另一种是工厂Bean 即 FactoryBean。&lt;br&gt;FactoryBean跟普通Bean不同，其返回的对象不是指定类的一个实例，而是该&lt;code&gt;FactoryBean&lt;/code&gt;的&lt;code&gt;getObje</summary>
      
    
    
    
    <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
    <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Java代理模式</title>
    <link href="http://yoursite.com/2019/12/24/Java%E7%9A%84%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/12/24/Java%E7%9A%84%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</id>
    <published>2019-12-24T12:03:53.000Z</published>
    <updated>2019-12-24T12:41:13.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><blockquote><p>在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。</p></blockquote><blockquote><p>在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。</p></blockquote><blockquote><p>java中的代理分为：静态代理、动态代理。动态代理又分为jdk代理和Cglib代理。</p></blockquote><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>静态代理在使用时，需要定义接口或者父类，被代理的对象和代理对象需要一起实现同一个接口或者继承同一个父类。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h4><ul><li><p>抽象接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>委托类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserImpl</span> <span class="keyword">implements</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;name is &quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>代理类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserProxy</span> <span class="keyword">implements</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserProxy</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.user = user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        String result = user.getName(name); </span><br><span class="line">        System.out.println(result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Demo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        UserProxy userProxy = <span class="keyword">new</span> UserProxy(<span class="keyword">new</span> UserImpl());</span><br><span class="line">        userProxy.getName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h4><blockquote><p>代理类不仅是一个隔离客户端和委托类的中介，还可以通过代理类在不修改原有代码的前提下增加一些新功能，是开闭原则(Open for Extension, Closed for Modification)最典型的实践。</p><p>代理类可以为委托类预处理消息、过滤消息、把消息转发给委托类以及事后处理消息等。代理类与委托类之间通常会存在关联关系，一个代理类的对象与一个委托类的对象关联，代理类对象本身并不真正实现服务，而是通过调用委托类的对象的相关方法来提供特定的服务。</p></blockquote></li><li><p>优点:可以做到在不修改目标对象的功能前提下,对目标功能扩展；</p></li><li><p>缺点:因为代理对象需要与目标对象实现一样的接口，所以会有很多代理类，同时，一旦接口增加方法，目标对象与代理对象都要维护。</p></li></ul><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>静态代理的缺点怎么改进呢？让代理类动态的生成是不就可以了呢，也就是<code>动态代理</code></p><p><code>动态代理</code>两种最常见的方式：</p><ol><li>通过实现接口的方式 -&gt; JDK动态代理</li><li>通过继承类的方式 -&gt; CGLIB动态代理</li></ol><h4 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h4><p><strong>JDK动态代理又称接口代理</strong>，基于Java反射机制实现，必须要实现了接口的业务类才能用这种办法生成代理对象。</p><p>JDK动态代理主要涉及两个类：<code>java.lang.reflect.Proxy</code> 和 <code>java.lang.reflect.InvocationHandler</code></p><p>InvocationHandler 和 Proxy 的主要方法介绍:</p><ul><li><p><code>java.lang.reflect.InvocationHandler</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义了代理对象调用方法时希望执行的动作，用于集中处理在动态代理类对象上的方法调用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> proxy     被代理的对象 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> method    要调用的方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args      方法调用时所需要参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br></pre></td></tr></table></figure></li><li><p><code>java.lang.reflect.Proxy</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造实现指定接口的代理类的一个新实例，所有方法会调用给定处理器对象的 invoke 方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> loader        指定当前目标对象使用类加载器，获取加载器的方法是固定的</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> interfaces    目标对象实现的接口的类型，使用泛型方式确认类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> h             InvocationHandler接口的子类的实例  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          InvocationHandler h)</span></span></span><br></pre></td></tr></table></figure><p>  <strong>推荐使用Guava中的 <code>com.google.common.reflect.Reflection</code>的<code>newProxy</code>方法，更加方便</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造实现指定接口的代理类的一个新实例，所有方法会调用给定处理器对象的 invoke 方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> interfaceType</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">newProxy</span><span class="params">(Class&lt;T&gt; interfaceType, InvocationHandler handler)</span></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 返回指定接口的代理类</span></span></span><br><span class="line"><span class="function"><span class="comment"> *</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @param loader        目标对象的类加载</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @param interfaces    目标对象实现的接口类型</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; <span class="title">getProxyClass</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                         Class&lt;?&gt;... interfaces)</span></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 获取指定代理对象所关联的调用处理器</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InvocationHandler <span class="title">getInvocationHandler</span><span class="params">(Object proxy)</span></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 判断cl是否为一个代理类</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isProxyClass</span><span class="params">(Class&lt;?&gt; cl)</span></span></span><br></pre></td></tr></table></figure></li></ul><h5 id="示例-1"><a href="#示例-1" class="headerlink" title="示例:"></a>示例:</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    User user = (User) Proxy.newProxyInstance(User.class.getClassLoader(), <span class="comment">// 传入ClassLoader</span></span><br><span class="line">                                              User.class.getInterfaces(), <span class="comment">// 传入要实现的接口</span></span><br><span class="line">                                              (object, method, para) -&gt; &#123;</span><br><span class="line">                                                System.out.println(method);</span><br><span class="line">                                                <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;getName&quot;</span>)) &#123;</span><br><span class="line">                                                  System.out.println(<span class="string">&quot;name is &quot;</span> + args[<span class="number">0</span>]);</span><br><span class="line">                                                &#125;</span><br><span class="line">                                                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                                              &#125;); <span class="comment">// 传入处理调用方法的InvocationHandler</span></span><br><span class="line"></span><br><span class="line">    user.getName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>在运行期动态创建一个interface实例的步骤如下：</p><ol><li>定义一个InvocationHandler实例，它负责实现接口的方法调用；</li><li>通过Proxy.newProxyInstance()创建interface实例，它需要3个参数：<ol><li>使用的ClassLoader，通常就是接口类的ClassLoader；</li><li>需要实现的接口数组，至少需要传入一个接口进去；</li><li>用来处理接口方法调用的InvocationHandler实例。</li></ol></li><li>将返回的Object强制转型为接口。</li></ol><h4 id="Cglib动态代理"><a href="#Cglib动态代理" class="headerlink" title="Cglib动态代理"></a>Cglib动态代理</h4><p><strong>Cglib动态代理又称子类代理</strong>，基于ASM机制实现，通过生成业务类的子类作为代理类。</p><h5 id="Cglib子类实现代理的方法"><a href="#Cglib子类实现代理的方法" class="headerlink" title="Cglib子类实现代理的方法:"></a>Cglib子类实现代理的方法:</h5><ol><li>需要引入cglib和asm的jar包文件，Spring的核心包里面已经包含了此包；</li><li>引入jar包后，就可以在内存中动态构建子类；</li><li><strong>代理的类不能为final，否则报错；</strong></li><li><strong>目标对象的方法如果为final/static，那么就不会被拦截，即不会执行目标对象额外的方法。</strong></li></ol><h5 id="示例-2"><a href="#示例-2" class="headerlink" title="示例:"></a>示例:</h5><ul><li><p>被代理类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserImpl</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;name is &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现MethodInterceptor接口生成方法拦截器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserMethodInterceptor</span>  <span class="keyword">implements</span> <span class="title">MethodInterceptor</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> object 表示要进行增强的对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 表示拦截的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> objects 数组表示参数列表，基本数据类型需要传入其包装类型，如int--&gt;Integer、long-Long、double--&gt;Double</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodProxy 表示对方法的代理，invokeSuper方法表示对被代理对象方法的调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Before: &quot;</span>  + method.getName());</span><br><span class="line">        <span class="comment">// 注意这里是调用 invokeSuper 而不是 invoke，否则死循环，methodProxy.invokesuper执行的是原始类的方法，method.invoke执行的是子类的方法</span></span><br><span class="line">        Object object = methodProxy.invokeSuper(o, objects);</span><br><span class="line">        System.out.println(<span class="string">&quot;After: &quot;</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Demo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">//继承被代理类</span></span><br><span class="line">        enhancer.setSuperclass(UserImpl.class);</span><br><span class="line">        <span class="comment">//设置回调</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> UserMethodInterceptor());</span><br><span class="line">        <span class="comment">//设置代理类对象</span></span><br><span class="line">        UserImpl user = (UserImpl) enhancer.create();</span><br><span class="line">        <span class="comment">//在调用代理类中方法时会被我们实现的方法拦截器进行拦截</span></span><br><span class="line">        user.getName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="在Spring的AOP编程中"><a href="#在Spring的AOP编程中" class="headerlink" title="在Spring的AOP编程中:"></a>在Spring的AOP编程中:</h4><ul><li>如果加入容器的目标对象有实现接口，用JDK代理</li><li>如果目标对象没有实现接口，用Cglib代理</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;代理模式&quot;&gt;&lt;a href=&quot;#代理模式&quot; class=&quot;headerlink&quot; title=&quot;代理模式&quot;&gt;&lt;/a&gt;代理模式&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型</summary>
      
    
    
    
    <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
    <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
