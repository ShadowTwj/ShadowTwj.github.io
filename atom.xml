<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tianwj&#39;s blog</title>
  
  
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-02-19T11:28:12.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>tianwj</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Web fragments</title>
    <link href="http://yoursite.com/2021/02/19/Web%20fragments/"/>
    <id>http://yoursite.com/2021/02/19/Web%20fragments/</id>
    <published>2021-02-19T10:23:07.000Z</published>
    <updated>2021-02-19T11:28:12.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p><code>Web fragments</code>是<code>servlet 3.0</code>开始支持的一个特性(可插性支持)，通过插件的方式很方便的扩充已有<code>Web</code>应用的功能，而不需要修改原有的应用</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><blockquote><p>Servlet 3.0 的部署描述文件 web.xml 的顶层标签 有一个 metadata-complete 属性，该属性指定当前的部署描述文件是否是完全的。如果设置为 true，则容器在部署时将只依赖部署描述文件，忽略所有的注解（同时也会跳过 web-fragment.xml 的扫描，亦即禁用可插性支持，具体请看后文关于 <a href="https://www.ibm.com/developerworks/cn/java/j-lo-servlet30/#major4">可插性支持</a> 的讲解）；如果不配置该属性，或者将其设置为 false，则表示启用注解支持（和可插性支持）。</p></blockquote><h3 id="Web-fragments语法和规则"><a href="#Web-fragments语法和规则" class="headerlink" title="Web fragments语法和规则"></a>Web fragments语法和规则</h3><ol><li><code>Web fragments</code> 需要有 <code>web-fragment.xml</code> 的部署描述文件，该文件必须存放在 <code>JAR</code> 文件的 <code>META-INF</code> 目录下，该部署描述文件可以包含一切可以在 <code>web.xml</code> 中定义的内容(过滤器、监听器与<code>Servlet</code>)</li><li>包含 <code>web-fragment.xml</code> 的 <code>JAR</code> 应该部署到 <code>Web</code> 应用程序的 <code>WEBINF/lib</code> 目录中</li><li><code>web-fragment.xml</code> 的根元素是 <code>&lt;web-fragment&gt;</code>，它可以包含 <code>DD(web.xml)</code> 中 <code>&lt;web-app&gt;</code> 元素的任何子元素。</li><li>每个 <code>web-fragment.xml</code> 都可以包含一个 <code>name</code> 元素。<code>name</code> 元素在所有 <code>Web</code> 片段中应该是唯一的，并且不应有任何循环引用或循环，否则容器将因有意义的错误中止应用程序部署。该名称将用于 <code>Web</code> 片段的任何排序。</li><li>可以使用元素 <code>&lt;absolute-ordering&gt;</code> 从 <code>web.xml</code> 中指定 <code>Web</code> 片段的顺序。也可以使用元素 <code>&lt;ordering&gt;</code> 从 <code>Web</code> 片段本身内部指定 <code>Web</code> 片段的顺序。在 <code>web.xml</code> 或 <code>Web</code> 片段中，元素按照声明的顺序加载。</li><li>并且如果 <code>web-fragment.xml</code> 和 <code>web.xml</code> 之间存在冲突，则 <code>web.xml</code> 将具有优先权。但是，如果两个片段之间存在冲突，则会引发错误。</li></ol><h3 id="配置内容"><a href="#配置内容" class="headerlink" title="配置内容"></a>配置内容</h3><blockquote><p>servlet、filter、listener三个可以定义任何一个，也可以全部定义</p></blockquote><ul><li><p>web-fragment.xml:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-fragment</span> <span class="attr">id</span>=<span class="string">&quot;WebFragment_ID&quot;</span> <span class="attr">version</span>=<span class="string">&quot;3.1&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-fragment_3_1.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Test<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- servlet --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>servletTest<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.xxx.xxx.servlets.ServletTest<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>servletTest<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- filter --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filterTest<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.xxx.xxx.FilterTest<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">async-supported</span>&gt;</span>true<span class="tag">&lt;/<span class="name">async-supported</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filterTest<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- listener --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>com.xxx.xxx.ListenerTest<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ordering</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 表示在项目所有之前进行初始化 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">before</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">others</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">before</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 表示在项目所有之后进行初始化 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">after</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">others</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">after</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ordering</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">web-fragment</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>Servlet:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletTest</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.service(req, resp);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.destroy();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Filter:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.Filter;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.FilterChain;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.FilterConfig;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterTest</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Listener:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.ServletRequestEvent;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletRequestListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListenerTest</span> <span class="keyword">implements</span> <span class="title">ServletRequestListener</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestDestroyed</span><span class="params">(ServletRequestEvent servletRequestEvent)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestInitialized</span><span class="params">(ServletRequestEvent servletRequestEvent)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Web fragments&lt;/code&gt;是&lt;code&gt;servlet 3.0&lt;/code&gt;开始支持的一个特性(可插性支持)，通过</summary>
      
    
    
    
    <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>服务缓存优化</title>
    <link href="http://yoursite.com/2021/02/03/%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2021/02/03/%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%96/</id>
    <published>2021-02-03T08:36:35.000Z</published>
    <updated>2021-03-04T09:22:10.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="服务介绍"><a href="#服务介绍" class="headerlink" title="服务介绍"></a>服务介绍</h3><p><code>bizconf</code>服务是公司所有业务的通用配置服务，用来保存所有企业、以及用户的业务配置。分为三个级别的配置，系统级、租户级和用户级。</p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>之前就有发现<code>bizconf</code>调用量比较大，需要优化缓存来降低调用，而最初现状是只在<code>server</code>端有<code>Redis</code>缓存</p><p>问题爆发点：元旦前最后几天，数据库负载高，导致<code>bizconf</code>服务调用耗时从几毫米升高到 20~30 毫秒，这时客户反馈系统库卡顿、反应慢，经过排查发现调用耗时长的请求和<code>bizconf</code>耗时曲线一致，各个业务都用调用<code>bizconf</code>，还有的业务调用多次，<code>bizconf</code>耗时上涨导致整个系统卡顿</p><h3 id="优化目标"><a href="#优化目标" class="headerlink" title="优化目标"></a>优化目标</h3><p>在<code>client</code>添加<code>jvm cahce</code>来降低调用，从而做到服务降级，前后共经过俩次优化，第一次优化因为缓存穿透的原因效果不明显，第二次优化后效果显著</p><p>优化前调用量：<br><img src="/images/%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%960.png"></p><h3 id="第一次优化"><a href="#第一次优化" class="headerlink" title="第一次优化"></a>第一次优化</h3><p>优化范围：在<code>server</code>和<code>client</code>中添加<code>jvm cache</code></p><p>使用缓存：使用<code>caffeine cache</code>，分级缓存，在<code>server</code>和<code>client</code>中分别添加两个<code>cache</code>，企业级和用户级的<code>cache</code></p><p>缓存设置：</p><ul><li>size：<code>server</code>中<code>cache size</code>为50000，<code>client</code>中<code>cache size</code>为5000，</li><li>过期时间：一个小时</li><li>过期策略：<code>expireAfterAccess(long, TimeUnit)</code>按最后访问时间计时</li><li>基于引用：<code>softValues()</code>设置为软引用</li></ul><p>优化后观察：<br>观察发现虽然添加了<code>jvm cache</code>，但是调用量降低的效果不明显，甚至可以说无效果</p><p>又观察<code>Redis</code>调用量和<code>db</code>调用量，发现<code>db</code>调用量和<code>Redis</code>调用量差不多，少的很有限，这时觉得这种情况不对，怀疑发生了缓存穿透，缓存没有生效</p><p><code>Redis</code>和<code>db</code>调用量：<br><img src="/images/%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%961.png"></p><p>经过排查发现一些数据多次的访问数据库，询问对应业务，是在判断企业的某些状态，如果返回<code>false</code>或不存在则认为没有，至此问题定位，缓存穿透导致大量访问数据库，从而解释了为什么优化的效果不明显</p><p>针对缓存穿透有了下面的第二次的优化</p><h3 id="第二次优化"><a href="#第二次优化" class="headerlink" title="第二次优化"></a>第二次优化</h3><p>针对缓存穿透一般有两种处理方式：使用布隆过滤器和缓存空值</p><h4 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h4><p>布隆过滤器具体可以参考<a href="https://blog.csdn.net/yuanlong122716/article/details/104402602">https://blog.csdn.net/yuanlong122716/article/details/104402602</a></p><p>布隆过滤器有两个非常重要的缺点：</p><ol><li>存在误算率，虽然不会错判但是会误判，什么意思呢，返回不存在则一定不存在，返回存在但是并不能判断一定存在</li><li>不可以删除</li></ol><p>如果使用布隆过滤器则有两个场景，保存白名单和黑名单：</p><ul><li>白名单：如果保存白名单，需要把数据库中所有的数据(表示存在的逻辑true)都保存起来，并且新增时需要同步的维护布隆过滤器数据，但因为是分布式服务需要保证所有服务都同步的维护布隆过滤器，难度比较大；同时布隆过滤器不支持删除，所以不考虑使用白名单</li><li>黑名单：如果保存黑名单，把不存在的数据保存起来，但因为会有误判，可能会把存在的数据认为不存在从而返回了空，从而使数据错误，所以不可取</li></ul><p>分析考虑，不采用布隆过滤器，采用缓存空值的方法更为有效和简单</p><h4 id="缓存空值"><a href="#缓存空值" class="headerlink" title="缓存空值"></a>缓存空值</h4><p>优化目标：<br><img src="/images/fs-paas-bizconf%E9%87%8D%E6%9E%84.png"></p><p>优化范围：在<code>client</code>中添加<code>jvm cache</code>，在<code>server</code>中只使用<code>Redis cache</code></p><p>使用缓存：第一次优化时<code>client</code>端缓存的数据有限，这次决定使用<code>ehcache</code>，可以缓存更大的数据量，同样也是分级缓存</p><p>缓存设置：</p><ul><li>size：每个<code>cache</code>堆内存5000条、堆外内存1MB、磁盘50MB</li><li>过期时间：<code>client</code>的<code>jvm cache</code>5小时；<code>server</code>的<code>redis</code>存在的数据24小时，不存在的空值半小时(防止大量不存在的数据把<code>Redis</code>搞崩，还可以更短一些)</li><li>过期策略：<code>ExpiryPolicyBuilder.timeToLiveExpiration(Duration timeToLive)</code> 按创建时间计时</li></ul><p>优化后观察：<br>这次优化后效果显著，调用量就下降了90%，预计所有业务方改完后调用量还会进一步下降</p><p>优化前后对比：<br><img src="/images/%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%962.png"></p><h3 id="审计日志优化"><a href="#审计日志优化" class="headerlink" title="审计日志优化"></a>审计日志优化</h3><p>优化缓存的同时，增加了审计日志，可以用来分析业务方的不合理调用</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;服务介绍&quot;&gt;&lt;a href=&quot;#服务介绍&quot; class=&quot;headerlink&quot; title=&quot;服务介绍&quot;&gt;&lt;/a&gt;服务介绍&lt;/h3&gt;&lt;p&gt;&lt;code&gt;bizconf&lt;/code&gt;服务是公司所有业务的通用配置服务，用来保存所有企业、以及用户的业务配置。分为三个级别</summary>
      
    
    
    
    <category term="优化" scheme="http://yoursite.com/categories/%E4%BC%98%E5%8C%96/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
    <category term="Cache" scheme="http://yoursite.com/tags/Cache/"/>
    
    <category term="优化" scheme="http://yoursite.com/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>服务日志优化</title>
    <link href="http://yoursite.com/2021/01/04/%E6%9C%8D%E5%8A%A1%E6%97%A5%E5%BF%97%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2021/01/04/%E6%9C%8D%E5%8A%A1%E6%97%A5%E5%BF%97%E4%BC%98%E5%8C%96/</id>
    <published>2021-01-04T09:20:59.000Z</published>
    <updated>2021-03-04T10:10:56.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><blockquote><p>功能权限服务之前经手的人比较多，不同人日志打印比较乱，并且服务日志打印量很大，但当需要排查问题时，大日志量 <code>grep</code> 困难、关键信息打印不全或没有打印等问题很痛苦，决定对日志方面进行统一的优化</p></blockquote><h3 id="优化目标"><a href="#优化目标" class="headerlink" title="优化目标"></a>优化目标</h3><ol><li>对服务日志量大、关键信息不全、代码中侵入式打印日志乱等问题进行优化</li><li>人员角色模块，经常有用户、业务不知道什么时候人员角色发生了变化，针对这个模块增加审计日志，便于观察分析调用、排查问题，给出证据</li><li>日志上报日志中心，使得服务发布后日志不丢失</li></ol><h3 id="优化记录"><a href="#优化记录" class="headerlink" title="优化记录"></a>优化记录</h3><h4 id="服务日志优化"><a href="#服务日志优化" class="headerlink" title="服务日志优化"></a>服务日志优化</h4><ul><li><p>日志级别<br><img src="/images/%E6%9C%8D%E5%8A%A1%E6%97%A5%E5%BF%97%E4%BC%98%E5%8C%960.png"></p></li><li><p>日志内容<br><code>traceId</code>，方法名，方法调用链路，每个方法耗时，入参，出参，异常堆栈</p></li><li><p>相关类<br>使用 <code>Spring AOP</code>、<code>ThreadLocal</code>、<code>Spring StopWatch</code>、<code>Annotation</code> 注解<br>支持两种日志打印方式，<code>AOP</code> 打印和手动调用<br><img src="/images/%E6%9C%8D%E5%8A%A1%E6%97%A5%E5%BF%97%E4%BC%98%E5%8C%961.png"></p></li><li><p>使用方式  </p></li></ul><ol><li>新建切面类，继承 <code>TraceLogAop</code> 抽象类</li><li>编写切点，使用环绕通知，切在需要打印日志的地方</li><li>通知中调用父类的 <code>around</code> 方法，传入 <code>ProceedingJoinPoint</code> 和打印耗时日志阈值</li><li>如需要特殊处理异常，则重写 <code>exceptionHandler</code> 方法<br><img src="/images/%E6%9C%8D%E5%8A%A1%E6%97%A5%E5%BF%97%E4%BC%98%E5%8C%962.png"></li><li>在需要打印 <code>info</code> 日志的方法上添加 <code>@InOutLog(&quot;info&quot;)</code> 注解，<code>debug</code> 级别不用添加，默认就是 <code>debug</code> 级别<br><img src="/images/%E6%9C%8D%E5%8A%A1%E6%97%A5%E5%BF%97%E4%BC%98%E5%8C%963.png"></li><li>也可以修改 <code>logback.xml</code> 文件，添加一个 <code>logger</code> 把日志打印到独立的文件中<br><img src="/images/%E6%9C%8D%E5%8A%A1%E6%97%A5%E5%BF%97%E4%BC%98%E5%8C%964.png"></li></ol><ul><li>优化效果<br>入参、出参效果<br><img src="/images/%E6%9C%8D%E5%8A%A1%E6%97%A5%E5%BF%97%E4%BC%98%E5%8C%965.jpg"><br>方法调用链路、耗时效果<br><img src="/images/%E6%9C%8D%E5%8A%A1%E6%97%A5%E5%BF%97%E4%BC%98%E5%8C%966.jpg"><br>根据详细的入参、出参可以快速、准确的排查问题；根据调用链路和耗时可以来分析耗时长的接口，以及耗时的占比，找到最耗时的方法，从而进行优化</li></ul><h4 id="添加审计日志"><a href="#添加审计日志" class="headerlink" title="添加审计日志"></a>添加审计日志</h4><blockquote><p>人员角色模块增加审计日志，上报ES，使用 kibana 展示，便于观察分析调用、排查问题，给出证据</p></blockquote><p><img src="/images/%E6%9C%8D%E5%8A%A1%E6%97%A5%E5%BF%97%E4%BC%98%E5%8C%967.jpg"></p><h4 id="上报日志中心"><a href="#上报日志中心" class="headerlink" title="上报日志中心"></a>上报日志中心</h4><p>有时查问题前一天晚上有过发版，日志信息丢失，导致查询问题困难，针对这种情况把日志上报到日志中心的 Grafana Explore中</p><hr><p>把日志整体优化后，再也没有了以前的苦恼，有什么问题一目了然(<em>^▽^</em>)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;功能权限服务之前经手的人比较多，不同人日志打印比较乱，并且服务日志打印量很大，但当需要排查问题时，大日志量 &lt;co</summary>
      
    
    
    
    <category term="优化" scheme="http://yoursite.com/categories/%E4%BC%98%E5%8C%96/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
    <category term="优化" scheme="http://yoursite.com/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Spring-AOP</title>
    <link href="http://yoursite.com/2020/12/02/Spring-AOP/"/>
    <id>http://yoursite.com/2020/12/02/Spring-AOP/</id>
    <published>2020-12-02T03:22:37.000Z</published>
    <updated>2020-12-07T11:48:02.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>面向切面编程(AOP)可以实现横切关注点与它们所影响对象之间的解耦，对业务逻辑没有任何侵入<br>使用场景有很多，如：日志、异常、声明式事物、安全、缓存等，包括但不限于这些场景<br>常见的AOP实现有<code>Spring-AOP</code>和<code>AspectJ</code>，<code>Spring-AOP</code>基于动态代理实现，主要总结一下<code>Spring-AOP</code></p></blockquote><p><img src="/images/Spring-AOP0.png"></p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="切面-Aspect"><a href="#切面-Aspect" class="headerlink" title="切面(Aspect)"></a>切面(Aspect)</h4><p>切面是通知和切点的结合，通知和切点共同定义了切面的全面内容————是什么，在何时和何处完成其功能</p><h5 id="通知-Advice"><a href="#通知-Advice" class="headerlink" title="通知(Advice)"></a>通知(Advice)</h5><p>切面的具体功能被称为通知，同时通知不仅定义了切面功能，还定义了切面何时使用，而根据使用时机可以分为5种类型的通知：</p><ul><li>前置通知(Before)：在目标方法被调用之前调用通知功能</li><li>后置通知(After)：在目标方法完成之后调用通知，此时不会关心方法的输出是什么</li><li>返回通知(After-returning)：在目标方法成功执行之后调用通知</li><li>异常通知(After-throwing)：在目标方法抛出异常后调用通知</li><li>环绕通知(Around)：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。环绕通知是最强大的通知类型</li></ul><blockquote><p>在 <code>Spring-AOP</code> 中的环绕通知必须有 <code>ProceedingJoinPoint</code> 这个对象参数，通过它的 <code>proceed()</code> 方法来调用被通知的方法</p></blockquote><h5 id="切点-Poincut"><a href="#切点-Poincut" class="headerlink" title="切点(Poincut)"></a>切点(Poincut)</h5><p>通知定义了切面的 “什么” 和 “何时” ，切点则是定义了切面的 ”何处“</p><p>切点定义了通知被应用的具体位置(在哪些连接点)</p><h4 id="连接点-Join-point"><a href="#连接点-Join-point" class="headerlink" title="连接点(Join point)"></a>连接点(Join point)</h4><p>连接点是在应用执行过程中能够应用通知的 ”所有点“</p><p>连接点可以是调用方法时、抛出异常时、甚至修改一个字段时，但因为<code>Spring-AOP</code>基于动态代理，所以<code>Spring</code>只支持方法的连接点，而<code>AspectJ</code>和<code>JBoss</code>的AOP框架还提供了字段和构造器接入点。</p><p>但是方法拦截则满足了大部分的需求，如果需要方法拦截之外的连接点可以利用<code>AspectJ</code>来补充<code>Spring-AOP</code>的功能</p><h4 id="引入-Introduction"><a href="#引入-Introduction" class="headerlink" title="引入(Introduction)"></a>引入(Introduction)</h4><p>添加方法或字段到被通知的类</p><h4 id="织入-Weaving"><a href="#织入-Weaving" class="headerlink" title="织入(Weaving)"></a>织入(Weaving)</h4><p>织入是把切面应用到目标对象并创建新的代理对象的过程</p><p>织入可以在对象生命周期的多个点织入：</p><ul><li>编译期：切面在目标类编译期被织入。这种需要特殊的编译器。<code>AspectJ</code>的织入编译器就是以这种方式织入</li><li>类加载期：切面在目标类加载到JVM时被织入。这种方式需要特殊的类加载器，可以在目标类被引入应用之前增强该目标类的字节码。<code>AspectJ 5</code>的加载时织入就支持这种方式织入</li><li>运行期：切面在应用运行的某个时刻被织入。在织入时，AOP容器会为目标对象动态地创建一个代理对象。**<code>Spring-AOP</code>就是以这种方式织入切面的**</li></ul><h3 id="定义切点"><a href="#定义切点" class="headerlink" title="定义切点"></a>定义切点</h3><blockquote><p>切点用来定位使用通知的地方，在<code>Spring-AOP</code>中使用的是<code>AspectJ</code>的切点表达式语言来定义切点，但是<code>Spring</code>仅支持<code>AspectJ</code>切点指示器的一个子集</p></blockquote><h4 id="切点表达式"><a href="#切点表达式" class="headerlink" title="切点表达式"></a>切点表达式</h4><h5 id="切点指示器"><a href="#切点指示器" class="headerlink" title="切点指示器"></a>切点指示器</h5><p><code>Spring-AOP</code>所支持的<code>AspectJ</code>的切点指示器</p><table><thead><tr><th>AspectJ 指示器</th><th>描述</th></tr></thead><tbody><tr><td>arg()</td><td>限制连接点匹配参数为指定类型的执行方法</td></tr><tr><td>@args()</td><td>限制连接点匹配参数由指定注解标注的执行方法</td></tr><tr><td>execution()</td><td>用于匹配是连接点的执行方法</td></tr><tr><td>this()</td><td>限制连接点匹配AOP代理的bean引用为指定类型的类</td></tr><tr><td>target</td><td>限制连接点匹配目标对象为指定类型的类</td></tr><tr><td>@target()</td><td>限制连接点匹配特定的执行对象，这些对象对应的类要具有指定类 型的注解</td></tr><tr><td>within()</td><td>限制连接点匹配指定的类型</td></tr><tr><td>@within()</td><td>限制连接点匹配指定注解所标注的类型（当使用Spring AOP时，方 法定义在由指定的注解所标注的类里）</td></tr><tr><td>@annotation</td><td>限定匹配带有指定注解的连接点</td></tr></tbody></table><p><strong>只有<code>execution</code>指示器是实际执行匹配的，而其他的指示器都是用来限制匹配的</strong></p><h5 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h5><p>支持<code>and</code>、<code>or</code>、<code>not</code>关系来连接指示器</p><p>在POJO中使用<code>&amp;&amp;</code>、<code>||</code>、<code>!</code>分别代表<code>and</code>、<code>or</code>、<code>not</code>关系</p><p>在XML中直接使用<code>and</code>、<code>or</code>、<code>not</code>来连接指示器</p><p><img src="/images/Spring-AOP1.jpg"></p><h4 id="bean指示器"><a href="#bean指示器" class="headerlink" title="bean指示器"></a>bean指示器</h4><p>除去<code>AspectJ</code>指示器外，<code>Spring</code>还引入了一个新的<code>bean()</code>指示器，用来在切点表达式中使用bean的ID来标识bean。<code>bean()</code>使用<code>bean Id</code>或<code>bean名称</code>作为参数来限制切点只匹配特定的<code>bean</code></p><h3 id="注解创建切面"><a href="#注解创建切面" class="headerlink" title="注解创建切面"></a>注解创建切面</h3><blockquote><p><code>AspectJ 5</code>支持使用注解来创建切面，使用少量的注解就可以把任意类转变为切面</p></blockquote><blockquote><p><code>Spring</code>同时支持<code>AspectJ</code>注解驱动的切面</p></blockquote><h4 id="AOP配置注解"><a href="#AOP配置注解" class="headerlink" title="AOP配置注解"></a>AOP配置注解</h4><h5 id="Aspect"><a href="#Aspect" class="headerlink" title="@Aspect"></a>@Aspect</h5><p>表明该类不仅仅是个POJO，还是一个切面</p><h5 id="通知注解"><a href="#通知注解" class="headerlink" title="通知注解"></a>通知注解</h5><blockquote><p>通知注解对应五种通知类型，来声明通知方法</p></blockquote><table><thead><tr><th>注解</th><th>通知</th></tr></thead><tbody><tr><td>@After</td><td>通知方法会在目标方法返回或抛出异常后调用</td></tr><tr><td>@AfterReturning</td><td>通知方法会在目标方法返回后调用</td></tr><tr><td>@AfterThrowing</td><td>通知方法会在目标方法抛出异常后调用</td></tr><tr><td>@Around</td><td>通知方法会将目标方法封装起来</td></tr><tr><td>@Before</td><td>通知方法会在目标方法调用之前执行</td></tr></tbody></table><h5 id="Pointcut"><a href="#Pointcut" class="headerlink" title="@Pointcut"></a>@Pointcut</h5><p><code>@Pointcut</code>注解可以在一个<code>@AspectJ</code>切面内定义可重用的切点</p><p>E.g.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Audience</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Pointcut(&quot;execution(** concert.Performance.perform(..))&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performce</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Before(&quot;performce()&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">silenceCellPhones</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Silencing cell phones&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Around(&quot;performce()&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takeSeats</span><span class="params">(ProceedingJoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">joinPoint.proceed(joinPoint.getArgs())</span><br><span class="line">    System.out.println(<span class="string">&quot;Taking seats&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@AfterReturning(&quot;performce()&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">applause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;CLAP CLAP CLAP!!!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@AfterThrowing(&quot;performce()&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demandRefund</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Demanding a refund&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过在 <code>performance()</code> 方法上添加 <code>@Pointcut</code> 注解，这样就可以在任何的切点表达式中使用 <code>performance()</code> 了</p><p><code>performance()</code> 方法的实际内容并不重要，在这里它实际上应该是空的。其实该方法本身只是一个标识，供 <code>@Pointcut</code> 注解依附。</p><h4 id="通过注解引入新功能"><a href="#通过注解引入新功能" class="headerlink" title="通过注解引入新功能"></a>通过注解引入新功能</h4><blockquote><p>类似<code>Groovy</code>不直接修改对象或类的定义就能为对象或类增加新的方法，虽然Java不是动态语言，但是通过<code>AOP</code>引用新的接口则可以实现其功能</p></blockquote><blockquote><p>但是当引入接口的方法被调用时，代理会把此调用委托给实现了新接口的某个其他对象。实际上，<strong>一个<code>bean</code>的实现被拆分到了多个类中</strong></p></blockquote><p>通过<code>@DeclareParents</code>注解可以将新的接口引入到<code>bean</code>中</p><p>定义新的接口:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> concert;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Encoreable</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">performEncore</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建切面引入接口:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> concert;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.DeclareParents;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EncodeableIntroducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@DeclareParents(value=&quot;concert.Performce+&quot;,</span></span><br><span class="line"><span class="meta">                  defaultImpl=DefaultEncoreable.class)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Encoreable encoreable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@DeclareParents</code> 注解由三部分组成：</p><ul><li><code>value</code> 属性指定了哪种类型的 <code>bean</code> 要引入该接口。在本例中，也就是所有实现 <code>Performance</code> 的类型。（标记符后面的加号表示是 <code>Performance</code> 的所有子类型，而不是 Performance 本身。）</li><li><code>defaultImpl</code> 属性指定了为引入功能提供实现的类。在这里，我们指定的是 <code>DefaultEncoreable</code> 提供实现。</li><li><code>@DeclareParents</code> 注解所标注的静态属性指明了要引入了接口。在这里，我们所引入的是 Encoreable 接口。</li></ul><h3 id="XML中声明切面"><a href="#XML中声明切面" class="headerlink" title="XML中声明切面"></a>XML中声明切面</h3><h4 id="AOP配置元素"><a href="#AOP配置元素" class="headerlink" title="AOP配置元素"></a>AOP配置元素</h4><p>在 Spring 的 aop 命名空间中，提供了多个元素用来在 XML 中声明切面</p><table><thead><tr><th>AOP 配置元素</th><th>用途</th></tr></thead><tbody><tr><td>&lt;aop:advisor&gt;</td><td>定义 AOP 通知器</td></tr><tr><td>&lt;aop:after&gt;</td><td>定义 AOP 后置通知（不管被通知的方法是否执行成功）</td></tr><tr><td>&lt;aop:after-returning&gt;</td><td>定义 AOP 返回通知</td></tr><tr><td>&lt;aop:after-throwing&gt;</td><td>定义 AOP 异常通知</td></tr><tr><td>&lt;aop:around&gt;</td><td>定义 AOP 环绕通知</td></tr><tr><td>&lt;aop:aspect&gt;</td><td>定义一个切面</td></tr><tr><td>&lt;aop:aspectj-autoproxy&gt;</td><td>启用 @AspectJ 注解驱动的切面</td></tr><tr><td>&lt;aop:before&gt;</td><td>定义一个 AOP 前置通知</td></tr><tr><td>&lt;aop:config&gt;</td><td>顶层的 AOP 配置元素。大多数的元素必须包含在元素内</td></tr><tr><td>&lt;aop:declare-parents&gt;</td><td>以透明的方式为被通知的对象引入额外的接口</td></tr><tr><td>&lt;aop:pointcut&gt;</td><td>定义一个切点</td></tr></tbody></table><p>E.g.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;audience&quot;</span>&gt;</span></span><br><span class="line">    &lt;aop:pointcut</span><br><span class="line">      id=&quot;performance&quot;</span><br><span class="line">      expressions=&quot;execution(** concert.Performance.perform(..))&quot; /&gt;</span><br><span class="line">  </span><br><span class="line">    &lt;aop:before</span><br><span class="line">      pointcut-ref=&quot;performance&quot;</span><br><span class="line">      method=&quot;silenceCellPhones&quot; /&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;aop:around</span><br><span class="line">      pointcut-ref=&quot;performance&quot;</span><br><span class="line">      method=&quot;takeSeats&quot; /&gt;</span><br><span class="line">      </span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:after-returning</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">pointcut</span>=<span class="string">&quot;execution(** concert.Performance.perform(..))&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">method</span>=<span class="string">&quot;applause&quot;</span> /&gt;</span></span><br><span class="line">      </span><br><span class="line">    &lt;aop:after-throwing</span><br><span class="line">      pointcut-ref=&quot;performance&quot;</span><br><span class="line">      method=&quot;demandRefund&quot; /&gt;</span><br><span class="line">      </span><br><span class="line">  <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="通过切面引入新功能"><a href="#通过切面引入新功能" class="headerlink" title="通过切面引入新功能"></a>通过切面引入新功能</h4><p>使用 <code>@DeclareParents</code> 注解可以为被通知的方法引入新的方法，使用 <code>Spring aop</code> 命名空间中的 <code>&lt;aop:declare-parents&gt;</code> 元素，可以实现相同的功能</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">  &lt;aop:delate-parents</span><br><span class="line">    types-matching=&quot;concert.Performance+&quot;</span><br><span class="line">    implement-interface=&quot;concert.Encoreable&quot;</span><br><span class="line">    default-impl=&quot;concert.DefaultEncoreable&quot; /&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>types-matching</code>类型匹配，匹配为哪些<code>bean</code>引入接口</li><li><code>implement-interface</code>指定新加的接口</li><li><code>default-impl</code>用全限定类名来显式指定新加接口的实现</li><li><code>delegate-ref</code>还支持引用了一个<code>Spring bean</code>作为引入接口的实现</li></ul><h3 id="启用AspectJ自动代理"><a href="#启用AspectJ自动代理" class="headerlink" title="启用AspectJ自动代理"></a>启用AspectJ自动代理</h3><p><strong>无论是注解创建、还是XML声明切面，都需要启用自动代理，来创建切面的代理，否则切面不会生效</strong></p><p>启用自动代理有两种方式：</p><ul><li><p>在<code>JavaConfig</code>中启用</p><blockquote><p>配置类的类级别上通过使用 <code>@EnableAspectJAutoProxy</code> 注解启用自动代理功能</p></blockquote></li><li><p> 在<code>XML</code>中启用</p><blockquote><p>使用 Spring aop 命名空间中的 <code>&lt;aop:aspectj-autoproxy/&gt;</code> 元素</p></blockquote></li></ul><h3 id="注入AspectJ切面"><a href="#注入AspectJ切面" class="headerlink" title="注入AspectJ切面"></a>注入AspectJ切面</h3><blockquote><p>虽然 <code>Spring AOP</code> 能够满足许多应用的切面需求，但是与 <code>AspectJ</code> 相比，<code>Spring AOP</code> 是一个功能比较弱的 <code>AOP</code> 解决方案。<code>AspectJ</code> 提供了 <code>Spring AOP</code> 所不能支持的许多类型的切点</p></blockquote><p><code>AspectJ</code> 可以织入到任意的Java应用程序中，而我们可以借助 <code>Spring</code> 的依赖注入把 <code>bean</code> 装配进 <code>AspectJ</code> 切面中，这样更为方便</p><h4 id="用AspectJ实现切面"><a href="#用AspectJ实现切面" class="headerlink" title="用AspectJ实现切面"></a>用AspectJ实现切面</h4><p>创建 <code>AspectJ</code> 的切面需要使用扩展的Java语言</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.aspect.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> aspect AspectInject &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AspectInject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Pointcut（切入点）：定义了相应Advice要发生的地方。</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 定义切入点的常用的两种方式：</span></span><br><span class="line"><span class="comment">     * 1、使用正则表达式。</span></span><br><span class="line"><span class="comment">     * 2、使用AspectJ表达式（Https://www.iteye.com/blog/jinnianshilongnian-1415606）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">pointcut <span class="title">printInfo</span><span class="params">()</span>:<span class="title">execution</span><span class="params">(* xxx.xxx.xxx.xxx.printInfo(..)</span>)</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造器切点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">pointcut <span class="title">constructEntity</span><span class="params">()</span>:<span class="title">execution</span><span class="params">(xxx.xxx.xxx.xxx.User.new()</span>)</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Advice定义了在Pointcut（切入点）具体要做的操作。</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 切入点在AOP中有多种类型，但在Spring中只有方法类型。</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * before advice, 前置。</span></span><br><span class="line"><span class="comment">     * after return advice, 后置（出错不执行）。</span></span><br><span class="line"><span class="comment">     * after throwing advice, 后置（出错才执行）。</span></span><br><span class="line"><span class="comment">     * after(final) advice, 后置（怎么都执行）。</span></span><br><span class="line"><span class="comment">     * around advice, 环绕（前后都执行）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"> </span><br><span class="line">    before():printInfo()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------printInfo()方法的前置------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    after():printInfo()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------printInfo()的后置------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    before():constructEntity()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------new User()时候的前置------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    after():constructEntity()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-------new User()时候的后置------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用aspectOf-方法注入"><a href="#使用aspectOf-方法注入" class="headerlink" title="使用aspectOf()方法注入"></a>使用aspectOf()方法注入</h4><p><code>Spring bean</code> 由 <code>Spring</code> 容器初始化，但是 <code>AspectJ</code> 切面是由 <code>AspectJ</code> 在运行期创建的。等到 <code>Spring</code> 有机会为 <code>AspectJ</code> 切面注入 <code>bean</code> 时，切面已经被实例化了。</p><p>所有的 <code>AspectJ</code> 切面都提供了一个静态的 <code>aspectOf()</code> 方法，该方法返回切面的一个单例。所以为了获得切面的实例，我们必须使用 <code>factory-method</code> 来调用 <code>asepctOf()</code> 方法</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.aspect.test.AspectInject&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;aspectOf&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li>《Spring 实战（第 4 版）》</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;面向切面编程(AOP)可以实现横切关注点与它们所影响对象之间的解耦，对业务逻辑没有任何侵入&lt;br&gt;使用场景有很多，如：日志、异常、声明式事物、安全、缓存等，包括但不限于这些场景&lt;br&gt;常见的AOP实现有&lt;code&gt;Spring-AOP&lt;/code&gt;</summary>
      
    
    
    
    <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
    <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>ssh-ControlMaster</title>
    <link href="http://yoursite.com/2020/11/18/ssh-ControlMaster/"/>
    <id>http://yoursite.com/2020/11/18/ssh-ControlMaster/</id>
    <published>2020-11-18T11:13:59.000Z</published>
    <updated>2020-11-19T12:18:58.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><code>ssh</code> 的配置文件<code>~/.ssh/config</code>可以大大的简化 <code>ssh</code> 的一些操作，如果没有这个文件则自己在 <code>~/.ssh/</code> 下<code>touch</code>一个即可</p></blockquote><blockquote><p>该文主要介绍使用 <code>ControlMaster</code> 来复用连接，每次<code>ssh</code>一台服务器时不需要每次输入密码</p></blockquote><h3 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h3><h4 id="ControlMaster"><a href="#ControlMaster" class="headerlink" title="ControlMaster"></a>ControlMaster</h4><blockquote><p>SSH支持 <code>ControlMaster</code> 模式，单一网络共享多个seesion，复用之前建立的连接，</p></blockquote><p>值可以为 <code>no(default)/yes/ask/auto</code>需要和 <code>ControlPath</code> 配合使用，当值为 yes 时，ssh 会监听该路径下的 <code>control socket</code>，多个 session 会去连接该 socket，则会尽可能的复用连接</p><h4 id="ControlPath"><a href="#ControlPath" class="headerlink" title="ControlPath"></a>ControlPath</h4><blockquote><p>指定 control socket 的路径</p></blockquote><p>值可以使用下面这些参数：</p><ul><li>%L 本地主机名的第一个组件</li><li>%l 本地主机名（包括域名）</li><li>%h 远程主机名（命令行输入）</li><li>%n 远程原始主机名</li><li>%p 远程主机端口</li><li>%r 远程登录用户名</li><li>%u 本地 ssh 正在使用的用户名</li><li>%i 本地 ssh 正在使用 uid</li><li>%C 值为 %l%h%p%r 的 hash</li></ul><h4 id="ControlPersist"><a href="#ControlPersist" class="headerlink" title="ControlPersist"></a>ControlPersist</h4><blockquote><p>结合 <code>ControlMaster</code> 使用，指定连接打开后后台保持的时间。值可以为 no/yes/整数，单位 s。如果为 no，最初的客户端关闭就关闭。如果 yes/0，无限期的，直到杀死或通过其它机制，如：<code>ssh -O exit</code></p></blockquote><h3 id="实际配置"><a href="#实际配置" class="headerlink" title="实际配置"></a>实际配置</h3><h4 id="ssh-config文件"><a href="#ssh-config文件" class="headerlink" title="~/.ssh/config文件"></a>~/.ssh/config文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">host *</span><br><span class="line">ControlPersist yes</span><br><span class="line">ControlMaster auto</span><br><span class="line">ControlPath ~&#x2F;.ssh&#x2F;master-%r@%h:%p</span><br></pre></td></tr></table></figure><ul><li><code>host</code> 标识匹配的主机名，<code>*</code>代表所有，也可匹配的主机</li><li><code>ControlPersist</code> 保持连接，客户端关闭并不会真的关闭连接</li><li><code>ControlMaster</code> 开启连接复用</li><li><code>ControlPath</code> 指定<code>control socket</code>的路径，当开启<code>ssh</code>连接后，会在<code>~/.ssh/</code>下产生一个master开头的文件，当有这这个文件时，再次<code>ssh</code>连接同一个服务器时判断有该文件则不需要输入密码</li></ul><h4 id="修改expect脚本"><a href="#修改expect脚本" class="headerlink" title="修改expect脚本"></a>修改expect脚本</h4><p>经常会使用<code>expect</code>脚本来连接服务器，开启<code>ControlMaster</code>模式后可能会使之前的<code>expect</code>脚本有问题，所以需要修改<code>expect</code>脚本</p><ul><li><p>before</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/expect</span></span><br><span class="line">set host [lindex $argv 0]</span><br><span class="line">set username &quot;&quot;</span><br><span class="line"></span><br><span class="line">spawn ssh $username@$host</span><br><span class="line">expect &#123;</span><br><span class="line">&quot;*yes/no)? &quot; &#123;send &quot;yes\n&quot;; exp_continue&#125;</span><br><span class="line">&quot;password:&quot; &#123;send &quot;password&quot;&#125;</span><br><span class="line">&#125;</span><br><span class="line">interact</span><br></pre></td></tr></table></figure></li><li><p>after</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/expect</span></span><br><span class="line">set host [lindex $argv 0]</span><br><span class="line">set username &quot;&quot;</span><br><span class="line"></span><br><span class="line">set controlMaster [file exists ~/.ssh/master-$username@$host:22]</span><br><span class="line"></span><br><span class="line">if &#123; $controlMaster&#125; &#123;</span><br><span class="line">spawn ssh $username@$host</span><br><span class="line">&#125; else &#123;</span><br><span class="line">spawn ssh $username@$host</span><br><span class="line">expect &#123;</span><br><span class="line">    &quot;*yes/no)? &quot; &#123;send &quot;yes\n&quot;; exp_continue&#125;</span><br><span class="line">&quot;password:&quot; &#123;send &quot;password&quot;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">interact</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;ssh&lt;/code&gt; 的配置文件&lt;code&gt;~/.ssh/config&lt;/code&gt;可以大大的简化 &lt;code&gt;ssh&lt;/code&gt; 的一些操作，如果没有这个文件则自己在 &lt;code&gt;~/.ssh/&lt;/code&gt; 下&lt;code&gt;touc</summary>
      
    
    
    
    <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Annotation注解</title>
    <link href="http://yoursite.com/2020/11/13/Annotation%E6%B3%A8%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/11/13/Annotation%E6%B3%A8%E8%A7%A3/</id>
    <published>2020-11-13T04:33:31.000Z</published>
    <updated>2020-11-13T04:54:41.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="三种内置注解"><a href="#三种内置注解" class="headerlink" title="三种内置注解:"></a>三种内置注解:</h4><ol><li><p><code>@Override</code>表示当前的方法定义将覆盖超类中的方法。</p></li><li><p><code>@Deprecated</code>使用了注解为它的元素编译器将发出警告，因为注解@Deprecated是不赞成使用的代码，被弃用的代码。</p></li><li><p><code>@SuppressWarnings</code>关闭不当编辑器警告信息。</p></li></ol><h4 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h4><blockquote><p>定义注解的注解,是java提供给我们用于定义注解的基本注解.在<code>java.lang.annotation</code>包</p></blockquote><h5 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h5><blockquote><p>用于定义注解的作用目标，表示该注解可以用于什么地方，ElementType参数有：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Target(ElementType.TYPE)           用于接口(注解本质上也是接口),类,枚举</span><br><span class="line">@Target(ElementType.FIELD)          用于字段,枚举常量</span><br><span class="line">@Target(ElementType.METHOD)         用于方法</span><br><span class="line">@Target(ElementType.PARAMETER)      用于方法参数</span><br><span class="line">@Target(ElementType.CONSTRUCTOR)    用于构造参数</span><br><span class="line">@Target(ElementType.LOCAL_VARIABLE) 用于局部变量</span><br><span class="line">@Target(ElementType.ANNOTATION_TYPE)用于注解</span><br><span class="line">@Target(ElementType.PACKAGE)        用于包</span><br></pre></td></tr></table></figure><h5 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h5><blockquote><p>用于定义注解保留策略，即定义的注解类在什么时候存在(源码阶段 or 编译后 or 运行阶段).</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.SOURCE)注解仅在源码中保留,class文件中不存在</span><br><span class="line">@Retention(RetentionPolicy.CLASS)注解在源码和class文件中都存在,但运行时不存在,即运行时无法获得,该策略也是默认的保留策略</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)注解在源码,class文件中存在且运行时可以通过反射机制获取到</span><br></pre></td></tr></table></figure><h5 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h5><blockquote><p>用于描述其它类型的annotation应该被javadoc文档化,出现在api doc中</p></blockquote><h5 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h5><blockquote><p>允许子类继承父类中的注解</p></blockquote><h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE&#125;)   ---作用范围 Class</span><br><span class="line">@Retention(RetentionPolicy.CLASS)  ---生命周期：仅保留到.class文件</span><br><span class="line">public @interface 注解名 &#123;定义体&#125;</span><br></pre></td></tr></table></figure><p>像<code>@Override</code>这样,没有成员定义的注解称之为标记注解.</p><p>自定义注解后，需要处理注解，注解实现的具体逻辑需要自己来写注解处理器</p><h3 id="注解处理器"><a href="#注解处理器" class="headerlink" title="注解处理器:"></a>注解处理器:</h3><p>注解处理器可以分为运行时注解处理和编译时注解处理器.运行时处理器需要借助反射机制实现,而编译时处理器则需要借助APT来实现.</p><p>无论是运行时注解处理器还是编译时注解处理器,主要工作都是读取注解然后处理特定注解</p><h4 id="运行时注解处理器"><a href="#运行时注解处理器" class="headerlink" title="运行时注解处理器"></a>运行时注解处理器</h4><p>运行时注解属性为<code>@Retention(RetentionPolicy.RUNTIME)</code>的注解.</p><p>为了运行时能准确获取到注解的相关信息，Java在java.lang.reflect 反射包下新增了<code>AnnotatedElement</code>接口，所有程序元素的(Class,Method)都实现了该接口，通过该接口提供的方法可以利用反射技术地读取注解的信息</p><p>常用<code>AnnotatedElement</code>中的反射方法:</p><table><thead><tr><th align="center">方法</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center"><T extends Annotation> T getAnnotation(Class<T> annotationClass)</td><td align="center">返回该元素上存在的制定类型的注解</td></tr><tr><td align="center">Annotation[] getAnnotations()</td><td align="center">返回该元素上存在的所有注解</td></tr><tr><td align="center">default <T extends Annotation> T[] getAnnotationsByType(Class<T> annotationClass)</td><td align="center">返回该元素指定类型的注解</td></tr><tr><td align="center">default <T extends Annotation> T getDeclaredAnnotation(Class<T> annotationClass)</td><td align="center">返回直接存在与该元素上的所有注释</td></tr><tr><td align="center">default <T extends Annotation> T[] getDeclaredAnnotationsByType(Class<T> annotationClass)</td><td align="center">返回直接存在该元素岸上某类型的注释</td></tr><tr><td align="center">Annotation[] getDeclaredAnnotations()</td><td align="center">返回直接存在与该元素上的所有注释</td></tr></tbody></table><p>通过这些反射方法获取到注解信息，然后对其进行业务操作即可</p><h4 id="编译时注解处理器"><a href="#编译时注解处理器" class="headerlink" title="编译时注解处理器"></a>编译时注解处理器</h4><blockquote><p>(Annotation Processor Tool)APT,处理注解来生成代码<br>获取注解及生成代码都是在代码编译时候完成的，相比反射在运行时处理注解大大提高了程序性能</p></blockquote><p>不同于运行时注解处理器，编写编译时注解处理器分两步:</p><h5 id="继承AbstractProcessor，实现自己的注解处理器"><a href="#继承AbstractProcessor，实现自己的注解处理器" class="headerlink" title="继承AbstractProcessor，实现自己的注解处理器"></a>继承AbstractProcessor，实现自己的注解处理器</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RouteProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ProcessingEnvironment env)</span></span>&#123; </span><br><span class="line">        <span class="keyword">super</span>.init(processingEnv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annoations, RoundEnvironment env)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">getSupportedAnnotationTypes</span><span class="params">()</span> </span>&#123; </span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">super</span>.getSupportedAnnotationTypes();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SourceVersion <span class="title">getSupportedSourceVersion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">super</span>.getSupportedSourceVersion();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">方法</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">init(ProcessingEnvironment processingEnv)</td><td align="center">该方法有注解处理器自动调用，其中ProcessingEnvironment类提供了很多有用的工具类：Filter，Types，Elements，Messager等</td></tr><tr><td align="center">getSupportedAnnotationTypes()</td><td align="center">该方法返回字符串的集合表示该处理器用于处理那些注解</td></tr><tr><td align="center">getSupportedSourceVersion()</td><td align="center">该方法用来指定支持的java版本，一般来说我们都是支持到最新版本，因此直接返回SourceVersion.latestSupported(）即可</td></tr><tr><td align="center">process(Set annotations, RoundEnvironment roundEnv)</td><td align="center">该方法是注解处理器处理注解的主要地方，我们需要在这里写扫描和处理注解的代码，以及最终生成的java文件。其中需要深入的是RoundEnvironment类，该用于查找出程序元素上使用的注解</td></tr></tbody></table><h5 id="注册处理器-并打成jar包"><a href="#注册处理器-并打成jar包" class="headerlink" title="注册处理器,并打成jar包"></a>注册处理器,并打成jar包</h5><blockquote><p>注解和注解处理器必须要新建jar包，然后通过jar包引用。</p></blockquote><p>为了让java编译器或能够找到自定义的注解处理器我们需要对其进行注册和打包：自定义的处理器需要被打成一个jar，并且需要在jar包的<code>META-INF/services</code>路径下中创建一个固定的文件<code>javax.annotation.processing.Processor</code>,在<code>javax.annotation.processing.Processor</code>文件中需要填写自定义处理器的完整路径名，有几个处理器就需要填写几个</p><blockquote><p>AbstractProcessor中生成java类，可以使用JavaPoet开源库进行编写，提升效率</p></blockquote><p>常用的<code>Lombok</code>来消除代码冗余，则是通过APT来实现的<br><img src="/images/Annotation%E6%B3%A8%E8%A7%A3.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h3&gt;&lt;h4 id=&quot;三种内置注解&quot;&gt;&lt;a href=&quot;#三种内置注解&quot; class=&quot;headerlink&quot; title=&quot;三种内置注</summary>
      
    
    
    
    <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>创建文档站点</title>
    <link href="http://yoursite.com/2020/10/23/%E5%88%9B%E5%BB%BA%E6%96%87%E6%A1%A3%E7%AB%99%E7%82%B9/"/>
    <id>http://yoursite.com/2020/10/23/%E5%88%9B%E5%BB%BA%E6%96%87%E6%A1%A3%E7%AB%99%E7%82%B9/</id>
    <published>2020-10-23T08:47:20.000Z</published>
    <updated>2020-10-23T10:14:17.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>经常看到一些文档的网站很简洁，于是便调研了一下，自己动手基于<code>GitHub Pages</code>搭建了一个文档站点</p></blockquote><h3 id="文档站点生成器"><a href="#文档站点生成器" class="headerlink" title="文档站点生成器"></a>文档站点生成器</h3><blockquote><p>调研了5种文档站点生成器</p></blockquote><ol><li><p><a href="https://docsify.js.org/#/zh-cn/">docsify</a><br>不同于 <code>GitBook</code>、<code>vuePress</code>、<code>Hexo</code> 的地方是它不会生成静态的 .html 文件，所有转换工作都是在运行时。无需构建，写完文档直接发布</p></li><li><p><a href="https://docute.org/zh/">docute</a><br><code>docute</code> 和 <code>docsify</code> 几乎相同，都是运行时驱动，但具有不同的 UI 和不同的使用方式，Docute（60kB）比 Docisfy（20kB）大 3 倍，因为<code>docute</code>使用了 Vue，Vue Router 和 Vuex，而 <code>Docsify</code> 使用的是 vanilla JavaScript。</p></li><li><p><a href="https://vuepress.vuejs.org/zh/">vuePress</a><br>使用vue开发，每一个由 <code>VuePress</code> 生成的页面都带有预渲染好的 HTML，也因此具有非常好的加载性能和搜索引擎优化（SEO）</p></li><li><p><a href="https://rust-lang.github.io/mdBook/">mdBook</a><br><code>mdBook</code> 是一个命令行工具和<code>Rust crate</code>。可将Markdown文件创建为书籍。它与<code>Gitbook</code>非常相似,但用<code>Rust</code>编写</p></li><li><p><a href="https://www.gitbook.com/">gitBook</a><br><code>GitBook</code> 是一个基于 Node.js 的命令行工具，可使用 Github/Git 和 Markdown 来制作精美的电子书，支持输出多种格式文档：静态站点、PDF、eBook、单HTML网页、JSON</p></li></ol><h3 id="使用docsify搭建站点"><a href="#使用docsify搭建站点" class="headerlink" title="使用docsify搭建站点"></a>使用docsify搭建站点</h3><blockquote><p><a href="http://leetcode.tianwj.com/">leetcode.tianwj.com</a><br>把之前刷的leetcode记录生成了一个站点，并且绑定二级域名</p></blockquote><p><a href="https://docsify.js.org/#/zh-cn/">docsify</a> 官方文档写的非常详细，并且还支持中文，官方文档就是使用 <code>docsify</code> 生成的，具体可以查看官方文档</p><p>设置<code>GitHub Pages</code>:<br><img src="/images/gitHub-pages.png"></p><p>最终成品:<br><img src="/images/leetcode1.png"><br><img src="/images/leetcode2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;经常看到一些文档的网站很简洁，于是便调研了一下，自己动手基于&lt;code&gt;GitHub Pages&lt;/code&gt;搭建了一个文档站点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;文档站点生成器&quot;&gt;&lt;a href=&quot;#文档站点生成器&quot; class</summary>
      
    
    
    
    <category term="其他" scheme="http://yoursite.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux expect</title>
    <link href="http://yoursite.com/2020/09/13/Linux-expect/"/>
    <id>http://yoursite.com/2020/09/13/Linux-expect/</id>
    <published>2020-09-13T07:54:52.000Z</published>
    <updated>2020-09-13T09:08:43.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><code>expect</code> 是基于<a href="http://tcl.tk/man/tcl8.5/TclCmd/contents.htm">Tcl</a>实现的一个脚本语言，用来实现自动和程序交互式通信。类似自动远程登录命令，模拟人手工交互输入密码的过程，从而实现自动远程登录<br><code>expect</code> 的工作流程为:<code>spawn</code>(启动指定进程)—&gt;<code>expect</code>(获取指定关键字)—&gt;<code>send</code>(向指定程序发送指定字符)—&gt;<code>interact</code>(允许用户交互)–&gt;退出结束</p></blockquote><h3 id="安装expect"><a href="#安装expect" class="headerlink" title="安装expect"></a>安装expect</h3><p>使用<code>expect</code>的前提需要安装，这里以<code>yum</code>安装为例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y expect</span><br></pre></td></tr></table></figure><h3 id="expect常用命令"><a href="#expect常用命令" class="headerlink" title="expect常用命令"></a>expect常用命令</h3><h4 id="spawn"><a href="#spawn" class="headerlink" title="spawn"></a>spawn</h4><p>启动一个进程，然后所有的<code>expect</code>都在这个进程中进行</p><h4 id="expect"><a href="#expect" class="headerlink" title="expect"></a>expect</h4><p>获取匹配信息匹配成功则执行<code>expect</code>后面的程序动作</p><blockquote><p>example:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">expect &#123;</span><br><span class="line">    “yes&#x2F;no”</span><br><span class="line">    &#123;send “yes\n”;exp_continue&#125;</span><br><span class="line">    “*password:”</span><br><span class="line">    &#123;send “123456\n”&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="exp-continue"><a href="#exp-continue" class="headerlink" title="exp_continue"></a>exp_continue</h4><p>在<code>expect</code>中多次匹配用到，使后面的匹配仍然从第一个关键字开始，否则第一次匹配从第一个关键字开始，但是后面第二次匹配则从第二个关键字开始</p><h4 id="send-exp-send"><a href="#send-exp-send" class="headerlink" title="send exp_send"></a>send exp_send</h4><p>用于发送指定的字符串信息</p><h4 id="send-user"><a href="#send-user" class="headerlink" title="send_user"></a>send_user</h4><p>把参数输出到标准输出中去，默认的<code>send</code>,<code>exp_send</code>命令都是将参数输出到程序中的，相当于<code>shell</code>中的<code>echo</code></p><h4 id="interact"><a href="#interact" class="headerlink" title="interact"></a>interact</h4><p>停留在当前进程，退出<code>expect</code>，交给用户操作</p><h4 id="exit"><a href="#exit" class="headerlink" title="exit"></a>exit</h4><p>退出<code>expect</code>脚本，还可以使用该命令指定退出前的一些命令</p><blockquote><p>example:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">exit -onexit &#123;</span><br><span class="line">    exec rm $tmpfile(删除临时文件)</span><br><span class="line">    send_user “Good bye\n”</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><blockquote><p><code>expect</code>变量使用方法和<code>Tcl</code>一致</p></blockquote><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p>定义变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set host localhost</span><br><span class="line">set passwrod 123456</span><br></pre></td></tr></table></figure><blockquote><p>example:接收命令行参数为变量</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set host [lindex $argv 0]</span><br><span class="line">set passwrod [lindex $argv 1]</span><br></pre></td></tr></table></figure><h4 id="puts"><a href="#puts" class="headerlink" title="puts"></a>puts</h4><p>输出变量</p><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><h4 id="eof"><a href="#eof" class="headerlink" title="eof"></a>eof</h4><p><code>expect</code>执行结束 退出</p><h4 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a>timeout</h4><p>设置全局性的超时时间，默认是10s</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set timeout 60</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;expect&lt;/code&gt; 是基于&lt;a href=&quot;http://tcl.tk/man/tcl8.5/TclCmd/contents.htm&quot;&gt;Tcl&lt;/a&gt;实现的一个脚本语言，用来实现自动和程序交互式通信。类似自动远程登录命令，模拟人</summary>
      
    
    
    
    <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>线程安全与锁优化</title>
    <link href="http://yoursite.com/2020/04/06/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2020/04/06/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/</id>
    <published>2020-04-06T09:48:29.000Z</published>
    <updated>2020-04-06T09:58:36.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><h4 id="Java中的线程安全"><a href="#Java中的线程安全" class="headerlink" title="Java中的线程安全"></a>Java中的线程安全</h4><p>按照线程安全的“安全程度”分为五大类：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立</p><ol><li><strong>不可变</strong><br>在Java中不可变(Immutable)对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要再进行任何线程安全保护措施。如<code>final</code>关键字</li><li><strong>绝对线程安全</strong><br>绝对的线程安全是指“不管运行时环境如何，调用者都不需要任何额外的同步策略”，绝对的线程安全是需要付出非常高的代价的，甚至是不切实际的代价。而在Java API中标注是线程安全的类，大多数都不是绝对的线程安全，都是相对的线程安全</li><li><strong>相对线程安全</strong><br>相对线程安全就是我们通常意义上所讲的线程安全。它需要保证<strong>对象单次的操作是安全的,</strong> 如<code>Vector</code>的<code>get()</code>方法，这个方法是同步的。但是对于一些特定顺序的连续调用，则需要调用端使用额外的同步手段来保证正确性，如使用<code>synchronized</code>关键字<br>在Java中，大部分声明线程安全的类都属于这种类型，如<code>Vector</code>、<code>HashTable</code>、<code>ConcurrentHashMap</code>和<code>Collections</code>的<code>synchronizedCollection()</code>方法包装的集合等</li><li><strong>线程兼容</strong><br>线程兼容是值对象本身并不是线程安全的，但是通过调用端正确的使用同步手段来保证对象在并发环境中可以安全的使用。平常我们说一个类不是线程安全的，指的就是这种情况。<br>Java类库中大部分类都是线程兼容的，如<code>ArrayList</code>和<code>HashMap</code>等</li><li><strong>线程对立</strong><br>线程独立是指不管调用端是否采取了同步措施，都无法在多线程环境中并发使用。<br>线程对立这种情况是很少出现的，而且通常都是有害的，应当避免<br>如<code>Thread</code>类的<code>suspend()</code>和<code>resume()</code>方法。</li></ol><h4 id="线程安全的实现方法"><a href="#线程安全的实现方法" class="headerlink" title="线程安全的实现方法"></a>线程安全的实现方法</h4><ol><li><p><strong>互斥同步</strong><br>互斥同步是最常见也是最主要的并发保障手段。同步是指共享数据在同一时刻只能背一个线程使用，而互斥是实现同步的一种手段，<code>临界区(Critical Section)</code>、<code>互斥量(Mutex)</code>和<code>信号量(Semaphore)</code>都是常见的互斥实现方式</p><ul><li>synchronized关键字:<br>在Java中，最基本的互斥同步手段就是<code>synchronized关键字</code>，这是一个块结构的语法。<code>synchronized</code>关键字经过javac编译后，会在同步块前后形成<code>monitorenter</code>和<code>monitorexit</code>两个字节码指令。<br>在执行<code>monitorenter</code>指令时，首先尝试去获取对象锁，如果对象没有被锁定或当前线程已经持有了该对象的锁，就把锁的计数器增加一，而在执行<code>monitorexit</code>指令时将会将锁计数器的值减一。当锁计数器的值为0时，锁则被释放了。如果获取对象锁失败则会一直阻塞等待，直到获取到锁  </li></ul></li></ol><p><strong><code>synchronized</code>对于一个线程来说是可重入的，同时<code>synchronized</code>中的锁是非公平的</strong></p><pre><code>- 重入锁(ReentrantLock):  </code></pre><p>重入锁(ReentrantLock)是Lock接口最常见的一种实现，与<code>synchronized</code>相似，但是比<code>synchronized</code>相比多了一些高级功能，主要是：等待可中断、可实现公平锁(默认也是非公平锁)、可以绑定多个条件</p><ol start="2"><li><p><strong>非阻塞同步</strong><br>互斥同步也被称为阻塞同步，是一种悲观悲观的并发策略，主要问题是进行线程阻塞和唤醒所带来的性能开销。与之对应的则是乐观的并发策略，最常用的是不断的重试，直接操作共享数据，当出现冲突时，不断的重试，直到没有冲突。<br>最常见的方法是CAS(Compare-and-Swap)，如juc包中的<code>Atomic</code>类则是通过自旋和CAS实现的，同时CAS可能会出现ABA问题，但是大部分情况下ABA问题不会影响程序并发的正确性</p></li><li><p><strong>无同步方案</strong><br>如果让一个方法不涉及多线程共享数据，自然也不需要去保证线程安全，因为他们天生就是线程安全的，如<code>ThreadLocal</code>这个类，每一个<code>Thread</code>对象都有一个<code>ThreadLocalMap</code>对象，用来存储当前线程的变量</p></li></ol><h3 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h3><blockquote><p>JDK 5升级到JDK 6后，进行了大量的锁优化</p></blockquote><h4 id="自旋锁和自适应自旋"><a href="#自旋锁和自适应自旋" class="headerlink" title="自旋锁和自适应自旋"></a>自旋锁和自适应自旋</h4><ul><li>自旋锁：当线程尝试获取锁时发现冲突，则让获取锁的线程等一会，但不放弃CPU的执行时间，而让线程等待则让线程执行一个循环(自旋)即可</li><li>自适应自旋：自旋所等待的时间必须有一定的限度，如果超过了限定的次数仍然没有获取到锁，则使用传统的方法挂起该线程，自旋次数默认是10次。而自适应自旋则是自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定</li></ul><h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><p>锁消除是虚拟机即时编译器在运行时，检测到数据不可能被其他线程访问，则会对锁进行消除。锁消除的主要判断依据来源于逃逸分析的数据支持，如果判断一段代码在堆上的所有数据都不会逃逸出去被其他线程访问到，则可以把他们当作栈上的数据对待，认为他们是线程私有的</p><h4 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h4><p>如果虚拟机探测到有一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展(粗化)到整个操作序列的外部。如果<code>StringBuffer.append()</code>方法，连续操作append方法，锁则会扩展到第一个append方法之前和最后一个append方法之后，只需加一次锁就可以</p><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><blockquote><p>轻量级锁是通过CAS来实现的</p></blockquote><p>HotSpot虚拟机的对象头中有一部分用来存储对象自身的运行时数据，如哈希码，GC分代年龄、存储标识位、偏向模式等，官方称它为“Mark Word”。</p><p>在代码即将进入同步块之前，如果同步对象没有被锁定，则在当前线程的栈帧中建立一个锁记录(Lock Record)的空间，用来存储锁对象Mark Word的拷贝。<br>然后虚拟机使用CAS操作尝试把对象的Mark Word更新为Lock Record的指针，如果更新成功，则代表该线程拥有了这个对象的所，如果更新失败了，首先检查是否是当前线程拥有了这个对象的锁，如果是的话直接执行即可，如果不是则说明锁被其他线程抢占了。解锁反之。</p><p>如果出现两个线程争用一个锁的情况，那轻量级锁则不再有效，必须膨胀为重量级锁</p><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>轻量级锁是在无竞争的情况下使用CAS来消除同步的互斥量，而偏向锁是在无竞争的情况下把整个同步都消除掉，连CAS都不再操作</p><p>具体是这样的，当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设置为“01”、把偏向模式设置为“1”，标识进入偏向模式。同时使用CAS操作把获取这个锁的线程ID记录在了对象头的Mark Word中，如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁都不需要有任何同步操作。但是如果另外的线程去尝试获取这个锁，偏向模式则马上宣告结束</p><p>偏向锁是一种权衡的优化，如果程序中的大多数锁都总是被多个不同的线程访问，那偏向模式反而是多余的。具体情况具体分析，可以使用参数<code>-CC:-UseBiasedLocking</code>来禁止偏向锁优化</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;线程安全&quot;&gt;&lt;a href=&quot;#线程安全&quot; class=&quot;headerlink&quot; title=&quot;线程安全&quot;&gt;&lt;/a&gt;线程安全&lt;/h3&gt;&lt;h4 id=&quot;Java中的线程安全&quot;&gt;&lt;a href=&quot;#Java中的线程安全&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>ThreadPoolExecutor</title>
    <link href="http://yoursite.com/2020/04/02/ThreadPoolExecutor/"/>
    <id>http://yoursite.com/2020/04/02/ThreadPoolExecutor/</id>
    <published>2020-04-02T14:51:58.000Z</published>
    <updated>2020-04-02T15:57:14.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>ThreadPoolExecutor是Java中线程池的核心实现类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">classDiagram</span><br><span class="line">Executor &lt;|-- ExecutorService : 继承</span><br><span class="line">ExecutorService &lt;|-- AbstractExecutorService : 实现</span><br><span class="line">AbstractExecutorService &lt;|-- ThreadPoolExecutor : 继承</span><br></pre></td></tr></table></figure><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new &#123;<span class="doctag">@code</span> ThreadPoolExecutor&#125; with the given initial</span></span><br><span class="line"><span class="comment"> * parameters and default thread factory.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> corePoolSize      核心线程池大小</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> maximumPoolSize   最大线程池大小</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> keepAliveTime     线程池中超过corePoolSize数目的空闲线程最大存活时间；可以allowCoreThreadTimeOut(true)成为核心线程的有效时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unit              keepAliveTime的时间单位</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> workQueue         阻塞任务队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> threadFactory     线程工厂，对线程命名 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> handler           拒绝策略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure><h3 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h3><p>所有任务的调度都是由execute方法完成的，这部分完成的工作是：检查现在线程池的运行状态、运行线程数、运行策略，决定接下来执行的流程，是直接申请线程执行，或是缓冲到队列中执行，亦或是直接拒绝该任务。其执行过程如下：</p><ol><li>首先检测线程池运行状态，如果不是RUNNING，则直接拒绝，线程池要保证在RUNNING的状态下执行任务。</li><li>如果workerCount &lt; corePoolSize，则创建并启动一个线程来执行新提交的任务。</li><li>如果workerCount &gt;= corePoolSize，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中。</li><li>如果workerCount &gt;= corePoolSize &amp;&amp; workerCount &lt; maximumPoolSize，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务。</li><li>如果workerCount &gt;= maximumPoolSize，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。</li></ol><h3 id="任务存储策略"><a href="#任务存储策略" class="headerlink" title="任务存储策略"></a>任务存储策略</h3><p>使用不同的队列可以实现不一样的任务存取策略</p><ul><li><strong>ArrayBlockingQueue:</strong> 一个用数组实现的有界阻塞队列，此队列按照先进先出(FIFO)的原则对元素进行排序。支持公平锁和非公平锁</li><li><strong>LinkedBlockingQueue:</strong> 一个由链表结构组成的有界队列，此队列按照先进先出(FIFO)的原则对元素进行排序。此队列的默认长度是Integer.MAX_VALUE，所以默认创建的队列有容量危险</li><li><strong>PriorityBlockingQueue:</strong> 一个支持线程优先级排序的无界队列，默认自然序进行排序，也可以自定义实现compareTo()方法来指定元素排序规则，不能保证同优先级元素的排序</li><li><strong>DelayQueue:</strong> 一个实现<code>PriorityBlockingQueue</code>实现延迟获取的无界队列，在创建元素时，可以指定多久才能从队列中获取当前元素。只有延时期满后才能从队列中获取元素</li><li><strong>SynchronousQueue:</strong> 一个不存储元素的阻塞队列，每一个put操作必须等待take操作，否则不能添加元素。支持公平锁和非公平锁。<code>SynchronousQueue</code>的一个使用场景是在线程里。<code>Executors.newCachedThreadPool()</code>就使用了<code>SynchronousQueue</code>，这个线程池根据需要(新任务到来时)创建新的线程，如果有空闲线程则会重复使用，线程空闲60秒后会被回收</li><li><strong>LinkedTransferQueue:</strong> 一个由链表结构组成的无界阻塞队列，相当于其他队列，<code>LinkedTransferQueue</code>队列多了<code>transfer</code>和<code>tryTransfer</code>方法</li><li><strong>LinkedBlockingDeque:</strong> 一个由链表结构组成的双向阻塞队列，队列的头和尾部都可以添加和移除元素，多线程并发时，可以将锁的竞争最多降低一半</li></ul><h3 id="RejectedExecutionHandler拒绝策略"><a href="#RejectedExecutionHandler拒绝策略" class="headerlink" title="RejectedExecutionHandler拒绝策略"></a>RejectedExecutionHandler拒绝策略</h3><ul><li><p><strong>AbortPolicy:</strong> 默认策略，直接抛出异常阻止系统正常运行</p></li><li><p><strong>CallerRunsPolicy:</strong> “调用者运行”一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将任务回馈至发起方比如main线程</p></li><li><p><strong>DiscardOldestPolicy:</strong> 抛弃队列中等待最久的任务，然后把当前任务加入队列中尝试再次提交当前任务</p></li><li><p><strong>DiscardPolicy:</strong> 直接丢弃任务，不给予任何处理也不跑出异常，如果允许任务丢失，这是最好的一种方案</p></li></ul><h3 id="execute-和submit-区别"><a href="#execute-和submit-区别" class="headerlink" title="execute()和submit()区别"></a>execute()和submit()区别</h3><ol><li>接收的参数不一样</li><li>submit有返回值，而execute没有</li><li>submit方便Exception处理：可以通过捕获Future.get抛出的异常</li></ol><h3 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ThreadFactory factory &#x3D; new ThreadFactoryBuilder().setDaemon(true).setNameFormat(&quot;test-666-%d&quot;).build();</span><br><span class="line">ExecutorService threadPoolExecutor &#x3D; new ThreadPoolExecutor(5, 5, 0L, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(), factory);</span><br><span class="line">threadPoolExecutor.execute(()-&gt;&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br><span class="line">&lt;!--threadPoolExecutor.submit(()-&gt;&#123;--&gt;</span><br><span class="line">&lt;!--    ...--&gt;</span><br><span class="line">&lt;!--&#125;);--&gt;</span><br><span class="line">threadPoolExecutor.shutdown();</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;ThreadPoolExecutor是Java中线程池的核心实现类&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;</summary>
      
    
    
    
    <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>事物隔离级别</title>
    <link href="http://yoursite.com/2020/02/01/%E4%BA%8B%E7%89%A9%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    <id>http://yoursite.com/2020/02/01/%E4%BA%8B%E7%89%A9%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</id>
    <published>2020-02-01T05:25:55.000Z</published>
    <updated>2020-02-01T05:55:34.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="事物"><a href="#事物" class="headerlink" title="事物"></a>事物</h3><p>事务是由一组SQL语句组成的逻辑处理单元，是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。事务具有以下4个属性，通常简称为事务的ACID属性:</p><ul><li><p><strong>原子性(Atomicity):</strong> 事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。</p></li><li><p><strong>一致性(Consistent):</strong> 在事务开始和完成时，数据都必须保持一致状态。</p></li><li><p><strong>隔离性(Isolation):</strong> 并发访问数据库时，一个用户的事物不被其他事物所干扰，各并发事务之间数据库是独立的。</p></li><li><p><strong>持久性(Durable):</strong> 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</p></li></ul><h3 id="并发一致性问题"><a href="#并发一致性问题" class="headerlink" title="并发一致性问题"></a>并发一致性问题</h3><ul><li><p><strong>脏读(Dirty read):</strong> 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。<br>解决办法: 把数据库的事务隔离级别调整到<code>READ_COMMITTED</code></p></li><li><p><strong>更新丢失(Lost Update):</strong> 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 </p></li><li><p><strong>不可重复读(Unrepeatableread):</strong> 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。  </p></li></ul><p><strong>一个事务范围内两个相同的查询却返回了不同数据。</strong><br>解决办法: 把数据库的事务隔离级别调整到<code>REPEATABLE_READ</code></p><ul><li><p><strong>幻读(Phantom read):</strong> 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</p></li><li><p><strong>不可重复度和幻读区别:</strong><br>不可重复读的重点是修改，幻读的重点在于新增或者删除。</p></li></ul><h3 id="事物的隔离级别"><a href="#事物的隔离级别" class="headerlink" title="事物的隔离级别"></a>事物的隔离级别</h3><p>“脏读”、”不可重复读”和”幻读”，必须由事务隔离机制来解决。</p><h4 id="SQL-标准定义了四个隔离级别"><a href="#SQL-标准定义了四个隔离级别" class="headerlink" title="SQL 标准定义了四个隔离级别:"></a>SQL 标准定义了四个隔离级别:</h4><ul><li><p><strong>读未提交(Read Uncommitted):</strong><br>最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读</p></li><li><p><strong>读已提交(Read Committed):</strong><br>允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong><br>Oracle、SqlServer默认隔离级别都是<code>READ-COMMITTED</code></p></li><li><p><strong>可重复读(Repeatable Read):</strong><br>对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong><br>MYSQL默认隔离级别是<code>REPEATABLE-READ</code></p></li><li><p><strong>串行化(Serializable):</strong><br>最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong></p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><p>读未提交: 一个事务还没提交时，它做的变更就能被别的事务看到。</p></li><li><p>读已提交: 一个事务提交之后，它做的变更才会被其他事务看到。</p></li><li><p>可重复读 : 一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。</p></li><li><p>串行化: 顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</p></li></ul><p>四个级别逐渐增强，每个级别解决一个问题，事务级别越高，性能越差，大多数环境(<code>Read committed</code> 就可以了)</p><table><thead><tr><th>隔离级别</th><th>读数据一致性</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>读未提交</td><td>最低级别</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>读已提交</td><td>语句级</td><td>N</td><td>Y</td><td>Y</td></tr><tr><td>可重复读</td><td>事物级</td><td>N</td><td>N</td><td>Y</td></tr><tr><td>串行化</td><td>最高级别、事物级</td><td>N</td><td>N</td><td>N</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;事物&quot;&gt;&lt;a href=&quot;#事物&quot; class=&quot;headerlink&quot; title=&quot;事物&quot;&gt;&lt;/a&gt;事物&lt;/h3&gt;&lt;p&gt;事务是由一组SQL语句组成的逻辑处理单元，是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollbac</summary>
      
    
    
    
    <category term="DB" scheme="http://yoursite.com/categories/DB/"/>
    
    
    <category term="DB" scheme="http://yoursite.com/tags/DB/"/>
    
  </entry>
  
  <entry>
    <title>Spring中的FactoryBean</title>
    <link href="http://yoursite.com/2019/12/27/Spring%E4%B8%AD%E7%9A%84FactoryBean/"/>
    <id>http://yoursite.com/2019/12/27/Spring%E4%B8%AD%E7%9A%84FactoryBean/</id>
    <published>2019-12-27T11:22:04.000Z</published>
    <updated>2019-12-27T11:25:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>Spring 中有两种类型的Bean，一种是普通Bean，另一种是工厂Bean 即 FactoryBean。<br>FactoryBean跟普通Bean不同，其返回的对象不是指定类的一个实例，而是该<code>FactoryBean</code>的<code>getObject</code>方法所返回的对象</p><h3 id="FactoryBean接口定义"><a href="#FactoryBean接口定义" class="headerlink" title="FactoryBean接口定义"></a>FactoryBean接口定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.beans.factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FactoryBean</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//返回的对象实例</span></span><br><span class="line">    <span class="function">T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Bean的类型</span></span><br><span class="line">    Class&lt;?&gt; getObjectType();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//true是单例，false是非单例  在Spring5.0中此方法利用了JDK1.8的新特性变成了default方法，返回true</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>FactoryBean 通常是用来创建比较复杂的bean，一般的bean 直接用xml配置即可，但如果一个bean的创建过程中涉及到很多其他的bean 和复杂的逻辑，用xml配置比较困难，这时可以考虑用FactoryBean。</p><blockquote><p>当使用ApplicationContext的getBean()方法获取FactoryBean实例本身而不是它所产生的bean，则要使用&amp;符号+id。比如，现有FactoryBean，它有id，在容器上调用getBean(“myBean”)将返回FactoryBean所产生的bean，调用getBean(“&amp;myBean”)将返回FactoryBean它本身的实例。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Spring 中有两种类型的Bean，一种是普通Bean，另一种是工厂Bean 即 FactoryBean。&lt;br&gt;FactoryBean跟普通Bean不同，其返回的对象不是指定类的一个实例，而是该&lt;code&gt;FactoryBean&lt;/code&gt;的&lt;code&gt;getObje</summary>
      
    
    
    
    <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
    <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Java代理模式</title>
    <link href="http://yoursite.com/2019/12/24/Java%E7%9A%84%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/12/24/Java%E7%9A%84%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</id>
    <published>2019-12-24T12:03:53.000Z</published>
    <updated>2019-12-24T12:41:13.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><blockquote><p>在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。</p></blockquote><blockquote><p>在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。</p></blockquote><blockquote><p>java中的代理分为：静态代理、动态代理。动态代理又分为jdk代理和Cglib代理。</p></blockquote><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>静态代理在使用时，需要定义接口或者父类，被代理的对象和代理对象需要一起实现同一个接口或者继承同一个父类。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h4><ul><li><p>抽象接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>委托类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserImpl</span> <span class="keyword">implements</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;name is &quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>代理类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserProxy</span> <span class="keyword">implements</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserProxy</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.user = user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        String result = user.getName(name); </span><br><span class="line">        System.out.println(result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Demo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        UserProxy userProxy = <span class="keyword">new</span> UserProxy(<span class="keyword">new</span> UserImpl());</span><br><span class="line">        userProxy.getName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h4><blockquote><p>代理类不仅是一个隔离客户端和委托类的中介，还可以通过代理类在不修改原有代码的前提下增加一些新功能，是开闭原则(Open for Extension, Closed for Modification)最典型的实践。</p><p>代理类可以为委托类预处理消息、过滤消息、把消息转发给委托类以及事后处理消息等。代理类与委托类之间通常会存在关联关系，一个代理类的对象与一个委托类的对象关联，代理类对象本身并不真正实现服务，而是通过调用委托类的对象的相关方法来提供特定的服务。</p></blockquote></li><li><p>优点:可以做到在不修改目标对象的功能前提下,对目标功能扩展；</p></li><li><p>缺点:因为代理对象需要与目标对象实现一样的接口，所以会有很多代理类，同时，一旦接口增加方法，目标对象与代理对象都要维护。</p></li></ul><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>静态代理的缺点怎么改进呢？让代理类动态的生成是不就可以了呢，也就是<code>动态代理</code></p><p><code>动态代理</code>两种最常见的方式：</p><ol><li>通过实现接口的方式 -&gt; JDK动态代理</li><li>通过继承类的方式 -&gt; CGLIB动态代理</li></ol><h4 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h4><p><strong>JDK动态代理又称接口代理</strong>，基于Java反射机制实现，必须要实现了接口的业务类才能用这种办法生成代理对象。</p><p>JDK动态代理主要涉及两个类：<code>java.lang.reflect.Proxy</code> 和 <code>java.lang.reflect.InvocationHandler</code></p><p>InvocationHandler 和 Proxy 的主要方法介绍:</p><ul><li><p><code>java.lang.reflect.InvocationHandler</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义了代理对象调用方法时希望执行的动作，用于集中处理在动态代理类对象上的方法调用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> proxy     被代理的对象 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> method    要调用的方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args      方法调用时所需要参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br></pre></td></tr></table></figure></li><li><p><code>java.lang.reflect.Proxy</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造实现指定接口的代理类的一个新实例，所有方法会调用给定处理器对象的 invoke 方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> loader        指定当前目标对象使用类加载器，获取加载器的方法是固定的</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> interfaces    目标对象实现的接口的类型，使用泛型方式确认类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> h             InvocationHandler接口的子类的实例  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          InvocationHandler h)</span></span></span><br></pre></td></tr></table></figure><p>  <strong>推荐使用Guava中的 <code>com.google.common.reflect.Reflection</code>的<code>newProxy</code>方法，更加方便</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造实现指定接口的代理类的一个新实例，所有方法会调用给定处理器对象的 invoke 方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> interfaceType</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">newProxy</span><span class="params">(Class&lt;T&gt; interfaceType, InvocationHandler handler)</span></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 返回指定接口的代理类</span></span></span><br><span class="line"><span class="function"><span class="comment"> *</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @param loader        目标对象的类加载</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @param interfaces    目标对象实现的接口类型</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; <span class="title">getProxyClass</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                         Class&lt;?&gt;... interfaces)</span></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 获取指定代理对象所关联的调用处理器</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InvocationHandler <span class="title">getInvocationHandler</span><span class="params">(Object proxy)</span></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 判断cl是否为一个代理类</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isProxyClass</span><span class="params">(Class&lt;?&gt; cl)</span></span></span><br></pre></td></tr></table></figure></li></ul><h5 id="示例-1"><a href="#示例-1" class="headerlink" title="示例:"></a>示例:</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    User user = (User) Proxy.newProxyInstance(User.class.getClassLoader(), <span class="comment">// 传入ClassLoader</span></span><br><span class="line">                                              User.class.getInterfaces(), <span class="comment">// 传入要实现的接口</span></span><br><span class="line">                                              (object, method, para) -&gt; &#123;</span><br><span class="line">                                                System.out.println(method);</span><br><span class="line">                                                <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;getName&quot;</span>)) &#123;</span><br><span class="line">                                                  System.out.println(<span class="string">&quot;name is &quot;</span> + args[<span class="number">0</span>]);</span><br><span class="line">                                                &#125;</span><br><span class="line">                                                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                                              &#125;); <span class="comment">// 传入处理调用方法的InvocationHandler</span></span><br><span class="line"></span><br><span class="line">    user.getName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>在运行期动态创建一个interface实例的步骤如下：</p><ol><li>定义一个InvocationHandler实例，它负责实现接口的方法调用；</li><li>通过Proxy.newProxyInstance()创建interface实例，它需要3个参数：<ol><li>使用的ClassLoader，通常就是接口类的ClassLoader；</li><li>需要实现的接口数组，至少需要传入一个接口进去；</li><li>用来处理接口方法调用的InvocationHandler实例。</li></ol></li><li>将返回的Object强制转型为接口。</li></ol><h4 id="Cglib动态代理"><a href="#Cglib动态代理" class="headerlink" title="Cglib动态代理"></a>Cglib动态代理</h4><p><strong>Cglib动态代理又称子类代理</strong>，基于ASM机制实现，通过生成业务类的子类作为代理类。</p><h5 id="Cglib子类实现代理的方法"><a href="#Cglib子类实现代理的方法" class="headerlink" title="Cglib子类实现代理的方法:"></a>Cglib子类实现代理的方法:</h5><ol><li>需要引入cglib和asm的jar包文件，Spring的核心包里面已经包含了此包；</li><li>引入jar包后，就可以在内存中动态构建子类；</li><li><strong>代理的类不能为final，否则报错；</strong></li><li><strong>目标对象的方法如果为final/static，那么就不会被拦截，即不会执行目标对象额外的方法。</strong></li></ol><h5 id="示例-2"><a href="#示例-2" class="headerlink" title="示例:"></a>示例:</h5><ul><li><p>被代理类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserImpl</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;name is &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现MethodInterceptor接口生成方法拦截器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserMethodInterceptor</span>  <span class="keyword">implements</span> <span class="title">MethodInterceptor</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> object 表示要进行增强的对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 表示拦截的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> objects 数组表示参数列表，基本数据类型需要传入其包装类型，如int--&gt;Integer、long-Long、double--&gt;Double</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodProxy 表示对方法的代理，invokeSuper方法表示对被代理对象方法的调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Before: &quot;</span>  + method.getName());</span><br><span class="line">        <span class="comment">// 注意这里是调用 invokeSuper 而不是 invoke，否则死循环，methodProxy.invokesuper执行的是原始类的方法，method.invoke执行的是子类的方法</span></span><br><span class="line">        Object object = methodProxy.invokeSuper(o, objects);</span><br><span class="line">        System.out.println(<span class="string">&quot;After: &quot;</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Demo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">//继承被代理类</span></span><br><span class="line">        enhancer.setSuperclass(UserImpl.class);</span><br><span class="line">        <span class="comment">//设置回调</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> UserMethodInterceptor());</span><br><span class="line">        <span class="comment">//设置代理类对象</span></span><br><span class="line">        UserImpl user = (UserImpl) enhancer.create();</span><br><span class="line">        <span class="comment">//在调用代理类中方法时会被我们实现的方法拦截器进行拦截</span></span><br><span class="line">        user.getName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="在Spring的AOP编程中"><a href="#在Spring的AOP编程中" class="headerlink" title="在Spring的AOP编程中:"></a>在Spring的AOP编程中:</h4><ul><li>如果加入容器的目标对象有实现接口，用JDK代理</li><li>如果目标对象没有实现接口，用Cglib代理</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;代理模式&quot;&gt;&lt;a href=&quot;#代理模式&quot; class=&quot;headerlink&quot; title=&quot;代理模式&quot;&gt;&lt;/a&gt;代理模式&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型</summary>
      
    
    
    
    <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
    <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Bean Copy</title>
    <link href="http://yoursite.com/2019/09/25/Bean-Copy/"/>
    <id>http://yoursite.com/2019/09/25/Bean-Copy/</id>
    <published>2019-09-25T08:50:48.000Z</published>
    <updated>2019-09-25T10:23:07.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在日常开发中，经常会遇到需要Bean copy的情况，有好多copy的方法</p></blockquote><h2 id="克隆的分类"><a href="#克隆的分类" class="headerlink" title="克隆的分类"></a>克隆的分类</h2><ul><li>浅克隆（shallow clone），浅克隆是指拷贝对象时仅仅copy对象本身和对象中的基本变量，而不拷贝对象包含的引用指向的对象。</li><li>深克隆（deep clone），不仅copy对象本身，而且copy对象包含的引用指向的所有对象。</li></ul><h2 id="克隆方法"><a href="#克隆方法" class="headerlink" title="克隆方法"></a>克隆方法</h2><h3 id="传统的setter方法"><a href="#传统的setter方法" class="headerlink" title="传统的setter方法"></a>传统的setter方法</h3><p>手工来setter对象的每个属性，这种方法性能非常高，但是写法不优雅、繁琐</p><h3 id="Object-clone"><a href="#Object-clone" class="headerlink" title="Object.clone()"></a>Object.clone()</h3><ul><li><p>实现<code>java.lang.Cloneable</code>接口<br>Cloneable是标记型的接口，它们内部都没有方法和属性，实现 Cloneable来表示该对象能被克隆，能使用Object.clone()方法。如果没有实现 Cloneable的类对象调用clone()就会抛出CloneNotSupportedException。</p></li><li><p>重写（Override）Object的<code>clone()</code>方法，并声明为<code>public</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">        String name;</span><br><span class="line">        <span class="keyword">int</span> age;</span><br><span class="line">        </span><br><span class="line">        Student(String name,<span class="keyword">int</span> age) &#123;</span><br><span class="line">            <span class="keyword">this</span>.name=name;</span><br><span class="line">            <span class="keyword">this</span>.age=age;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这只是浅克隆，如果需要深克隆的话则重写（Override）Object类的clone()方法，并且在方法内部调用持有对象的clone方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">        String name;    </span><br><span class="line">        Info info;    </span><br><span class="line"></span><br><span class="line">        Student(String name,Info info) &#123;    </span><br><span class="line">            <span class="keyword">this</span>.name=name;    </span><br><span class="line">            <span class="keyword">this</span>.info=info;    </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">            Student student = (Student) <span class="keyword">super</span>.clone();</span><br><span class="line">            student.info = (Info) student.info.clone();</span><br><span class="line">            <span class="keyword">return</span> student;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以调用<code>Object.clone()</code>方法或调用<code>org.apache.commons.lang3.ObjectUtils</code>的clone()方法来克隆对象了</p></li></ul><h3 id="序列化来实现深克隆"><a href="#序列化来实现深克隆" class="headerlink" title="序列化来实现深克隆"></a>序列化来实现深克隆</h3><p>自定义类需要实现<code>Serializable</code>接口，然后把对象（实际上只是对象的一个拷贝）写到一个流里，再从流里读出来，便可以重建对象</p><h3 id="使用第三方工具"><a href="#使用第三方工具" class="headerlink" title="使用第三方工具"></a>使用第三方工具</h3><p>常见的第三方工具大概有这几种:</p><blockquote><p>Apache 的 BeanUtils<br>Apache 的 PropertyUtils<br>Spring 的 BeanUtils<br>Cglib 的 BeanCopier</p></blockquote><h4 id="Apache-的-BeanUtils-和-PropertyUtils"><a href="#Apache-的-BeanUtils-和-PropertyUtils" class="headerlink" title="Apache 的 BeanUtils 和 PropertyUtils:"></a>Apache 的 BeanUtils 和 PropertyUtils:</h4><p>Apache的BeanUtils和PropertyUtils<strong>性能非常差</strong>，一般都不使用。<br>这个俩个类都是浅克隆，Apache还提供了 <code>SerializationUtils.clone(T)</code>，T对象需要实现<code>Serializable</code>接口，他属于深克隆。</p><h4 id="Spring-的-BeanUtils"><a href="#Spring-的-BeanUtils" class="headerlink" title="Spring 的 BeanUtils"></a>Spring 的 BeanUtils</h4><p>Spring的BeanUtils的<code>BeanUtils.copyProperties()</code>方法相比Apache来说性能要好很多。<br>并且相比Cglib 的 BeanCopier来说，它是静态方法，直接使用即可，非常方便。而BeanCopier不是静态方法，使用前需要使用<code>BeanCopier.create()</code>来初始化。</p><h4 id="Cglib-的-BeanCopier"><a href="#Cglib-的-BeanCopier" class="headerlink" title="Cglib 的 BeanCopier"></a>Cglib 的 BeanCopier</h4><p>Cglib 的 BeanCopier相比来说性能是最高的，但是使用前需要通过<code>BeanCopier.create()</code>来初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BeanCopier beanCopier = BeanCopier.create(srcClass, dstClass, <span class="keyword">false</span>);</span><br><span class="line">beanCopier.copy(srcObject, dstObject, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>其实BeanCopier主要花费的时间是调用create()方法，真正执行copy Bean花费的时间较少，所以我们可以进行优化，不是每次执行创建新BeanCopier，将BeanCopier.create()创建的BeanCopier进行缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@UtilityClass</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanCopierUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, BeanCopier&gt; cache = Maps.newConcurrentMap();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &lt;S, D&gt; <span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">(S srcObject, D dstObject)</span> </span>&#123;</span><br><span class="line">    BeanCopier beanCopier = getBeanCopier(srcObject.getClass(), dstObject.getClass());</span><br><span class="line">    beanCopier.copy(srcObject, dstObject, <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> BeanCopier <span class="title">getBeanCopier</span><span class="params">(Class&lt;?&gt; srcClass, Class&lt;?&gt; dstClass)</span> </span>&#123;</span><br><span class="line">    String key = Joiner.on(<span class="string">&#x27;\u0003&#x27;</span>).join(srcClass.getName(), dstClass.getName());</span><br><span class="line">    <span class="keyword">return</span> cache.computeIfAbsent(key, k -&gt; BeanCopier.create(srcClass, dstClass, <span class="keyword">false</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加入缓存后和手工set的性能接近</p><hr><blockquote><p>建议不要使用Apache的工具，如果是偶尔使用为了方便可以使用Spring的BeanUtils，如果是频繁使用时还是推荐使用Cglib 的 BeanCopier</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;在日常开发中，经常会遇到需要Bean copy的情况，有好多copy的方法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;克隆的分类&quot;&gt;&lt;a href=&quot;#克隆的分类&quot; class=&quot;headerlink&quot; title=&quot;克隆的分类&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>死锁DeadLock</title>
    <link href="http://yoursite.com/2019/09/18/MySQL-DeadLock/"/>
    <id>http://yoursite.com/2019/09/18/MySQL-DeadLock/</id>
    <published>2019-09-18T11:24:51.000Z</published>
    <updated>2019-09-25T07:52:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="死锁问题"><a href="#死锁问题" class="headerlink" title="死锁问题"></a>死锁问题</h2><blockquote><p>Deadlock found when trying to get lock; try restarting transaction</p></blockquote><p>发现在批量update时偶尔报Deadlock found when trying to get lock; try restarting transaction错误</p><h3 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h3><p>根本原因是两个事物同时批量操作时，有操作相同的记录，但是两个事物操作相同记录的顺序不一样，导致两个两个事物都获取不到锁，互锁了<br><img src="/images/deadlock.jpg" alt="deadlock"></p><p>正如阿里Java开发手册中说的一样:</p><blockquote><p>【强制】对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造 成死锁。<br>说明:线程一需要对表 A、B、C 依次全部加锁后才可以进行更新操作，那么线程二的加锁顺序 也必须是 A、B、C，否则可能出现死锁。</p></blockquote><hr><h3 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h3><ul><li>减小事务</li><li>给字段排序，按照排序后顺序执行，让死锁变为锁等待。</li></ul><hr><h4 id="减小事物"><a href="#减小事物" class="headerlink" title="减小事物:"></a>减小事物:</h4><p>减小在一个事物中的语句和执行时间，这样只是减小发生deadlock的概率，推荐给字段排序来解决。</p><h4 id="给字段排序"><a href="#给字段排序" class="headerlink" title="给字段排序:"></a>给字段排序:</h4><p>看到网上有这样解决的：<br>Change</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> onlineusers <span class="keyword">WHERE</span> datetime <span class="operator">&lt;=</span> now() <span class="operator">-</span> <span class="type">INTERVAL</span> <span class="number">900</span> <span class="keyword">SECOND</span></span><br></pre></td></tr></table></figure><p>TO</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> onlineusers <span class="keyword">WHERE</span> id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> onlineusers</span><br><span class="line">    <span class="keyword">WHERE</span> datetime <span class="operator">&lt;=</span> now() <span class="operator">-</span> <span class="type">INTERVAL</span> <span class="number">900</span> <span class="keyword">SECOND</span> <span class="keyword">order</span> <span class="keyword">by</span> id) u;</span><br></pre></td></tr></table></figure><p><strong>需要注意这样写可能会非常慢，因为IN中的子查询可能会不走索引，全表扫描，如果表中的数据很多，那这样就会产生很大的问题</strong></p><ul><li><p>可以修改为join：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE tableName <span class="keyword">AS</span> table1 <span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> tableName <span class="keyword">WHERE</span> <span class="keyword">AND</span> id <span class="keyword">IN</span> (<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>) <span class="keyword">ORDER</span> <span class="keyword">BY</span> id) <span class="keyword">AS</span> table2 <span class="keyword">ON</span> table1.id<span class="operator">=</span>table2.id <span class="keyword">SET</span> column1<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure></li><li><p>或者可以修改为:</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE tableNmae <span class="keyword">SET</span> column1<span class="operator">=</span><span class="number">1</span> <span class="keyword">WHERE</span> <span class="keyword">AND</span> id <span class="keyword">IN</span> (<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>)  <span class="keyword">ORDER</span> <span class="keyword">BY</span> id;</span><br></pre></td></tr></table></figure><p>  MySQL支持这种语法</p></li><li><p>或者可以在程序中把需要排序的字段排好序，然后再去执行SQL</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;死锁问题&quot;&gt;&lt;a href=&quot;#死锁问题&quot; class=&quot;headerlink&quot; title=&quot;死锁问题&quot;&gt;&lt;/a&gt;死锁问题&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Deadlock found when trying to get lock; try resta</summary>
      
    
    
    
    <category term="DB" scheme="http://yoursite.com/categories/DB/"/>
    
    
    <category term="DB" scheme="http://yoursite.com/tags/DB/"/>
    
    <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>设计模式——工厂模式</title>
    <link href="http://yoursite.com/2018/07/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/07/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</id>
    <published>2018-07-25T08:55:48.000Z</published>
    <updated>2019-12-24T12:35:49.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h3><p>工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<br>在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</p><h3 id="工厂模式分类："><a href="#工厂模式分类：" class="headerlink" title="工厂模式分类："></a>工厂模式分类：</h3><ol><li>简单工厂（Simple Factory）模式，又称静态工厂方法模式（Static Factory Method Pattern）</li><li>工厂方法（Factory Method）模式，又称多态性工厂（Polymorphic Factory）模式</li><li>抽象工厂（Abstract Factory）模式，又称工具箱（Kit 或Toolkit）模式</li></ol><hr><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式:"></a>简单工厂模式:</h3><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><ul><li>工厂类负责创建的对象比较少：由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂</li><li>客户端只知道传入工厂类的参数，对于如何创建对象不关心：客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数。</li></ul><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>假设一家工厂，生产电视，汽车等等，我们先为所有产品定义一个共同的产品接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后工厂的产品实现这个接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tv</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Tv</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;product Tv&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;product Car&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建工厂</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Product <span class="title">produce</span><span class="params">(String productName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (productName) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;tv&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Tv();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;car&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Car();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的实现有个问题，如果我们新增产品类的话，需要不断的在工厂类中新增case，这样需要修改的地方比较多，所以利用反射来优化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductFactory2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Product <span class="title">produce</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Product product = (Product) Class.forName(className).newInstance();</span><br><span class="line">            <span class="keyword">return</span> product;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;介绍：&quot;&gt;&lt;a href=&quot;#介绍：&quot; class=&quot;headerlink&quot; title=&quot;介绍：&quot;&gt;&lt;/a&gt;介绍：&lt;/h3&gt;&lt;p&gt;工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对</summary>
      
    
    
    
    <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
    <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Linux 下各文件夹的结构说明及用途介绍</title>
    <link href="http://yoursite.com/2018/03/02/Linux-%E4%B8%8B%E5%90%84%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E7%BB%93%E6%9E%84%E8%AF%B4%E6%98%8E%E5%8F%8A%E7%94%A8%E9%80%94%E4%BB%8B%E7%BB%8D/"/>
    <id>http://yoursite.com/2018/03/02/Linux-%E4%B8%8B%E5%90%84%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E7%BB%93%E6%9E%84%E8%AF%B4%E6%98%8E%E5%8F%8A%E7%94%A8%E9%80%94%E4%BB%8B%E7%BB%8D/</id>
    <published>2018-03-02T02:09:17.000Z</published>
    <updated>2020-09-13T09:10:35.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>==<strong>原文链接：<a href="http://www.cnblogs.com/xningge/p/8331631.html">http://www.cnblogs.com/xningge/p/8331631.html</a></strong>==  </p></blockquote><h3 id="linux下各文件夹的结构说明及用途介绍："><a href="#linux下各文件夹的结构说明及用途介绍：" class="headerlink" title="linux下各文件夹的结构说明及用途介绍："></a>linux下各文件夹的结构说明及用途介绍：</h3><p>/bin：二进制可执行命令。<br>/dev：设备特殊文件。<br>/etc：系统管理和配置文件。<br>/etc/rc.d：启动的配 置文件和脚本。<br>/home：用户主目录的基点，比如用户user的主目录就是/home/user，可以用~user表示。<br>/lib：标准程序设计库，又 叫动态链接共享库，作用类似windows里的.dll文件。<br>/sbin：系统管理命令，这 里存放的是系统管理员使用的管理程序。<br>/tmp：公用的临时文件存储 点。<br>/root：系统管理员的主目 录。<br>/mnt：系统提供这个目录是 让用户临时挂载其他的文件系统。<br>/lost+found：这个 目录平时是空的，系统非正常关机而留下“无家可归”的文件就在这里。<br>/proc：虚拟的目录，是系 统内存的映射。可直接访问这个目录来获取系统信息。<br>/var：某些大文件的溢出 区，比方说各种服务的日志文件。<br>/usr：最庞大的目录，要用 到的应用程序和文件几乎都在这个目录。其中包含：<br>/usr/x11r6：存放x window的目录。<br>/usr/bin：众多的应用程序。<br>/usr/sbin：超级用户的一些管理程序。<br>/usr/doc：linux文档。<br>/usr/include：linux下开发和编译应用程序所需要的头文件。<br>/usr/lib：常用的动态链接库和软件包的配置文件。<br>/usr/man：帮助文档。<br>/usr/src：源代码，linux内核的源代码就放在/usr/src/linux 里。<br>/usr/local/bin：本地增加的命令。<br>/usr/local/lib：本地增加的库根文件系统。  </p><p>通常情况下，根文件系统所占空间一般应该比较小，因为其中的绝大部分文件都不需要经常改动，而且包括严格的文件和一个小的 不经常改变的文件系统不容易损坏。除了可能的一个叫/vmlinuz标准的系统引导映像之外，根目录一般不含任何文 件。所有其他文件在根文件系统的子目录中。   </p><h4 id="1-bin目录"><a href="#1-bin目录" class="headerlink" title="1. /bin目录"></a>1. /bin目录</h4><p>/bin目录包含了引导启动所需的命令或普通用户可能用的命令(可能在引导启动后)。这些命 令都是二进制文件的可执行程序(bin是binary的简称)，多是系统中重要的系统文件。   </p><h4 id="2-sbin目录"><a href="#2-sbin目录" class="headerlink" title="2. /sbin目录"></a>2. /sbin目录</h4><p>/sbin目录类似/bin ，也用于存储二进制文件。因为其中的大部分文件多是系统管理员使用的基本的系统程序，所以虽然普通用户必要且允许时可以使用，但一般不给普通用户使 用。   </p><h4 id="3-etc目录"><a href="#3-etc目录" class="headerlink" title="3. /etc目录"></a>3. /etc目录</h4><p>/etc目录存放着各种系统配置文件，其中包括了用户信息文件/etc/passwd， 系统初始化文件/etc/rc等。linux正是靠这些文件才得以正常地运行。   </p><h4 id="4-root目录"><a href="#4-root目录" class="headerlink" title="4. /root目录"></a>4. /root目录</h4><p>/root目录是超级用户的目录。   </p><h4 id="5-lib目录"><a href="#5-lib目录" class="headerlink" title="5. /lib目录"></a>5. /lib目录</h4><p>/lib目录是根文件系统上的程序所需的共享库，存放了根文件系统程序运行所需的共享文件。 这些文件包含了可被许多程序共享的代码，以避免每个程序都包含有相同的子程序的副本，故可以使得可执行文件变得更小，节省空间。   </p><h4 id="6-lib-modules目录"><a href="#6-lib-modules目录" class="headerlink" title="6. /lib/modules目录"></a>6. /lib/modules目录</h4><p>/lib/modules目录包含系统核心可加载各种模块，尤其是那些在恢复损坏的系统时重 新引导系统所需的模块(例如网络和文件系统驱动)。   </p><h4 id="7-dev目录"><a href="#7-dev目录" class="headerlink" title="7. /dev目录"></a>7. /dev目录</h4><p>/dev目录存放了设备文件，即设备驱动程序，用户通过这些文件访问外部设备。比如，用户可 以通过访问/dev/mouse来访问鼠标的输入，就像访问其他文件一样。   </p><h4 id="8-tmp目录"><a href="#8-tmp目录" class="headerlink" title="8. /tmp目录"></a>8. /tmp目录</h4><p>/tmp目录存放程序在运行时产生的信息和数据。但在引导启动后，运行的程序最好使用/var/tmp来 代替/tmp，因为前者可能拥有一个更大的磁盘空间。   </p><h4 id="9-boot目录"><a href="#9-boot目录" class="headerlink" title="9. /boot目录"></a>9. /boot目录</h4><p>/boot目录存放引导加载器(bootstrap loader)使用的文件，如lilo，核心映像也经常放在这里，而不是放在根目录中。但是如果有许多核心映像，这个目录就可能变得很大，这时使用单独的 文件系统会更好一些。还有一点要注意的是，要确保核心映像必须在ide硬盘的前1024柱面内。   </p><h4 id="10-mnt目录"><a href="#10-mnt目录" class="headerlink" title="10. /mnt目录"></a>10. /mnt目录</h4><p>/mnt目录是系统管理员临时安装(mount)文件系统的安装点。程序并不自动支持安装到/mnt 。/mnt下面可以分为许多子目录，例如/mnt/dosa可能是使用 msdos文件系统的软驱，而/mnt/exta可能是使用ext2文件系统的软驱，/mnt/cdrom光 驱等等。   </p><h4 id="11-proc-usr-var-home目录"><a href="#11-proc-usr-var-home目录" class="headerlink" title="11. /proc, /usr, /var, /home目录"></a>11. /proc, /usr, /var, /home目录</h4><p>其他文件系统的安装点。</p><p>目录树可以分为小的部分，每个部分可以在自己的磁盘或分区上。主要部分是根、/usr 、/var 和 /home 文件系统。每个部分有不同的目的。<br>　　每台机器都有根文件系统，它包含系统引导和使其他文件系统得以mount所必要的文件，根文件系统应该有单用户状态所必须的足够的内容。还应该包括修复损坏 系统、恢复备份等的工具。<br>　　/usr 文件系统包含所有命令、库、man页和其他一般操作中所需的不改变的文件。 /usr 不应该有 一般使用中要修改的文件。这样允许此文件系统中的文件通过网络共享，这样可以更有效，因为这样节省了磁盘空间(/usr 很容易是数百兆)，且易于管理 (当升级应用时，只有主/usr 需要改变，而无须改变每台机器) 即使此文件系统在本地盘上，也可以只读mount，以减少系统崩溃时文件系统的损 坏。<br>　　/var 文件系统包含会改变的文件，比如spool目录(mail、news、打印机等用的)， log文件、 formatted manual pages和暂存文件。传统上/var 的所有东西曾在 /usr 下的某个地方，但这样/usr 就不可能只读安装 了。<br>　　/home 文件系统包含用户家目录，即系统上的所有实际数据。一个大的/home 可能要分为若干文件系统，需要在 /home 下加一级名字，如/home/students 、/home/staff 等。 </p><p>下面详细介绍：  </p><h4 id="etc文件系统"><a href="#etc文件系统" class="headerlink" title="/etc文件系统"></a>/etc文件系统</h4><p>/etc目录包含各种系统配置文件，下面说明其中的一些。其他的你应该知道它们属于哪个程序， 并阅读该程序的man页。许多网络配置文件也在/etc中。  </p><ol><li>/etc/rc或/etc/rc.d或/etc/rc?.d：启动、或改变运行级时运 行的脚本或脚本的目录。  </li><li>/etc/passwd：用户数据库，其中的域给出了用户名、真实姓名、用户起始目 录、加密口令和用户的其他信息。  </li><li>/etc/fdprm：软盘参数表，用以说明不同的软盘格式。可用setfdprm进 行设置。更多的信息见setfdprm的帮助页。  </li><li>/etc/fstab：指定启动时需要自动安装的文件系统列表。也包括用swapon -a启用的swap区的信息。  </li><li>/etc/group：类似/etc/passwd ，但说明的不是用户信息而是组的信息。包括组的各种数据。  </li><li>/etc/inittab：init 的配置文件。  </li><li>/etc/issue：包括用户在登录提示符前的输出信息。通常包括系统的一段短说明 或欢迎信息。具体内容由系统管理员确定。  </li><li>/etc/magic：“file”的配置文件。包含不同文件格式的说 明，“file”基于它猜测文件类型。  </li><li>/etc/motd：motd是message of the day的缩写，用户成功登录后自动输出。内容由系统管理员确定。<br>常用于通告信息，如计划关机时间的警告等。</li><li>/etc/mtab：当前安装的文件系统列表。由脚本(scritp)初始化，并由 mount命令自动更新。当需要一个当前安装的文件系统的列表时使用(例如df命令)。  </li><li>/etc/shadow：在安装了影子(shadow)口令软件的系统上的影子口令 文件。影子口令文件  将/etc/passwd文件中的加密口令移动到/etc/shadow中，而后者只对超级用户(root)可读。这使破译口令更困 难，以此增加系统的安全性。  </li><li>/etc/login.defs：login命令的配置文件。  </li><li>/etc/printcap：类似/etc/termcap ，但针对打印机。语法不同。  </li><li>/etc/profile 、/etc/csh.login、/etc/csh.cshrc：登 录或启动时bourne或cshells执行的文件。这允许系统管理员为所有用户建立全局缺省环境。  </li><li>/etc/securetty：确认安全终端，即哪个终端允许超级用户(root) 登录。一般只列出虚拟控制台，这样就不可能(至少很困难)通过调制解调器(modem)或网络闯入系统并得到超级用户特权。  </li><li>/etc/shells：列出可以使用的shell。chsh命令允许用户在本文件 指定范围内改变登录的shell。提供一台机器ftp服务的服务进程ftpd检查用户shell是否列在/etc/shells文件 中，如果不是，将不允许该用户登录。  </li><li>/etc/termcap：终端性能数据库。说明不同的终端用什么“转义序列”控 制。写程序时不直接输出转义<br>序列(这样只能工作于特定品牌的终端)，而是从/etc/termcap中查找要做的工作的 正确序列。这样，多数的程序可以在多数终端上运行。  </li></ol><h4 id="dev文件系统"><a href="#dev文件系统" class="headerlink" title="/dev文件系统"></a>/dev文件系统</h4><p>/dev目录包括所有设备的设备文件。设备文件用特定的约定命名，这在设备列表中说明。设备文件在安装时由系 统产生，以后可以用/dev/makedev描述。/dev/makedev.local 是系统管理员为本地设备文件(或连接)写的描述文稿(即如一些非标准设备驱动不是标准makedev 的一部分)。下面简要介绍/dev下 一些常用文件。  </p><ol><li>/dev/console：系统控制台，也就是直接和系统连接的监视器。  </li><li>/dev/hd：ide硬盘驱动程序接口。如：/dev/hda指的是第一个硬 盘，had1则是指/dev/hda的第一个分区。如系统中有其他的硬盘，则依次为/dev /hdb、/dev/hdc、. . . . . .；如有多个分区则依次为hda1、hda2 . . . . . .  </li><li>/dev/sd：scsi磁盘驱动程序接口。如系统有scsi硬盘，就不会访问/dev/had， 而会访问/dev/sda。</li><li>/dev/fd：软驱设备驱动程序。如：/dev/fd0指 系统的第一个软盘，也就是通常所说的a盘，/dev/fd1指第二个软盘，. . . . . .而/dev/fd1 h1440则表示访问驱动器1中的4.5高密盘。  </li><li>/dev/st：scsi磁带驱动器驱动程序。  </li><li>/dev/tty：提供虚拟控制台支持。如：/dev/tty1指 的是系统的第一个虚拟控制台，/dev/tty2则是系统的第二个虚拟控制台。  </li><li>/dev/pty：提供远程登陆伪终端支持。在进行telnet登录时就要用到/dev/pty设备。  </li><li>/dev/ttys：计算机串行接口，对于dos来说就是“com1”口。  </li><li>/dev/cua：计算机串行接口，与调制解调器一起使用的设备。  </li><li>/dev/null：“黑洞”，所有写入该设备的信息都将消失。例如：当想要将屏幕 上的输出信息隐藏起来<br>时，只要将输出信息输入到/dev/null中即可。  </li></ol><h4 id="usr文件系统"><a href="#usr文件系统" class="headerlink" title="/usr文件系统"></a>/usr文件系统</h4><p>/usr是个很重要的目录，通常这一文件系统很大，因为所有程序安装在这里。/usr里 的所有文件一般来自linux发行版；本地安装的程序和其他东西在/usr/local下，因为这样可以在升级新版系 统或新发行版时无须重新安装全部程序。/usr目录下的许多内容是可选的，但这些功能会使用户使用系统更加有效。/usr可容纳许多大型的软件包和它们的 配置文件。下面列出一些重要的目录(一些不太重要的目录被省略了)。  </p><ol><li>/usr/x11r6：包含x window系统的所有可执行程序、配置文件和支持文件。为简化x的开发和安装，x的文件没有集成到系统中。x window系统是一个功能强大的图形环境，提供了大量的图形工具程序。用户如果对microsoft windows比较熟悉的话，就不会对x window系统感到束手无策了。  </li><li>/usr/x386：类似/usr/x11r6 ，但是是专门给x 11 release 5的。  </li><li>/usr/bin：集中了几乎所有用户命令，是系统的软件库。另有些命令在/bin或/usr/local/bin中。  </li><li>/usr/sbin：包括了根文件系统不必要的系统管理命令，例如多数服务程序。  </li><li>/usr/man、/usr/info、/usr/doc：这些目录包含所有手册页、 gnu信息文档和各种其他文档文件。每个联机手册的“节”都有两个子目录。例如：/usr/man/man1中包含联机手册第一节的源码(没有格式化的原 始文件)，/usr/man/cat1包含第一节已格式化的内容。联机手册分为以下九节：内部命令、系统调用、库函数、设备、文件格式、游戏、宏软件包、 系统管理和核心程序。  </li><li>/usr/include：包含了c语言的头文件，这些文件多以.h结尾，用来描述c 语言程序中用到的数据结构、<br>子过程和常量。为了保持一致性，这实际上应该放在/usr/lib下，但习惯上一直沿用了这个名字。  </li><li>/usr/lib：包含了程序或子系统的不变的数据文件，包括一些site - wide配置文件。名字lib来源于库(library); 编程的原始库也存在/usr/lib 里。当编译程序时，程序便会和其中的库进行连接。也有许多程序把配置文件存入其中。  </li><li>/usr/local：本地安装的软件和其他文件放在这里。这与/usr很相似。用户 可能会在这发现一些比较大<br>的软件包，如tex、emacs等。  </li></ol><h4 id="var文件系统"><a href="#var文件系统" class="headerlink" title="/var文件系统"></a>/var文件系统</h4><p>/var包含系统一般运行时要改变的数据。通常这些数据所在的目录的大小是要经常变化或扩充 的。原来/var目录中有些内容是在/usr中的，但为了保持/usr目录的相对稳定，就把那些需要经常改变的目录放到/var中了。每个系统是特定的， 即不通过网络与其他计算机共享。下面列出一些重要的目录(一些不太重要的目录省略了)。  </p><ol><li>/var/catman：包括了格式化过的帮助(man)页。帮助页的源文件一般存在 /usr/man/catman中；有些man页可能有预格式化的版本，存在/usr/man/cat中。而其他的man页在第一次看时都需要格式化，格 式化完的版本存在/var/man中，这样其他人再看相同的页时就无须等待格式化了。(/var/catman经常被 清除，就像清除临时目录一样。)  </li><li>/var/lib：存放系统正常运行时要改变的文件。  </li><li>/var/local：存放/usr/local中 安装的程序的可变数据(即系统管理员安装的程序)。注意，如果必要，即使本地安装的程序也会使用其他/var目录，例如/var/lock 。  </li><li>/var/lock：锁定文件。许多程序遵循在/var/lock中 产生一个锁定文件的约定，以用来支持他们正在<br>使用某个特定的设备或文件。其他程序注意到这个锁定文件时，就不会再使用这个设备或文件。  </li><li>/var/log：各种程序的日志(log)文件，尤其是login (/var/log/wtmplog纪 录所有到系统的登录和注销) 和syslog (/var/log/messages 纪录存储所有核心和系统程序信息)。/var/log 里的文件经常不确定地增长，应该定期清除。  </li><li>/var/run：保存在下一次系统引导前有效的关于系统的信息文件。例如，/var/run/utmp包 含当前登录的用户的信息。  </li><li>/var/spool：放置“假脱机(spool)”程序的目录，如mail、 news、打印队列和其他队列工作的目录。每个不同的spool在/var/spool下有自己的子目录，例如，用户的邮箱就存放在/var/spool/mail 中。  </li><li>/var/tmp：比/tmp允许更大的或需要存在较长时间的临时文件。注意系统管理 员可能不允许/var/tmp有很旧的文件。  </li></ol><h4 id="proc文件系统"><a href="#proc文件系统" class="headerlink" title="/proc文件系统"></a>/proc文件系统</h4><p>/proc文件系统是一个伪的文件系统，就是说它是一个实际上不存在的目录，因而这是一个非 常特殊的目录。它并不存在于某个磁盘上，而是由核心在内存中产生。这个目录用于提供关于系统的信息。下面说明一些最重要的文件和目录(/proc文件系统 在proc man页中有更详细的说明)。  </p><ol><li>/proc/x：关于进程x的信息目录，这x是这一进程的标识号。每个进程在 /proc下有一个名为自己进程号的目录。  </li><li>/proc/cpuinfo：存放处理器(cpu)的信息，如cpu的类型、制造商、 型号和性能等。  </li><li>/proc/devices：当前运行的核心配置的设备驱动的列表。  </li><li>/proc/dma：显示当前使用的dma通道。  </li><li>/proc/filesystems：核心配置的文件系统信息。  </li><li>/proc/interrupts：显示被占用的中断信息和占用者的信息，以及被占用 的数量。  </li><li>/proc/ioports：当前使用的i/o端口。  </li><li>/proc/kcore：系统物理内存映像。与物理内存大小完全一样，然而实际上没有 占用这么多内存；它仅<br>仅是在程序访问它时才被创建。(注意：除非你把它拷贝到什么地方，否则/proc下没有任何东西占用任何磁盘空间。)  </li><li>/proc/kmsg：核心输出的消息。也会被送到syslog。  </li><li>/proc/ksyms：核心符号表。  </li><li>/proc/loadavg：系统“平均负载”；3个没有意义的指示器指出系统当前 的工作量。  </li><li>/proc/meminfo：各种存储器使用信息，包括物理内存和交换分区 (swap)。  </li><li>/proc/modules：存放当前加载了哪些核心模块信息。  </li><li>/proc/net：网络协议状态信息。  </li><li>/proc/self：存放到查看/proc的 程序的进程目录的符号连接。当2个进程查看/proc时，这将会是不同的连接。这主要便于程序得到它自己的进程目录。  </li><li>/proc/stat：系统的不同状态，例如，系统启动后页面发生错误的次数。  </li><li>/proc/uptime：系统启动的时间长度。  </li><li>/proc/version：核心版本。  </li></ol><h4 id="usr-local"><a href="#usr-local" class="headerlink" title="/usr/local"></a>/usr/local</h4><p>一般是你安装软件的目录，这个目录就相当于在windows下的programefiles这个目录   </p><h4 id="opt"><a href="#opt" class="headerlink" title="/opt"></a>/opt</h4><p>这个目录是一些大型软件的安装目录，或者是一些服务程序的安装目录  </p><p>举个例子：刚才装的测试版firefox，就可以装到/opt/firefox_beta目录下，/opt/firefox_beta目录下面就包含了运 行firefox所需要的所有文件、库、数据等等。要删除firefox的时候，你只需删除/opt/firefox_beta目录即可，非常简单。  </p><h4 id="usr-local-1"><a href="#usr-local-1" class="headerlink" title="/usr/local"></a>/usr/local</h4><p>这里主要存放那些手动安装的软件，即 不是通过“新立得”或apt-get安装的软件 。 它和/usr目录具有相类似的目录结构 。让软件包管理器来管理/usr目录，而把自定义的脚本(scripts)放到/usr/local目录下面，我想这应该是个不错的主意</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;==&lt;strong&gt;原文链接：&lt;a href=&quot;http://www.cnblogs.com/xningge/p/8331631.html&quot;&gt;http://www.cnblogs.com/xningge/p/8331631.html&lt;/a&gt;&lt;/st</summary>
      
    
    
    
    <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
    <category term="转载" scheme="http://yoursite.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
    <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Spring—@Transactional注解</title>
    <link href="http://yoursite.com/2018/03/01/Spring%E2%80%94-Transactional%E6%B3%A8%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/03/01/Spring%E2%80%94-Transactional%E6%B3%A8%E8%A7%A3/</id>
    <published>2018-02-28T19:20:55.000Z</published>
    <updated>2020-04-01T08:17:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>在日常开发中事物管理是非常重要的，当出现异常情况时，它可以保证数据的一致性。  </p><h3 id="Spring事物管理方式"><a href="#Spring事物管理方式" class="headerlink" title="Spring事物管理方式"></a>Spring事物管理方式</h3><p>Spring也对事物做了丰富的支持。Spring 事务管理分为编码式和声明式的两种方式。  </p><p>编程式事务指的是通过编码方式实现事务,编程式事务管理使用TransactionTemplate或者直接使用底层的PlatformTransactionManager。对于编程式事务管理，spring推荐使用TransactionTemplate。  </p><p>声明式事务基于 AOP,其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。  </p><p>声明式事务管理使业务代码逻辑不受污染, 因此在实际使用中声明式事务用的比较多。但是声明式事物管理的最小级别是方法级，而编程式事物管理的的最小级别是代码级。  </p><p>声明式事务有两种方式，一种是在配置文件（xml）中做相关的事务规则声明，另一种是基于@Transactional 注解的方式。注释配置是目前流行的使用方式。本文介绍的就是基于@Transactional注解的方式。  </p><h3 id="实现-Transactional-注解管理事务的步骤"><a href="#实现-Transactional-注解管理事务的步骤" class="headerlink" title="实现@Transactional 注解管理事务的步骤"></a>实现@Transactional 注解管理事务的步骤</h3><p>使用@Transactional 注解管理事务的实现步骤分为两步</p><h4 id="第一步：在-xml-配置文件中添加事务配置信息"><a href="#第一步：在-xml-配置文件中添加事务配置信息" class="headerlink" title="第一步：在 xml 配置文件中添加事务配置信息"></a>第一步：在 xml 配置文件中添加事务配置信息</h4><p>以 DataSourceTransactionManager 为例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--spring声明式事务管理控制--&gt;</span><br><span class="line">  &lt;!--配置事务管理器类--&gt;</span><br><span class="line">  &lt;bean id&#x3D;&quot;transactionManager&quot;</span><br><span class="line">    class&#x3D;&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!--设置注解驱动的事务管理--&gt;</span><br><span class="line">  &lt;tx:annotation-driven transaction-manager&#x3D;&quot;transactionManager&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure><p>####第二步，将@Transactional 注解添加到合适的方法或类上，并设置合适的属性信息。<br>@Transactional 注解的属性信息:</p><table><thead><tr><th>属性</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>value</td><td>String</td><td>可选的限定描述符，指定使用的事务管理器</td></tr><tr><td>propagation</td><td>enum: Propagation</td><td>可选的事务传播行为设置</td></tr><tr><td>isolation</td><td>enum: Isolation</td><td>可选的事务隔离级别设置</td></tr><tr><td>readOnly</td><td>boolean</td><td>读写或只读事务，默认读写</td></tr><tr><td>timeout</td><td>int (in seconds granularity)</td><td>事务超时时间设置</td></tr><tr><td>rollbackFor</td><td>Class对象数组，必须继承自Throwable</td><td>导致事务回滚的异常类数组</td></tr><tr><td>rollbackForClassName</td><td>类名数组，必须继承自Throwable</td><td>导致事务回滚的异常类名字数组</td></tr><tr><td>noRollbackFor</td><td>Class对象数组，必须继承自Throwable</td><td>不会导致事务回滚的异常类数组</td></tr><tr><td>noRollbackForClassName</td><td>类名数组，必须继承自Throwable</td><td>不会导致事务回滚的异常类名字数组</td></tr></tbody></table><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><h4 id="Transactional作用的位置"><a href="#Transactional作用的位置" class="headerlink" title="@Transactional作用的位置"></a>@Transactional作用的位置</h4><p>@Transactional 可以作用于接口、接口方法、类以及类方法上。当作用于类上时，该类的所有 public 方法将都具有该类型的事务属性，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。<br>虽然 @Transactional 注解可以作用于接口、接口方法、类以及类方法上，但是 Spring 建议不要在接口或者接口方法上使用该注解，因为这只有在使用基于接口的代理时它才会生效。  </p><h4 id="Transactional-只能应用到-public-方法才有效"><a href="#Transactional-只能应用到-public-方法才有效" class="headerlink" title="@Transactional 只能应用到 public 方法才有效"></a>@Transactional 只能应用到 public 方法才有效</h4><p> @Transactional 注解应该只被应用到 public 方法上，这是由 Spring AOP 的本质决定的。如果你在 protected、private 或者默认可见性的方法上使用 @Transactional 注解，这将被忽略，也不会抛出任何异常。  </p><h4 id="正确的设置-Transactional-的-propagation-属性"><a href="#正确的设置-Transactional-的-propagation-属性" class="headerlink" title="正确的设置@Transactional 的 propagation 属性"></a>正确的设置@Transactional 的 propagation 属性</h4><ol><li><strong>Propagation.REQUIRED:</strong> propagation的默认值，支持当前事务，如果不存在，则创建一个新事务。</li><li><strong>Propagation.SUPPORTS:</strong> 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。 </li><li><strong>Propagation.MANDATORY:</strong> 支持当前事务，如果不存在则抛出异常。</li><li><strong>Propagation.REQUIRES_NEW:</strong> 创建一个新事务，如果存在当前事务，则挂起它。</li><li><strong>Propagation.NOT_SUPPORTED:</strong> 以非事务方式执行，如果当前事务存在，则挂起当前事务。</li><li><strong>Propagation.NEVER:</strong> 以非事务方式执行，如果存在事务，则抛出异常。</li><li><strong>Propagation.NESTED:</strong> 如果当前事务存在，则在嵌套事务中执行</li></ol><h4 id="正确的设置-Transactional-的-rollbackFor-属性"><a href="#正确的设置-Transactional-的-rollbackFor-属性" class="headerlink" title="正确的设置@Transactional 的 rollbackFor 属性"></a>正确的设置@Transactional 的 rollbackFor 属性</h4><p>默认情况下，如果在事务中抛出了未检查异常（继承自 RuntimeException 的异常）或者 Error，则 Spring 将回滚事务；除此之外，Spring 不会回滚事务。<br>而可以指定rollbackFor属性来设置回滚的异常等级，若在目标方法中抛出的异常是 rollbackFor 指定的异常的子类，事务同样会回滚。  </p><h4 id="内部调用-Transactional不起作用"><a href="#内部调用-Transactional不起作用" class="headerlink" title="内部调用@Transactional不起作用"></a>内部调用@Transactional不起作用</h4><p>默认情况下，只有来自外部的方法调用才会被AOP代理捕获，也就是，类内部方法调用本类内部的其他方法并不会引起事务行为，即使被调用方法使用@Transactional注解进行修饰。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在日常开发中事物管理是非常重要的，当出现异常情况时，它可以保证数据的一致性。  &lt;/p&gt;
&lt;h3 id=&quot;Spring事物管理方式&quot;&gt;&lt;a href=&quot;#Spring事物管理方式&quot; class=&quot;headerlink&quot; title=&quot;Spring事物管理方式&quot;&gt;&lt;/a&gt;Sp</summary>
      
    
    
    
    <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
    <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>lombok—@Accessors注解</title>
    <link href="http://yoursite.com/2018/02/06/lombok%E2%80%94-Accessors%E6%B3%A8%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/02/06/lombok%E2%80%94-Accessors%E6%B3%A8%E8%A7%A3/</id>
    <published>2018-02-06T01:07:55.000Z</published>
    <updated>2019-09-09T03:40:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>@Accessors 注解用来配置lombok如何产生和显示getters和setters的方法。<br>@Accessors有三个属性，分别是fluent,chain,prefix，@Accessors注解既可以注解在类上也可以注解在属性上  </p><h4 id="1-fluent"><a href="#1-fluent" class="headerlink" title="1.fluent"></a>1.fluent</h4><p>fluent为一个布尔值，如果为true生成的get/set方法则没有set/get前缀，默认为false<br>例如：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Accessors(flunet &#x3D; true)</span><br><span class="line">public class MyClass &#123;</span><br><span class="line">    @Getter</span><br><span class="line">    private int num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成的get方法为num()，而不是getNum()</p><h4 id="2-chain"><a href="#2-chain" class="headerlink" title="2.chain"></a>2.chain</h4><p>chain为一个布尔值，如果为true生成的set方法返回this，为false生成的set方法是void类型。默认为false，除非当fluent为true时，chain默认则为true</p><h4 id="3-prefix"><a href="#3-prefix" class="headerlink" title="3.prefix"></a>3.prefix</h4><p>prefix为一系列string类型，可以指定前缀，生成get/set方法时会去掉指定的前缀<br>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Accessors(prefix &#x3D; &quot;m&quot;)</span><br><span class="line">public class MyClass &#123;</span><br><span class="line">    @Getter</span><br><span class="line">    private int mNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成的get方法为getNum()，而不是getMNum()</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;@Accessors 注解用来配置lombok如何产生和显示getters和setters的方法。&lt;br&gt;@Accessors有三个属性，分别是fluent,chain,prefix，@Accessors注解既可以注解在类上也可以注解在属性上  &lt;/p&gt;
&lt;h4 id=&quot;1</summary>
      
    
    
    
    <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
    <category term="lombok" scheme="http://yoursite.com/tags/lombok/"/>
    
  </entry>
  
  <entry>
    <title>常用Idea插件</title>
    <link href="http://yoursite.com/2018/01/17/%E5%B8%B8%E7%94%A8Idea%E6%8F%92%E4%BB%B6/"/>
    <id>http://yoursite.com/2018/01/17/%E5%B8%B8%E7%94%A8Idea%E6%8F%92%E4%BB%B6/</id>
    <published>2018-01-16T18:21:52.000Z</published>
    <updated>2019-12-27T11:16:48.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/idea-plugins.jpg" alt="idea插件"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/idea-plugins.jpg&quot; alt=&quot;idea插件&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="IDE" scheme="http://yoursite.com/categories/IDE/"/>
    
    
    <category term="IDEA" scheme="http://yoursite.com/tags/IDEA/"/>
    
  </entry>
  
</feed>
